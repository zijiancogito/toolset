filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/countOfSmallerNumbersAfterSelf/countOfSmallerNumbersAfterSelf.cpp

function-decl: Solution::search search
param-decl: int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return i;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: k--
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   1: i += (1 << k)
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: k >= 0
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int i = 0;
   2: int k = step;
   Preds (1): B8
   Succs (1): B5

 [B7]
   1: step++
   Preds (1): B8
   Succs (1): B8

 [B8]
   1: (1 << step) <= this->n
   T: for (; [B8.1]; ...)
   Preds (2): B7 B9
   Succs (2): B7 B6

 [B9]
   1: int step = 0;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::compute compute
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int s = 0;
   2: return s;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::add add
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::countSmaller countSmaller
param-decl: int &; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: i--
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: int pos;
   2: this->add(pos)
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: i >= 0
   T: for (...; [B3.1]; ...)
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: int i;
   Preds (1): B5
   Succs (1): B3

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B0

 [B0 (EXIT)]
   Preds (2): B3 B5

function-decl: BinarySearchTreeNode::BinarySearchTreeNode BinarySearchTreeNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: BinarySearchTree::BinarySearchTree BinarySearchTree
param-decl: const int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: BinarySearchTree::~BinarySearchTree ~BinarySearchTree
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->freeTree(this->root)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: BinarySearchTree::insert insert
param-decl: const int; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->insert(this->root, value, numLessThan)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: BinarySearchTree::freeTree freeTree
param-decl: class BinarySearchTreeNode *; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: delete root
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: this->freeTree(root->right)
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: root->right (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B3.1]
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   1: this->freeTree(root->left)
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: root->left (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return;
   Preds (1): B7
   Succs (1): B0

 [B7]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (2): B1 B6

function-decl: BinarySearchTree::insert insert
param-decl: class BinarySearchTreeNode *; const int; int &; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: numLessThan += root->less
   2: root->count++
   3: return;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: this->insert(root->right, value, numLessThan)
   Preds (1): B4
   Succs (1): B0

 [B3]
   1: value (CXXConstructExpr, class BinarySearchTreeNode)
   2: new class BinarySearchTreeNode([B3.1])
   3: root->right = [B3.2]
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: numLessThan += root->less + root->count
   2: !root->right
   T: if [B4.2]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: value > root->val
   T: if [B5.1]
   Preds (1): B9
   Succs (2): B4 B1

 [B6]
   1: this->insert(root->left, value, numLessThan)
   Preds (1): B8
   Succs (1): B0

 [B7]
   1: value (CXXConstructExpr, class BinarySearchTreeNode)
   2: new class BinarySearchTreeNode([B7.1])
   3: root->left = [B7.2]
   Preds (1): B8
   Succs (1): B0

 [B8]
   1: root->less++
   T: if <null expr>
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: value < root->val
   T: if [B9.1]
   Preds (1): B10
   Succs (2): B8 B5

 [B0 (EXIT)]
   Preds (5): B1 B2 B3 B6 B7


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/rectangleArea/RectangleArea.cpp

function-decl: leetcode::Point::Point Point
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: leetcode::Rectangle::Rectangle Rectangle
param-decl: int; int; int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: leetcode::Rectangle::Area Area
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return (this->bottomRight.x - this->topLeft.x) * (this->topLeft.y - this->bottomRight.y);
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: leetcode::Rectangle::InclusiveArea InclusiveArea
param-decl: class leetcode::Rectangle &; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: return 0;
   Preds (4): B3 B4 B5 B6
   Succs (1): B0

 [B2]
   1: r.Area()
   2: return [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: r.bottomRight.y <= this->bottomRight.y
   T: if [B6.1] && [B5.1] && [B4.1] && [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: r.topLeft.y >= this->topLeft.y
   T: [B6.1] && [B5.1] && [B4.1] && ...
   Preds (1): B5
   Succs (2): B3 B1

 [B5]
   1: r.bottomRight.x >= this->bottomRight.x
   T: [B6.1] && [B5.1] && ...
   Preds (1): B6
   Succs (2): B4 B1

 [B6]
   1: r.topLeft.x <= this->topLeft.x
   T: [B6.1] && ...
   Preds (4): B8 B9 B10 B11
   Succs (2): B5 B1

 [B7]
   1: this->Area()
   2: return [B7.1];
   Preds (1): B8
   Succs (1): B0

 [B8]
   1: r.bottomRight.y >= this->bottomRight.y
   T: if [B11.1] && [B10.1] && [B9.1] && [B8.1]
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: r.topLeft.y <= this->topLeft.y
   T: [B11.1] && [B10.1] && [B9.1] && ...
   Preds (1): B10
   Succs (2): B8 B6

 [B10]
   1: r.bottomRight.x <= this->bottomRight.x
   T: [B11.1] && [B10.1] && ...
   Preds (1): B11
   Succs (2): B9 B6

 [B11]
   1: r.topLeft.x >= this->topLeft.x
   T: [B11.1] && ...
   Preds (1): B12
   Succs (2): B10 B6

 [B0 (EXIT)]
   Preds (3): B1 B2 B7

function-decl: leetcode::Rectangle::OverlappedArea OverlappedArea
param-decl: class leetcode::Rectangle &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int overlap_x;
   2: int overlap_y;
   3: return overlap_x * overlap_y;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: computeArea computeArea
param-decl: int; int; int; int; int; int; int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: r1.Area()
   2: r2.Area()
   3: r1.OverlappedArea(r2)
   4: return [B1.1] + [B1.2] - [B1.3];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return area;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: A, B, C, D (CXXConstructExpr, class leetcode::Rectangle)
   2: class leetcode::Rectangle r1(A, B, C, D);
   3: E, F, G, H (CXXConstructExpr, class leetcode::Rectangle)
   4: class leetcode::Rectangle r2(E, F, G, H);
   5: r1.InclusiveArea(r2)
   6: int area = r1.InclusiveArea(r2);
   7: area > 0
   T: if [B3.7]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/maximalSquare/MaximalSquare.cpp

function-decl: Solution::min min
param-decl: int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: [B4.1] ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: x
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: y
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: x < y
   T: [B4.1] ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::min min
param-decl: int; int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->min(y, z)
   2: this->min(x, [B1.1])
   3: return [B1.2];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::maximalSquare maximalSquare
param-decl: int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int col;
   2: int maxSize = 0;
   3: return maxSize * maxSize;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: int row;
   2: row <= 0
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/timeBasedKeyValueStore/TimeBasedKeyValueStore.cpp

function-decl: TimeMap::TimeMap TimeMap
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TimeMap::set set
param-decl: int; int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TimeMap::get get
param-decl: int; int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: auto it;
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/addAndSearchWord/AddAndSearchWord.cpp

function-decl: TrieNode::TrieNode TrieNode
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TrieNode::operator[] operator[]
param-decl: char; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int i = (idx - 'a') % MAX_CHARS;
   2: return this->childern[i];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TrieNode::operator[] operator[]
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int i = idx % MAX_CHARS;
   2: return this->childern[i];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TrieTree::TrieTree TrieTree
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TrieTree::~TrieTree ~TrieTree
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->freeTree(this->root)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TrieTree::put put
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: class TrieNode *node = this->root;
   2: node->isWord = true
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TrieTree::search search
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TrieTree::get get
param-decl: int &; class TrieNode *; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: class TrieNode *node = root;
   2: return node->isWord;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TrieTree::freeTree freeTree
param-decl: class TrieNode *; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: delete root
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   1: (*root)[i] (OperatorCall)
   2: this->freeTree([B3.1])
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < MAX_CHARS
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B1

function-decl: WordDictionary::addWord addWord
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: WordDictionary::search search
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1:  (CXXConstructExpr, class WordDictionary)
   2: class WordDictionary wd;
   3: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/cousinsInBinaryTree/CousinsInBinaryTree.cpp

function-decl: Solution::isCousins isCousins
param-decl: int *; int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return false;
   Preds (3): B2 B3 B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: dy (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: if [B4.4] && [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: int dx = 0;
   2: int dy = 0;
   3: int *px;
   4: dx (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: [B4.4] && ...
   Preds (1): B5
   Succs (2): B3 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::DepthAndParent DepthAndParent
param-decl: int *; int *&; int; int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return d;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return d;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: int d = 0;
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return depth;
   Preds (1): B7
   Succs (1): B0

 [B7]
   T: if <null expr>
   Preds (1): B9
   Succs (2): B6 B5

 [B8]
   1: return 0;
   Preds (1): B9
   Succs (1): B0

 [B9]
   T: if <null expr>
   Preds (1): B10
   Succs (2): B8 B7

 [B0 (EXIT)]
   Preds (5): B1 B2 B4 B6 B8


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/binaryTreeLevelOrderTraversal/binaryTreeLevelOrderTraversal.cpp

function-decl: TreeNode::TreeNode TreeNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: levelOrder levelOrder
param-decl: struct TreeNode *; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (2): B3 B4
   Succs (2): B1 B0

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: levelOrder1 levelOrder1
param-decl: struct TreeNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int i = 0;
   2: int vt;
   3: int step = 2;
   4: int j;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int q;
   2: int v;
   3: root (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B3.3]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: levelOrder2 levelOrder2
param-decl: struct TreeNode *; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: root->right (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B3.1] && [B2.1]
   Preds (1): B3
   Succs (2): B1 B0

 [B3]
   1: root (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B3.1] && ...
   Preds (3): B4 B5 B6
   Succs (2): B2 B0

 [B4]
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: root->left (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B6.1] && [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: root (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B6.1] && ...
   Preds (2): B7 B8
   Succs (2): B5 B3

 [B7]
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: int v;
   2: root (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B8.2]
   Preds (1): B9
   Succs (2): B7 B6

 [B0 (EXIT)]
   Preds (3): B1 B2 B3

function-decl: levelOrder3 levelOrder3
param-decl: struct TreeNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int level = 0;
   2: struct TreeNode *last = root;
   3: int q;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printTree printTree
param-decl: struct TreeNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: printTree(root->left)
   2: printTree(root->right)
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: printTree_level_order printTree_level_order
param-decl: struct TreeNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int q;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: createTree createTree
param-decl: int *; int; 

 [B15 (ENTRY)]
   Succs (1): B14

 [B1]
   1: return tree[0];
   Preds (2): B6 B7
   Succs (1): B0

 [B2]
   1: i++
   Preds (3): B3 B4 B5
   Succs (1): B7

 [B3]
   1: tree[i]->right = tree[pos++]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: tree[i]->left = tree[pos++]
   2: pos < n
   T: if [B4.2]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: tree[i] (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B2

 [B6]
   1: pos < n
   T: for (...; [B7.1] && [B6.1]; ...)
   Preds (1): B7
   Succs (2): B5 B1

 [B7]
   1: i < n
   T: [B7.1] && ...
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B8]
   1: int pos = 1;
   2: int i = 0;
   Preds (1): B13
   Succs (1): B7

 [B9]
   1: i++
   Preds (2): B10 B11
   Succs (1): B13

 [B10]
   1: a[i] (CXXConstructExpr, struct TreeNode)
   2: new struct TreeNode([B10.1])
   3: tree[i] = [B10.2]
   Preds (1): B12
   Succs (1): B9

 [B11]
   T: continue;
   Preds (1): B12
   Succs (1): B9

 [B12]
   1: a[i] == 0
   T: if [B12.1]
   Preds (1): B13
   Succs (2): B11 B10

 [B13]
   1: i < n
   T: for (...; [B13.1]; ...)
   Preds (2): B9 B14
   Succs (2): B12 B8

 [B14]
   1: new struct TreeNode *[n]
   2: struct TreeNode **tree = new struct TreeNode *[n];
   3: int i = 0;
   Preds (1): B15
   Succs (1): B13

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printMatrix printMatrix
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: struct TreeNode *p;
   2: int a[] = {1, 2, 3, 4, 5, 0, 0};
   3: createTree(a, sizeof (a) / sizeof(int))
   4: p = [B1.3]
   5: printTree_level_order(p)
   6: int b[] = {1, 0, 2};
   7: createTree(b, sizeof (b) / sizeof(int))
   8: p = [B1.7]
   9: printTree_level_order(p)
  10: int c[] = {1, 2, 0, 3, 0, 4, 0, 5};
  11: createTree(c, sizeof (c) / sizeof(int))
  12: p = [B1.11]
  13: printTree_level_order(p)
  14: int d[] = {1, 2, 3, 4, 0, 0, 5};
  15: createTree(d, sizeof (d) / sizeof(int))
  16: p = [B1.15]
  17: printTree_level_order(p)
  18: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/binaryTreeLevelOrderTraversal/binaryTreeLevelOrderTraversal.II.cpp

function-decl: Solution::levelOrderBottom levelOrderBottom
param-decl: int *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int i = 0;
   2: int step = 2;
   3: int j;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int v;
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/removeDuplicatesFromSortedList/removeDuplicatesFromSortedList.cpp

function-decl: ListNode::ListNode ListNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: deleteDuplicates deleteDuplicates
param-decl: struct ListNode *; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: return head;
   Preds (2): B6 B7
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B7

 [B3]
   1: p = p->next
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: p->next = p->next->next
   T: continue;
   Preds (1): B5
   Succs (1): B2

 [B5]
   1: p->val == p->next->val
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: p->next (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: for (...; [B7.1] && [B6.1]; )
   Preds (1): B7
   Succs (2): B5 B1

 [B7]
   1: p (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B7.1] && ...
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B8]
   1: struct ListNode *p = head;
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printList printList
param-decl: struct ListNode *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: createList createList
param-decl: int *; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return head;
   Preds (1): B6
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B6

 [B3]
   1: a[i] (CXXConstructExpr, struct ListNode)
   2: new struct ListNode([B3.1])
   3: p->next = [B3.2]
   4: p = p->next
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: a[i] (CXXConstructExpr, struct ListNode)
   2: new struct ListNode([B4.1])
   3: head = p = [B4.2]
   Preds (1): B5
   Succs (1): B2

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: i < n
   T: for (...; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: struct ListNode *head;
   2: struct ListNode *p;
   3: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {1, 1, 2, 3, 3};
   2: int b[] = {1, 1, 1};
   3: createList(a, sizeof (a) / sizeof(int))
   4: deleteDuplicates([B1.3])
   5: printList([B1.4])
   6: createList(b, sizeof (b) / sizeof(int))
   7: deleteDuplicates([B1.6])
   8: printList([B1.7])
   9: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/removeDuplicatesFromSortedList/removeDuplicatesFromSortedList.II.cpp

function-decl: ListNode::ListNode ListNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: deleteDuplicates deleteDuplicates
param-decl: struct ListNode *; 

 [B16 (ENTRY)]
   Succs (1): B15

 [B1]
   1: return head->next;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: dup == true
   T: if [B3.1]
   Preds (2): B13 B14
   Succs (2): B2 B1

 [B4]
   1: p = p->next
   Preds (4): B5 B6 B7 B10
   Succs (1): B14

 [B5]
   1: tail = p
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: dup == false
   T: if [B6.1]
   Preds (2): B8 B9
   Succs (2): B5 B4

 [B7]
   1: dup = false
   2: tail->next = p->next
   T: continue;
   Preds (1): B8
   Succs (1): B4

 [B8]
   1: p->val != p->next->val
   T: if [B9.1] && [B8.1]
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: dup == true
   T: [B9.1] && ...
   Preds (2): B11 B12
   Succs (2): B8 B6

 [B10]
   1: dup = true
   T: continue;
   Preds (1): B11
   Succs (1): B4

 [B11]
   1: p->val == p->next->val
   T: if [B12.1] && [B11.1]
   Preds (1): B12
   Succs (2): B10 B9

 [B12]
   1: dup == false
   T: [B12.1] && ...
   Preds (1): B13
   Succs (2): B11 B9

 [B13]
   1: p->next (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: for (...; [B14.1] && [B13.1]; ...)
   Preds (1): B14
   Succs (2): B12 B3

 [B14]
   1: p (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B14.1] && ...
   Preds (2): B4 B15
   Succs (2): B13 B3

 [B15]
   1: -1 (CXXConstructExpr, struct ListNode)
   2: struct ListNode fake(-1);
   3: fake.next = head
   4: head = &fake
   5: struct ListNode *tail = head;
   6: _Bool dup = false;
   7: struct ListNode *p = head->next;
   Preds (1): B16
   Succs (1): B14

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printList printList
param-decl: struct ListNode *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: createList createList
param-decl: int *; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return head;
   Preds (1): B6
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B6

 [B3]
   1: a[i] (CXXConstructExpr, struct ListNode)
   2: new struct ListNode([B3.1])
   3: p->next = [B3.2]
   4: p = p->next
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: a[i] (CXXConstructExpr, struct ListNode)
   2: new struct ListNode([B4.1])
   3: head = p = [B4.2]
   Preds (1): B5
   Succs (1): B2

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: i < n
   T: for (...; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: struct ListNode *head;
   2: struct ListNode *p;
   3: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {1, 1, 2, 3, 3};
   2: int b[] = {1, 1, 1};
   3: int c[] = {1, 2, 3};
   4: int d[] = {3};
   5: createList(a, sizeof (a) / sizeof(int))
   6: deleteDuplicates([B1.5])
   7: printList([B1.6])
   8: createList(b, sizeof (b) / sizeof(int))
   9: deleteDuplicates([B1.8])
  10: printList([B1.9])
  11: createList(c, sizeof (c) / sizeof(int))
  12: deleteDuplicates([B1.11])
  13: printList([B1.12])
  14: createList(d, sizeof (d) / sizeof(int))
  15: deleteDuplicates([B1.14])
  16: printList([B1.15])
  17: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/searchForRange/searchForRange.cpp

function-decl: searchRange searchRange
param-decl: int *; int; int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: h >= 0
   T: do ... while [B1.1]
   Preds (1): B2
   Succs (2): B3 B0

 [B2]
   1: high = h
   2: binary_search(A, high + 1, n - 1, target)
   3: h = [B2.2]
   Preds (2): B3 B4
   Succs (1): B1

 [B3]
   Preds (1): B1
   Succs (1): B2

 [B4]
   1: int h = high;
   Preds (1): B5
   Succs (1): B2

 [B5]
   1: l >= 0
   T: do ... while [B5.1]
   Preds (1): B6
   Succs (2): B7 B4

 [B6]
   1: low = l
   2: binary_search(A, 0, low - 1, target)
   3: l = [B6.2]
   Preds (2): B7 B8
   Succs (1): B5

 [B7]
   Preds (1): B5
   Succs (1): B6

 [B8]
   1: low = high = pos
   2: int l = low;
   Preds (1): B9
   Succs (1): B6

 [B9]
   1: binary_search(A, 0, n - 1, target)
   2: int pos = binary_search(A, 0, n - 1, target);
   3: int v;
   4: int low = -1;
   5: int high = -1;
   6: pos >= 0
   T: if [B9.6]
   Preds (1): B10
   Succs (2): B8 B0

 [B0 (EXIT)]
   Preds (2): B1 B9

function-decl: binary_search binary_search
param-decl: int *; int; int; int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return -1;
   Preds (1): B9
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B9

 [B3]
   1: high = mid - 1
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: key < A[mid]
   T: if [B4.1]
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   1: low = mid + 1
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: key > A[mid]
   T: if [B6.1]
   Preds (1): B8
   Succs (2): B5 B4

 [B7]
   1: return mid;
   Preds (1): B8
   Succs (1): B0

 [B8]
   1: int mid = low + (high - low) / 2;
   2: A[mid] == key
   T: if [B8.2]
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: low <= high
   T: while [B9.1]
   Preds (2): B2 B10
   Succs (2): B8 B1

 [B0 (EXIT)]
   Preds (2): B1 B7

function-decl: printVector printVector
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: const int cnt = 6;
   2: int a[6] = {5, 7, 7, 8, 8, 10};
   3: int v;
   4: int b[6] = {5, 5, 5, 8, 8, 10};
   5: int c[6] = {5, 5, 5, 5, 5, 5};
   6: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/removeElement/removeElement.cpp

function-decl: Solution::removeElement removeElement
param-decl: int &; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int pos = 0;
   2: return pos;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::removeElement removeElement
param-decl: int *; int; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return tail + 1;
   Preds (1): B6
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B6

 [B3]
   1: i++
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: A[i] = A[tail--]
   T: continue;
   Preds (1): B5
   Succs (1): B2

 [B5]
   1: A[i] == elem
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: i <= tail
   T: while [B6.1]
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: int tail = n - 1;
   2: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/firstBadVersion/FirstBadVersion.cpp

function-decl: Solution::firstBadVersion firstBadVersion
param-decl: int; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: return -1;
   Preds (1): B9
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B9

 [B3]
   1: low = mid + 1
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: high = mid - 1
   Preds (1): B5
   Succs (1): B2

 [B5]
   1: isBadVersion(mid)
   T: if [B5.1]
   Preds (2): B7 B8
   Succs (2): B4 B3

 [B6]
   1: return mid;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: isBadVersion(mid - 1)
   2: ![B7.1]
   T: if [B8.2] && [B7.2]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: int mid = low + (high - low) / 2;
   2: isBadVersion(mid)
   T: [B8.2] && ...
   Preds (1): B9
   Succs (2): B7 B5

 [B9]
   1: low <= high
   T: while [B9.1]
   Preds (2): B2 B10
   Succs (2): B8 B1

 [B10]
   1: int low = 1;
   2: int high = n;
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (2): B1 B6


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/bestTimeToBuyAndSellStock/bestTimeToBuyAndSellStock.II.cpp

function-decl: Solution::maxProfit maxProfit
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::maxProfit01 maxProfit01
param-decl: int &; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: return max;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: low >= 0
   T: if [B3.1]
   Preds (1): B9
   Succs (2): B2 B1

 [B4]
   1: i++
   Preds (2): B5 B6
   Succs (1): B9

 [B5]
   1: low = -1
   Preds (1): B6
   Succs (1): B4

 [B6]
   T: if <null expr>
   Preds (2): B7 B8
   Succs (2): B5 B4

 [B7]
   1: low = i
   Preds (1): B8
   Succs (1): B6

 [B8]
   T: if <null expr>
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: i < len - 1
   T: for (...; [B9.1]; ...)
   Preds (2): B4 B10
   Succs (2): B8 B3

 [B10]
   1: int max = 0;
   2: int low = -1;
   3: int len;
   4: int i = 0;
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::maxProfit02 maxProfit02
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int profit = 0;
   2: return profit;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/bestTimeToBuyAndSellStock/bestTimeToBuyAndSellStock.cpp

function-decl: Solution::maxProfit maxProfit
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int max = 0;
   2: int begin = 0;
   3: int end = 0;
   4: int delta = 0;
   5: return max;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/bestTimeToBuyAndSellStock/bestTimeToBuyAndSellStock.III.cpp

function-decl: Solution::maxProfit maxProfit
param-decl: int &; 

 [B13 (ENTRY)]
   Succs (1): B12

 [B1]
   1: return max_profit;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < n
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int max_profit = 0;
   2: int i = 0;
   Preds (1): B6
   Succs (1): B3

 [B5]
   1: i--
   Preds (1): B6
   Succs (1): B6

 [B6]
   1: i >= 0
   T: for (...; [B6.1]; ...)
   Preds (2): B5 B7
   Succs (2): B5 B4

 [B7]
   1: int highestSellOutPrice;
   2: int i = n - 2;
   Preds (1): B9
   Succs (1): B6

 [B8]
   1: i++
   Preds (1): B9
   Succs (1): B9

 [B9]
   1: i < n
   T: for (...; [B9.1]; ...)
   Preds (2): B8 B10
   Succs (2): B8 B7

 [B10]
   1: int n;
   2: int lowestBuyInPrice;
   3: int i = 1;
   Preds (1): B12
   Succs (1): B9

 [B11]
   1: return 0;
   Preds (1): B12
   Succs (1): B0

 [B12]
   T: if <null expr>
   Preds (1): B13
   Succs (2): B11 B10

 [B0 (EXIT)]
   Preds (2): B1 B11


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/bestTimeToBuyAndSellStock/bestTimeToBuyAndSellStock.IV.cpp

function-decl: Solution::maxProfit maxProfit
param-decl: int; int &; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return sum;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < ndays
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int sum = 0;
   2: int i = 1;
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: k > ndays / 2
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B0

 [B6]
   1: return 0;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: int ndays;
   2: ndays <= 1
   T: if [B7.2]
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (3): B1 B5 B6

function-decl: Solution::maxProfit_DP01 maxProfit_DP01
param-decl: int; int &; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: trans++
   Preds (1): B6
   Succs (1): B8

 [B2]
   1: day++
   Preds (1): B4
   Succs (1): B6

 [B3]
   1: i++
   Preds (1): B4
   Succs (1): B4

 [B4]
   1: i <= day
   T: for (...; [B4.1]; ...)
   Preds (2): B3 B5
   Succs (2): B3 B2

 [B5]
   1: int m = 0;
   2: int i = 1;
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: day <= ndays
   T: for (...; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: int day = 1;
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: trans <= k
   T: for (...; [B8.1]; ...)
   Preds (2): B1 B9
   Succs (2): B7 B0

 [B9]
   1: int ndays;
   2: int trans = 1;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B8

function-decl: Solution::maxProfit_DP02 maxProfit_DP02
param-decl: int; int &; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: trans++
   Preds (1): B5
   Succs (1): B7

 [B2]
   1: day++
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: day < ndays
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: day <= ndays
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int day = 1;
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: trans <= k
   T: for (...; [B7.1]; ...)
   Preds (2): B1 B8
   Succs (2): B6 B0

 [B8]
   1: int ndays;
   2: int trans = 1;
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (1): B7

function-decl: Solution::maxProfit_DP03 maxProfit_DP03
param-decl: int; int &; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: trans++
   Preds (1): B5
   Succs (1): B7

 [B2]
   1: day++
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: day < ndays
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: day <= ndays
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int m;
   2: int day = 1;
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: trans <= k
   T: for (...; [B7.1]; ...)
   Preds (2): B1 B8
   Succs (2): B6 B0

 [B8]
   1: int ndays;
   2: int trans = 1;
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (1): B7


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/bestTimeToBuyAndSellStock/BestTimeToBuyAndSellStockWithTransactionFee.cpp

function-decl: Solution::max max
param-decl: int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: [B4.1] ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: x
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: y
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: x > y
   T: [B4.1] ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::max max
param-decl: int; int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->max(y, z)
   2: this->max(x, [B1.1])
   3: return [B1.2];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::maxProfit maxProfit
param-decl: int &; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::genPricesPairs genPricesPairs
param-decl: int &; int &; int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int low = -1;
   2: low >= 0
   T: if [B2.2]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::maxProfit_dp01 maxProfit_dp01
param-decl: int &; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::maxProfit_dp02 maxProfit_dp02
param-decl: int &; int &; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return 0;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::maxProfit_dp03 maxProfit_dp03
param-decl: int &; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int buy;
   2: int sell = 0;
   3: int pre_buy = 0;
   4: int pre_sell = 0;
   5: return sell;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/bestTimeToBuyAndSellStock/BestTimeToBuyAndSellStockWithCooldown.cpp

function-decl: Solution::maxProfit maxProfit
param-decl: int &; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < len
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 2;
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: return 0;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: int len;
   2: len < 2
   T: if [B5.2]
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (2): B2 B4


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/convertSortedListToBinarySearchTree/convertSortedListToBinarySearchTree.cpp

function-decl: ListNode::ListNode ListNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TreeNode::TreeNode TreeNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: sortedListToBST sortedListToBST
param-decl: struct ListNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int len = 0;
   2: sortedListToBST(0, len - 1, head)
   3: return [B1.2];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: sortedListToBST sortedListToBST
param-decl: int; int; struct ListNode *&; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int mid = low + (high - low) / 2;
   2: sortedListToBST(low, mid - 1, head)
   3: struct TreeNode *leftNode = sortedListToBST(low, mid - 1, head);
   4: head->val (CXXConstructExpr, struct TreeNode)
   5: new struct TreeNode([B1.4])
   6: struct TreeNode *node = new struct TreeNode(head->val);
   7: node->left = leftNode
   8: head = head->next
   9: sortedListToBST(mid + 1, high, head)
  10: struct TreeNode *rightNode = sortedListToBST(mid + 1, high, head);
  11: node->right = rightNode
  12: return node;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printTree_level_order printTree_level_order
param-decl: struct TreeNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int q;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: createList createList
param-decl: int *; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return head;
   Preds (1): B6
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B6

 [B3]
   1: a[i] (CXXConstructExpr, struct ListNode)
   2: new struct ListNode([B3.1])
   3: p->next = [B3.2]
   4: p = p->next
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: a[i] (CXXConstructExpr, struct ListNode)
   2: new struct ListNode([B4.1])
   3: head = p = [B4.2]
   Preds (1): B5
   Succs (1): B2

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: i < n
   T: for (...; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: struct ListNode *head;
   2: struct ListNode *p;
   3: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printList printList
param-decl: struct ListNode *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: createList(a, n)
   2: struct ListNode *head = createList(a, n);
   3: printList(head)
   4: sortedListToBST(head)
   5: struct TreeNode *root = sortedListToBST(head);
   6: printTree_level_order(root)
   7: delete [] a
   8: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: a[i] = i + 1
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < n
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: new int [n]
   2: int *a = new int [n];
   3: int i = 0;
   Preds (2): B6 B7
   Succs (1): B4

 [B6]
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: int n = 8;
   2: argc > 1
   T: if [B7.2]
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/trappingRainWater/trappingRainWater.cpp

function-decl: trap trap
param-decl: int *; int; 

 [B19 (ENTRY)]
   Succs (1): B18

 [B1]
   1: return result;
   Preds (1): B6
   Succs (1): B0

 [B2]
   1: i--
   Preds (1): B3
   Succs (1): B6

 [B3]
   1: result += (prevHigh - a[i])
   Preds (2): B4 B5
   Succs (1): B2

 [B4]
   1: prevHigh = a[i]
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: a[i] > prevHigh
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: i > maxIdx
   T: for (...; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: prevHigh = 0
   2: int i = n - 1;
   Preds (1): B12
   Succs (1): B6

 [B8]
   1: i++
   Preds (1): B9
   Succs (1): B12

 [B9]
   1: result += (prevHigh - a[i])
   Preds (2): B10 B11
   Succs (1): B8

 [B10]
   1: prevHigh = a[i]
   Preds (1): B11
   Succs (1): B9

 [B11]
   1: a[i] > prevHigh
   T: if [B11.1]
   Preds (1): B12
   Succs (2): B10 B9

 [B12]
   1: i < maxIdx
   T: for (...; [B12.1]; ...)
   Preds (2): B8 B13
   Succs (2): B11 B7

 [B13]
   1: int prevHigh = 0;
   2: int i = 0;
   Preds (1): B17
   Succs (1): B12

 [B14]
   1: i++
   Preds (2): B15 B16
   Succs (1): B17

 [B15]
   1: maxHigh = a[i]
   2: maxIdx = i
   Preds (1): B16
   Succs (1): B14

 [B16]
   1: a[i] > maxHigh
   T: if [B16.1]
   Preds (1): B17
   Succs (2): B15 B14

 [B17]
   1: i < n
   T: for (...; [B17.1]; ...)
   Preds (2): B14 B18
   Succs (2): B16 B13

 [B18]
   1: int result = 0;
   2: int maxHigh = 0;
   3: int maxIdx = 0;
   4: int i = 0;
   Preds (1): B19
   Succs (1): B17

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {2, 0, 2};
   2: int b[] = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
   3: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/powerOfFour/PowerOfFour.cpp

function-decl: Solution::isPowerOfFour isPowerOfFour
param-decl: int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return true;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: (num & mask) != 0
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return false;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: (num & num - 1) != 0
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return false;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: static int mask = 1431655765;
   2: num <= 0
   T: if [B7.2]
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (4): B1 B2 B4 B6


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/smallestStringStartingFromLeaf/SmallestStringStartingFromLeaf.cpp

function-decl: Solution::smallestFromLeaf smallestFromLeaf
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int str;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::smallestFromLeafHelper smallestFromLeafHelper
param-decl: int *; int; int &; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (2): B3 B4
   Succs (2): B1 B0

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   1: return;
   Preds (1): B6
   Succs (1): B0

 [B6]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B5 B4

 [B0 (EXIT)]
   Preds (3): B1 B2 B5


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/mergeTwoSortedList/mergeTwoSortedList.cpp

function-decl: Solution::Solution Solution
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::mergeTwoLists mergeTwoLists
param-decl: int *; int *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::mergeTwoLists01 mergeTwoLists01
param-decl: int *; int *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int *p1;
   2: static int dummy;
   3: int *prev;
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::mergeTwoLists02 mergeTwoLists02
param-decl: int *; int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int *l;
   2: int *rest;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::mergeTheRest mergeTheRest
param-decl: int *; int *; int *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B0

 [B0 (EXIT)]
   Preds (3): B1 B2 B3

function-decl: Solution::mergeTwoLists03 mergeTwoLists03
param-decl: int *; int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int *head;
   2: int **pTail;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/binarySearchTreeIterator/binarySearchTreeIterator.cpp

function-decl: BSTIterator::BSTIterator BSTIterator
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->pos = 0
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: BSTIterator::hasNext hasNext
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: BSTIterator::next next
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/excelSheetColumnTitle/excelSheetColumnTitle.cpp

function-decl: base26_int2str base26_int2str
param-decl: long long; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: char ch = 'A' + (n - 1) % 26;
   2: n -= (n - 1) % 26
   3: n /= 26
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: n > 0
   T: while [B3.1]
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: int ret;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B3

function-decl: base26_str2int base26_str2int
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: long long ret = 0;
   2: return ret;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: convertToTitle convertToTitle
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int ns;
   2: argc > 2
   T: if [B2.2]
   Preds (2): B3 B4
   Succs (2): B1 B0

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: long long n = 27;
   2: argc > 1
   T: if [B4.2]
   Preds (1): B5
   Succs (2): B3 B2

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/mostCommonWord/MostCommonWord.cpp

function-decl: Solution::isLetter isLetter
param-decl: char; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: [B3.1] && [B2.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: c <= 'z'
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: c >= 'a'
   T: [B3.1] && ...
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::mostCommonWord mostCommonWord
param-decl: int; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int word;
   2: int result;
   3: int max_cnt = 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/largestPerimeterTriangle/largestPerimeterTriangle.cpp

function-decl: Solution::largestPerimeter largestPerimeter
param-decl: int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/accountsMerge/AccountsMerge.cpp


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/palindromicSubstrings/PalindromicSubstrings.cpp

function-decl: Solution::countSubstrings countSubstrings
param-decl: int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: return cnt;
   Preds (1): B8
   Succs (1): B0

 [B2]
   1: i--
   Preds (1): B6
   Succs (1): B8

 [B3]
   1: j++
   Preds (2): B4 B5
   Succs (1): B6

 [B4]
   1: cnt++
   Preds (1): B5
   Succs (1): B3

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: j <= len - 1
   T: for (...; [B6.1]; ...)
   Preds (2): B3 B7
   Succs (2): B5 B2

 [B7]
   1: int j = i;
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: i >= 0
   T: for (...; [B8.1]; ...)
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int cnt = 0;
   2: int i = len - 1;
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: return len;
   Preds (1): B11
   Succs (1): B0

 [B11]
   1: int len;
   2: len <= 1
   T: if [B11.2]
   Preds (1): B12
   Succs (2): B10 B9

 [B0 (EXIT)]
   Preds (2): B1 B10


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/pathSum/pathSum.cpp

function-decl: Solution::Solution Solution
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::hasPathSum hasPathSum
param-decl: int *; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::hasPathSum3 hasPathSum3
param-decl: int *; int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return s == sum;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B1 B0

 [B3]
   1: return false;
   Preds (1): B4
   Succs (1): B0

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B0 (EXIT)]
   Preds (3): B1 B2 B3

function-decl: Solution::hasPathSum1 hasPathSum1
param-decl: int *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::hasPathSum2 hasPathSum2
param-decl: int *; int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: return false;
   Preds (2): B3 B4
   Succs (1): B0

 [B2]
   1: return true;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   T: if <null expr>
   Preds (2): B6 B7
   Succs (2): B3 B1

 [B5]
   1: return true;
   Preds (1): B6
   Succs (1): B0

 [B6]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   T: if <null expr>
   Preds (2): B8 B9
   Succs (2): B6 B4

 [B8]
   Preds (1): B9
   Succs (1): B7

 [B9]
   T: if <null expr>
   Preds (1): B11
   Succs (2): B8 B7

 [B10]
   1: return false;
   Preds (1): B11
   Succs (1): B0

 [B11]
   T: if <null expr>
   Preds (1): B12
   Succs (2): B10 B9

 [B0 (EXIT)]
   Preds (4): B1 B2 B5 B10


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/pathSum/pathSum.II.cpp

function-decl: Solution::pathSum pathSum
param-decl: int *; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int v;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::generatePathSum generatePathSum
param-decl: int *; int; int; int; int &; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B1 B0

 [B3]
   1: return;
   Preds (1): B4
   Succs (1): B0

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B0 (EXIT)]
   Preds (3): B1 B2 B3


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/peekingIterator/PeekingIterator.cpp

function-decl: PeekingIterator::takeNext takeNext
param-decl: 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: this->class Iterator::next()
   2: this->m_next = [B1.1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: this->class Iterator::hasNext()
   2: this->m_hasNext = [B2.1]
   3: this->m_hasNext (ImplicitCastExpr, LValueToRValue, _Bool)
   T: if [B2.3]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: PeekingIterator::PeekingIterator PeekingIterator
param-decl: const int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->takeNext()
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: PeekingIterator::peek peek
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return this->m_next;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: PeekingIterator::next next
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int temp = this->m_next;
   2: this->takeNext()
   3: return temp;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: PeekingIterator::hasNext hasNext
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return this->m_hasNext;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/shortestPalindrome/ShortestPalindrome.cpp

function-decl: isPalindrome isPalindrome
param-decl: int &; int; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return true;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: begin++
   2: end--
   3: ... , [B2.2]
   Preds (1): B4
   Succs (1): B5

 [B3]
   1: return false;
   Preds (1): B4
   Succs (1): B0

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: begin < end
   T: for (; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B0 (EXIT)]
   Preds (2): B1 B3

function-decl: shortestPalindrome_bf shortestPalindrome_bf
param-decl: int &; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: int t;
   Preds (2): B3 B5
   Succs (1): B0

 [B2]
   1: i--
   Preds (1): B4
   Succs (1): B5

 [B3]
   1: i++
   T: break;
   Preds (1): B4
   Succs (1): B1

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i >= 0
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int len;
   2: int i;
   3: i = len - 1
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B1

function-decl: shortestPalindrome_dp shortestPalindrome_dp
param-decl: int &; 

 [B15 (ENTRY)]
   Succs (1): B14

 [B1]
   1: int t;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   1: pos = i + 1
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < len
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int pos = 0;
   2: int i = 1;
   Preds (1): B13
   Succs (1): B5

 [B7]
   1: i--
   Preds (1): B11
   Succs (1): B13

 [B8]
   1: j++
   Preds (2): B9 B10
   Succs (1): B11

 [B9]
   Preds (1): B10
   Succs (1): B8

 [B10]
   T: if <null expr>
   Preds (1): B11
   Succs (2): B9 B8

 [B11]
   1: j < len
   T: for (...; [B11.1]; ...)
   Preds (2): B8 B12
   Succs (2): B10 B7

 [B12]
   1: int j = i;
   Preds (1): B13
   Succs (1): B11

 [B13]
   1: i >= 0
   T: for (...; [B13.1]; ...)
   Preds (2): B7 B14
   Succs (2): B12 B6

 [B14]
   1: int len;
   2: int i = len - 1;
   Preds (1): B15
   Succs (1): B13

 [B0 (EXIT)]
   Preds (1): B1

function-decl: shortestPalindrome_kmp shortestPalindrome_kmp
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int len;
   2: int pattern;
   3: int pos;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: shortestPalindrome shortestPalindrome
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int s;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/serializeAndDeserializeBinaryTree/SerializeAndDeserializeBinaryTree.cpp

function-decl: TreeNode::TreeNode TreeNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Codec::serialize serialize
param-decl: struct TreeNode *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Codec::deserialize deserialize
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Codec::serialize01 serialize01
param-decl: struct TreeNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int result;
   2: int v;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Codec::deserialize01 deserialize01
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int v;
   2: int index = 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Codec::serializeHelper serializeHelper
param-decl: struct TreeNode *; int &; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Codec::deserializeHelper deserializeHelper
param-decl: int &; int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return root;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: struct TreeNode *root;
   2: root (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Codec::split split
param-decl: const int &; char; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int ss;
   2: int item;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Codec::serialize02 serialize02
param-decl: struct TreeNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int out;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Codec::deserialize02 deserialize02
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int in;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Codec::serialize serialize
param-decl: struct TreeNode *; int &; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Codec::deserialize deserialize
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int val;
   2: struct TreeNode *node;
   3: return node;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1:  (CXXConstructExpr, class Codec)
   2: class Codec codec;
   3: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int s;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/containerWithMostWater/containerWithMostWater.cpp

function-decl: Solution::maxArea maxArea
param-decl: int &; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return maxArea;
   Preds (1): B8
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B8

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: [B7.1] ? [B5.1] : [B6.1]
   2: maxArea = [B4.1]
   T: if <null expr>
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   1: area
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: maxArea
   Preds (1): B7
   Succs (1): B4

 [B7]
   1: area > maxArea
   T: [B7.1] ? ... : ...
   Preds (1): B8
   Succs (2): B5 B6

 [B8]
   1: left < right
   T: while [B8.1]
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int maxArea = 0;
   2: int left = 0;
   3: int right;
   4: int area;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/repeatedDNASequences/repeatedDNASequences.cpp

function-decl: ACGT2Int ACGT2Int
param-decl: char; 

 [B7 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return -1;
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: ch (ImplicitCastExpr, IntegralCast, int)
   T: switch [B2.1]
   Preds (1): B7
   Succs (5): B3 B4 B5 B6 B1

 [B3]
  case 'T':
   1: return 3;
   Preds (1): B2
   Succs (1): B0

 [B4]
  case 'G':
   1: return 2;
   Preds (1): B2
   Succs (1): B0

 [B5]
  case 'C':
   1: return 1;
   Preds (1): B2
   Succs (1): B0

 [B6]
  case 'A':
   1: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (5): B1 B3 B4 B5 B6

function-decl: DNASeqs2Int DNASeqs2Int
param-decl: int &; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return result;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < MAX_LEN
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int result = 0;
   2: int i = 0;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: findRepeatedDnaSequences_01 findRepeatedDnaSequences_01
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int stat;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: findRepeatedDnaSequences_02 findRepeatedDnaSequences_02
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: findRepeatedDnaSequences findRepeatedDnaSequences
param-decl: int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: printVector printVector
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int s;
   2: argc > 1
   T: if [B2.2]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/grayCode/grayCode.cpp

function-decl: grayCode01 grayCode01
param-decl: int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: i++
   Preds (1): B5
   Succs (1): B7

 [B2]
   1: j++
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: j % 2 == 0
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: j < len
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int len;
   2: int j = 0;
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: i < n
   T: for (...; [B7.1]; ...)
   Preds (2): B1 B8
   Succs (2): B6 B0

 [B8]
   1: int v;
   2: int x = 0;
   3: int i = 0;
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (1): B7

function-decl: grayCode02 grayCode02
param-decl: int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: ++i
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < size
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int ret;
   2: int size = 1 << n;
   3: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: grayCode grayCode
param-decl: int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: printBits printBits
param-decl: int; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: i--
   Preds (2): B2 B3
   Succs (1): B4

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: n & (1 << i) (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: i >= 0
   T: for (...; [B4.1]; ...)
   Preds (2): B1 B5
   Succs (2): B3 B0

 [B5]
   1: int i = len - 1;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B4

function-decl: printVector printVector
param-decl: int &; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int it;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int v;
   2: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int n = 2;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/mergeIntervals/mergeIntervals.cpp

function-decl: Interval::Interval Interval
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Interval::Interval Interval
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: compare compare
param-decl: const struct Interval &; const struct Interval &; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: ([B4.1]) ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: lhs.end < rhs.end
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: lhs.start < rhs.start
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: lhs.start == rhs.start
   T: ([B4.1]) ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: merge merge
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: 1, 4 (CXXConstructExpr, struct Interval)
   2: struct Interval i1(1, 4);
   3: 0, 2 (CXXConstructExpr, struct Interval)
   4: struct Interval i2(0, 2);
   5: 3, 5 (CXXConstructExpr, struct Interval)
   6: struct Interval i3(3, 5);
   7: 15, 18 (CXXConstructExpr, struct Interval)
   8: struct Interval i4(15, 18);
   9: int intervals;
  10: int r;
  11: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/restoreIPAddresses/restoreIPAddresses.cpp

function-decl: restoreIpAddresses restoreIpAddresses
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int ip;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: restoreIpAddressesHelper restoreIpAddressesHelper
param-decl: int &; int; int; int; int &; 

 [B14 (ENTRY)]
   Succs (1): B13

 [B1]
   1: i++
   Preds (1): B3
   Succs (1): B6

 [B2]
   T: break;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: num == 0
   T: if [B3.1]
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: num < 256
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: i < start + 3
   T: for (...; [B6.1]; ...)
   Preds (2): B1 B7
   Succs (2): B5 B0

 [B7]
   1: int num = 0;
   2: int i = start;
   Preds (2): B9 B10
   Succs (1): B6

 [B8]
   1: return;
   Preds (1): B9
   Succs (1): B0

 [B9]
   1: start == len
   T: if [B10.1] && [B9.1]
   Preds (1): B10
   Succs (2): B8 B7

 [B10]
   1: partNum == 4
   T: [B10.1] && ...
   Preds (1): B12
   Succs (2): B9 B7

 [B11]
   1: return;
   Preds (2): B12 B13
   Succs (1): B0

 [B12]
   1: len - start > (4 - partNum) * 3
   T: if [B13.2] || [B12.1]
   Preds (1): B13
   Succs (2): B11 B10

 [B13]
   1: int len;
   2: len - start < 4 - partNum
   T: [B13.2] || ...
   Preds (1): B14
   Succs (2): B11 B12

 [B0 (EXIT)]
   Preds (4): B2 B6 B8 B11

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int s;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/mergeKSortedLists/mergeKSortedLists.cpp

function-decl: ListNode::ListNode ListNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: mergeKLists mergeKLists
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: struct ListNode *p;
   2: struct ListNode *p1;
   3: struct ListNode *p2;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: mergeTwoLists mergeTwoLists
param-decl: struct ListNode *; struct ListNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: mergeTwoLists02(head1, head2)
   2: return [B1.1];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: mergeTwoLists01(head1, head2)
   2: return [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: n (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: mergeTwoLists01 mergeTwoLists01
param-decl: struct ListNode *; struct ListNode *; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: return dummy.next;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: prev->next = p2
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: p2 (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B3.1]
   Preds (2): B8 B9
   Succs (2): B2 B1

 [B4]
   Preds (2): B5 B6
   Succs (1): B9

 [B5]
   1: prev->next = p2
   2: p2 = p2->next
   3: prev = prev->next
   4: prev->next = p1
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: prev = p1
   2: p1 = p1->next
   Preds (1): B7
   Succs (1): B4

 [B7]
   1: p1->val < p2->val
   T: if [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: p2 (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: while [B9.1] && [B8.1]
   Preds (1): B9
   Succs (2): B7 B3

 [B9]
   1: p1 (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B9.1] && ...
   Preds (2): B4 B10
   Succs (2): B8 B3

 [B10]
   1: struct ListNode *p1 = head1;
   2: struct ListNode *p2 = head2;
   3: 0 (CXXConstructExpr, struct ListNode)
   4: static struct ListNode dummy(0);
   5: dummy.next = p1
   6: struct ListNode *prev = &dummy;
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (1): B1

function-decl: mergeTwoLists02 mergeTwoLists02
param-decl: struct ListNode *; struct ListNode *; 

 [B15 (ENTRY)]
   Succs (1): B14

 [B1]
   1: pTail->next = p
   2: return pHead;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return p;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (3): B4 B5 B6
   Succs (2): B2 B1

 [B4]
   1: p = p2
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: p2 (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: p = p1
   Preds (1): B7
   Succs (1): B3

 [B7]
   1: struct ListNode *p;
   2: p1 (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B7.2]
   Preds (2): B12 B13
   Succs (2): B6 B5

 [B8]
   Preds (2): B9 B10
   Succs (1): B13

 [B9]
   1: TakeOutNode(pHead, pTail, p2)
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: TakeOutNode(pHead, pTail, p1)
   Preds (1): B11
   Succs (1): B8

 [B11]
   1: p1->val < p2->val
   T: if [B11.1]
   Preds (1): B12
   Succs (2): B10 B9

 [B12]
   1: p2 (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: while [B13.1] && [B12.1]
   Preds (1): B13
   Succs (2): B11 B7

 [B13]
   1: p1 (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B13.1] && ...
   Preds (2): B8 B14
   Succs (2): B12 B7

 [B14]
   1: struct ListNode *p1 = head1;
   2: struct ListNode *p2 = head2;
   3: struct ListNode *pHead;
   4: struct ListNode *pTail;
   Preds (1): B15
   Succs (1): B13

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: TakeOutNode TakeOutNode
param-decl: struct ListNode *&; struct ListNode *&; struct ListNode *&; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: p = pNext
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: tail->next = p
   2: tail = p
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: head = tail = p
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: struct ListNode *pNext = p->next;
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printList printList
param-decl: struct ListNode *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: createList createList
param-decl: int *; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return head;
   Preds (1): B6
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B6

 [B3]
   1: a[i] (CXXConstructExpr, struct ListNode)
   2: new struct ListNode([B3.1])
   3: p->next = [B3.2]
   4: p = p->next
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: a[i] (CXXConstructExpr, struct ListNode)
   2: new struct ListNode([B4.1])
   3: head = p = [B4.2]
   Preds (1): B5
   Succs (1): B2

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: i < n
   T: for (...; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: struct ListNode *head;
   2: struct ListNode *p;
   3: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < 10240
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int a[] = {1, 3, 5, 6, 7, 10};
   2: int b[] = {0, 4, 6, 8, 9, 11, 20, 30, 40};
   3: createList(a, sizeof (a) / sizeof(int))
   4: struct ListNode *p1 = createList(a, sizeof (a) / sizeof(int));
   5: createList(b, sizeof (b) / sizeof(int))
   6: struct ListNode *p2 = createList(b, sizeof (b) / sizeof(int));
   7: mergeTwoLists(p1, p2)
   8: printList([B4.7])
   9: int v;
  10: int i = 0;
   Preds (2): B5 B6
   Succs (1): B3

 [B5]
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: argc > 1
   T: if [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/pow/pow.cpp

function-decl: pow pow
param-decl: double; int; 

 [B13 (ENTRY)]
   Succs (1): B12

 [B1]
   1: [B4.1] ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: 1 / result
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: result (ImplicitCastExpr, LValueToRValue, double)
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: sign (ImplicitCastExpr, LValueToRValue, _Bool)
   T: [B4.1] ? ... : ...
   Preds (1): B9
   Succs (2): B2 B3

 [B5]
   Preds (1): B6
   Succs (1): B9

 [B6]
   1: exp >>= 1
   2: x *= x
   Preds (2): B7 B8
   Succs (1): B5

 [B7]
   1: result *= x
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: exp & 1 (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: if [B8.1]
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: exp (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: while [B9.1]
   Preds (2): B5 B10
   Succs (2): B8 B4

 [B10]
   1: double result = 1.;
   Preds (2): B11 B12
   Succs (1): B9

 [B11]
   1: exp = -n
   2: sign = true
   Preds (1): B12
   Succs (1): B10

 [B12]
   1: _Bool sign = false;
   2: unsigned int exp = n;
   3: n < 0
   T: if [B12.3]
   Preds (1): B13
   Succs (2): B11 B10

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: double x = 2.;
   2: int n = 3;
   3: argc == 3
   T: if [B3.3]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/validPalindrome/validPalindrome.cpp

function-decl: Solution::isPalindrome isPalindrome
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return true;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::removeNoise removeNoise
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int d;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/longestPalindromicSubstring/longestPalindromicSubstring.cpp

function-decl: findPalindrome findPalindrome
param-decl: int; int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int n;
   2: int l = left;
   3: int r = right;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: longestPalindrome_recursive_way longestPalindrome_recursive_way
param-decl: int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: i++
   Preds (2): B2 B3
   Succs (1): B6

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   Preds (1): B5
   Succs (1): B3

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: i < n - 1
   T: for (...; [B6.1]; ...)
   Preds (2): B1 B7
   Succs (2): B5 B0

 [B7]
   1: int n;
   2: int longest;
   3: int str;
   4: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B6

function-decl: findPalindrome findPalindrome
param-decl: int; int; int; int &; int &; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: len = right - left - 1
   2: start = left + 1
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int n;
   2: int l = left;
   3: int r = right;
   4: right - left - 1 > len
   T: if [B2.4]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: longestPalindrome_recursive_way2 longestPalindrome_recursive_way2
param-decl: int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n - 1
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int n;
   2: int start = 0;
   3: int len = 0;
   4: int longest;
   5: int str;
   6: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: longestPalindrome_dp_way longestPalindrome_dp_way
param-decl: int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: i--
   Preds (1): B6
   Succs (1): B8

 [B2]
   1: j++
   Preds (3): B3 B4 B5
   Succs (1): B6

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B2

 [B6]
   1: j < n
   T: for (...; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: int j = i;
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: i >= 0
   T: for (...; [B8.1]; ...)
   Preds (2): B1 B9
   Succs (2): B7 B0

 [B9]
   1: int longest;
   2: int n;
   3: int i = n - 1;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B8

function-decl: longestPalindrome_dp_opt_way longestPalindrome_dp_opt_way
param-decl: int; 

 [B13 (ENTRY)]
   Succs (1): B12

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 0;
   Preds (1): B11
   Succs (1): B2

 [B4]
   1: i++
   Preds (1): B9
   Succs (1): B11

 [B5]
   1: j++
   Preds (3): B6 B7 B8
   Succs (1): B9

 [B6]
   1: start = j
   2: len = i - j + 1
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: matrix[i][j] = true
   2: len < i - j + 1
   T: if [B7.2]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   T: if <null expr>
   Preds (1): B9
   Succs (2): B7 B5

 [B9]
   1: j <= i
   T: for (...; [B9.1]; ...)
   Preds (2): B5 B10
   Succs (2): B8 B4

 [B10]
   1: matrix[i][i] = true
   2: int j = 0;
   Preds (1): B11
   Succs (1): B9

 [B11]
   1: i < n
   T: for (...; [B11.1]; ...)
   Preds (2): B4 B12
   Succs (2): B10 B3

 [B12]
   1: int n;
   2: _Bool **matrix;
   3: int start = 0;
   4: int len = 0;
   5: int i = 0;
   Preds (1): B13
   Succs (1): B11

 [B0 (EXIT)]
   Preds (1): B2

function-decl: longestPalindrome longestPalindrome
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int s;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/slidingWindowMaximum/SlidingWindowMaximum.cpp

function-decl: maxSlidingWindow02 maxSlidingWindow02
param-decl: int &; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int result;
   2: int w;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: maxSlidingWindow01 maxSlidingWindow01
param-decl: int &; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int result;
   2: int q;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: maxSlidingWindow maxSlidingWindow
param-decl: int &; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printVector printVector
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {1, 3, -1, -3, 5, 3, 6, 7};
   2: int k = 3;
   3: int result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/textJustification/textJustification.cpp

function-decl: fullJustify fullJustify
param-decl: int &; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int len = 0;
   2: int start = 0;
   3: int end = 0;
   4: double space = 0;
   5: _Bool lastLine = false;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printVector printVector
param-decl: int &; _Bool; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: test test
param-decl: const char **; int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: const char *w1[] = {"This", "is", "an", "example", "of", "text", "justification."};
   2: test(w1, sizeof (w1) / sizeof(const char *), 16)
   3: const char *w2[] = {"What", "must", "be", "shall", "be."};
   4: test(w2, sizeof (w2) / sizeof(const char *), 12)
   5: const char *w3[] = {"My", "momma", "always", "said,", "Life", "was", "like", "a", "box", "of", "chocolates.", "You", "never", "know", "what", "you're", "gonna", "get."};
   6: test(w3, sizeof (w3) / sizeof(const char *), 20)
   7: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/3SumClosest/3SumClosest.cpp

function-decl: threeSumClosest threeSumClosest
param-decl: int &; int; 

 [B17 (ENTRY)]
   Succs (1): B16

 [B1]
   1: return result;
   Preds (1): B15
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B11 B13
   Succs (1): B15

 [B3]
   Preds (2): B4 B5
   Succs (1): B11

 [B4]
   1: low++
   Preds (1): B6
   Succs (1): B3

 [B5]
   1: high--
   Preds (1): B6
   Succs (1): B3

 [B6]
   1: sum - target > 0
   T: if [B6.1]
   Preds (2): B7 B8
   Succs (2): B5 B4

 [B7]
   1: result = sum
   Preds (1): B8
   Succs (1): B6

 [B8]
   T: if <null expr>
   Preds (1): B10
   Succs (2): B7 B6

 [B9]
   1: return target;
   Preds (1): B10
   Succs (1): B0

 [B10]
   1: int b;
   2: int c;
   3: int sum = a + b + c;
   4: sum - target == 0
   T: if [B10.4]
   Preds (1): B11
   Succs (2): B9 B8

 [B11]
   1: low < high
   T: while [B11.1]
   Preds (2): B3 B12
   Succs (2): B10 B2

 [B12]
   1: int a;
   2: int low = i + 1;
   3: int high = n - 1;
   Preds (1): B14
   Succs (1): B11

 [B13]
   T: continue;
   Preds (1): B14
   Succs (1): B2

 [B14]
   T: if <null expr>
   Preds (1): B15
   Succs (2): B13 B12

 [B15]
   1: i < n - 2
   T: for (...; [B15.1]; ...)
   Preds (2): B2 B16
   Succs (2): B14 B1

 [B16]
   1: int n;
   2: int distance = 2147483647;
   3: int result;
   4: int i = 0;
   Preds (1): B17
   Succs (1): B15

 [B0 (EXIT)]
   Preds (2): B1 B9

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {-1, 2, 1, -4};
   2: int target = 1;
   3: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/combinations/combinations.cpp

function-decl: combine combine
param-decl: int; int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: combine1 combine1
param-decl: int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int solution;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: getCombination getCombination
param-decl: int; int; int &; int &; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: i--
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i > 0
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = n;
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: int v;
   2: return;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: k == 0
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (2): B2 B4

function-decl: combine2 combine2
param-decl: int; int; 

 [B22 (ENTRY)]
   Succs (1): B21

 [B1]
   Preds (1): B3
   Succs (1): B18

 [B2]
   T: break;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: !found
   T: if [B3.1]
   Preds (2): B7 B13
   Succs (2): B2 B1

 [B4]
   1: i++
   Preds (2): B5 B6
   Succs (1): B13

 [B5]
   1: ones++
   Preds (1): B6
   Succs (1): B4

 [B6]
   T: if <null expr>
   Preds (1): B12
   Succs (2): B5 B4

 [B7]
   T: break;
   Preds (1): B10
   Succs (1): B3

 [B8]
   1: j++
   Preds (1): B9
   Succs (1): B10

 [B9]
   1: ones--
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: j < i
   T: for (...; [B10.1]; ...)
   Preds (2): B8 B11
   Succs (2): B9 B7

 [B11]
   1: found = true
   2: int j = 0;
   Preds (1): B12
   Succs (1): B10

 [B12]
   T: if <null expr>
   Preds (1): B13
   Succs (2): B11 B6

 [B13]
   1: i < n - 1
   T: for (...; [B13.1]; ...)
   Preds (2): B4 B14
   Succs (2): B12 B3

 [B14]
   1: int i;
   2: _Bool found = false;
   3: int ones = 0;
   4: i = 0
   Preds (1): B16
   Succs (1): B13

 [B15]
   1: x++
   Preds (1): B16
   Succs (1): B16

 [B16]
   1: x < n
   T: for (...; [B16.1]; ...)
   Preds (2): B15 B17
   Succs (2): B15 B14

 [B17]
   1: int v;
   2: int x = 0;
   Preds (1): B18
   Succs (1): B16

 [B18]
   1: 1 (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: while [B18.1]
   Preds (2): B1 B20
   Succs (2): B17 NULL

 [B19]
   1: i++
   Preds (1): B20
   Succs (1): B20

 [B20]
   1: i < n
   T: for (...; [B20.1]; ...)
   Preds (2): B19 B21
   Succs (2): B19 B18

 [B21]
   1: int d;
   2: int i = 0;
   Preds (1): B22
   Succs (1): B20

 [B0 (EXIT)]
   Preds (1): B2

function-decl: printResult printResult
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int n = 4;
   2: int k = 2;
   3: argc > 2
   T: if [B2.3]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/reverseString/ReverseString.cpp

function-decl: Solution::reverseString reverseString
param-decl: int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: char ch;
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: i < len / 2
   T: for (...; [B3.1]; ...)
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: int len;
   2: int i = 0;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B3


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/perfectSquares/PerfectSquares.cpp

function-decl: Solution::numSquares numSquares
param-decl: int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: this->numSquares_dp(n)
   2: return [B1.1];
   Succs (1): B0

 [B2]
   1: this->numSquares_dp_opt(n)
   2: return [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::numSquares_dp numSquares_dp
param-decl: int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: delete [] dp
   Succs (1): B0

 [B2]
   1: return dp[n];
   Preds (1): B8
   Succs (1): B0

 [B3]
   1: i++
   Preds (1): B4
   Succs (1): B8

 [B4]
   1: dp[i] = m
   Preds (1): B6
   Succs (1): B3

 [B5]
   1: j++
   Preds (1): B6
   Succs (1): B6

 [B6]
   1: i - j * j >= 0
   T: for (...; [B6.1]; ...)
   Preds (2): B5 B7
   Succs (2): B5 B4

 [B7]
   1: int m = n;
   2: int j = 1;
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: i <= n
   T: for (...; [B8.1]; ...)
   Preds (2): B3 B9
   Succs (2): B7 B2

 [B9]
   1: new int [n + 1]
   2: int *dp = new int [n + 1];
   3: dp[0] = 0
   4: int i = 1;
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: return 0;
   Preds (1): B11
   Succs (1): B0

 [B11]
   1: n <= 0
   T: if [B11.1]
   Preds (1): B12
   Succs (2): B10 B9

 [B0 (EXIT)]
   Preds (3): B1 B2 B10

function-decl: Solution::numSquares_dp_opt numSquares_dp_opt
param-decl: int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: i++
   Preds (1): B3
   Succs (1): B5

 [B2]
   1: j++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i - j * j >= 0
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int m = n;
   2: int j = 1;
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: i <= n
   T: for (...; [B5.1]; ...)
   Preds (2): B1 B6
   Succs (2): B4 B0

 [B6]
   1: static int dp;
   2: int i;
   Preds (1): B8
   Succs (1): B5

 [B7]
   1: return 0;
   Preds (1): B8
   Succs (1): B0

 [B8]
   1: n <= 0
   T: if [B8.1]
   Preds (1): B9
   Succs (2): B7 B6

 [B0 (EXIT)]
   Preds (2): B5 B7


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/longestTurbulentSubarray/LongestTurbulentSubarray.cpp

function-decl: Solution::maxTurbulenceSize_01 maxTurbulenceSize_01
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: enum Status s = none;
   2: int maxlen = 1;
   3: int len = 1;
   4: return maxlen;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::maxTurbulenceSize_02 maxTurbulenceSize_02
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int up = 1;
   2: int down = 1;
   3: int maxlen = 1;
   4: return maxlen;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::maxTurbulenceSize maxTurbulenceSize
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/maximalRectangle/maximalRectangle.cpp

function-decl: largestRectangleArea largestRectangleArea
param-decl: int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int stack;
   2: int maxArea = 0;
   3: return maxArea;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: maximalRectangle maximalRectangle
param-decl: int &; 

 [B14 (ENTRY)]
   Succs (1): B13

 [B1]
   1: return maxArea;
   Preds (1): B10
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B10

 [B3]
   1: maxArea = area
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: int area;
   2: area > maxArea
   T: if [B4.2]
   Preds (1): B8
   Succs (2): B3 B2

 [B5]
   1: j++
   Preds (2): B6 B7
   Succs (1): B8

 [B6]
   Preds (1): B7
   Succs (1): B5

 [B7]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: j < col
   T: for (...; [B8.1]; ...)
   Preds (2): B5 B9
   Succs (2): B7 B4

 [B9]
   1: int j = 0;
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: i < row
   T: for (...; [B10.1]; ...)
   Preds (2): B2 B11
   Succs (2): B9 B1

 [B11]
   1: int row;
   2: int col;
   3: int maxArea = 0;
   4: int i = 0;
   Preds (1): B13
   Succs (1): B10

 [B12]
   1: return 0;
   Preds (1): B13
   Succs (1): B0

 [B13]
   T: if <null expr>
   Preds (1): B14
   Succs (2): B12 B11

 [B0 (EXIT)]
   Preds (2): B1 B12

function-decl: printArray printArray
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: test test
param-decl: int *; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: return 0;
   Preds (1): B7
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B5
   Succs (1): B7

 [B3]
   1: j++
   Preds (1): B4
   Succs (1): B5

 [B4]
   1: char ch;
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: j < c
   T: for (...; [B5.1]; ...)
   Preds (2): B3 B6
   Succs (2): B4 B2

 [B6]
   1: int v;
   2: int j = 0;
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: i < r
   T: for (...; [B7.1]; ...)
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B8]
   1: int i = 0;
   Preds (2): B9 B10
   Succs (1): B7

 [B9]
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: int a0[] = {2, 1, 3, 1};
   2: test(a0, sizeof (a0) / sizeof(int))
   3: int a1[] = {2, 1, 5, 6, 2, 3};
   4: test(a1, sizeof (a1) / sizeof(int))
   5: int r = 3;
   6: int c = 3;
   7: argc > 2
   T: if [B10.7]
   Preds (1): B11
   Succs (2): B9 B8

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/longestCommonPrefix/longestCommonPrefix.cpp

function-decl: longestCommonPrefix longestCommonPrefix
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int word;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: const char *s[] = {"abab", "aba", "abc"};
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/intervalListIntersectons/IntervalListIntersections.cpp

function-decl: Solution::compareInterval compareInterval
param-decl: int &; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::overlapped overlapped
param-decl: int &; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::mergeTwoInterval mergeTwoInterval
param-decl: int &; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::intervalIntersection intervalIntersection
param-decl: int &; int &; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   Preds (2): B2 B7
   Succs (1): B9

 [B2]
   1: i = nexti
   Preds (2): B3 B4
   Succs (1): B1

 [B3]
   1: j++
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   1: nexti = i + 1
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: int nexti = i;
   T: if <null expr>
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B1

 [B8]
   1: j < lenB
   T: while [B9.1] && [B8.1]
   Preds (1): B9
   Succs (2): B7 B0

 [B9]
   1: i < lenA
   T: [B9.1] && ...
   Preds (2): B1 B10
   Succs (2): B8 B0

 [B10]
   1: int lenA;
   2: int lenB;
   3: int i = 0;
   4: int j = 0;
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (2): B8 B9


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/binaryTreeRightSideView/binaryTreeRightSideView.cpp

function-decl: Solution::rightSideViewHelper rightSideViewHelper
param-decl: int *; int; int &; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::rightSideViewHelper rightSideViewHelper
param-decl: int *; int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int level;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::rightSideView rightSideView
param-decl: int *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int result;
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/implementTriePrefixTree/ImplementTriePrefixTree.cpp

function-decl: TrieNode::TrieNode TrieNode
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Trie::Trie Trie
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1:  (CXXConstructExpr, class TrieNode)
   2: new class TrieNode([B1.1])
   3: this->root = [B1.2]
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Trie::insert insert
param-decl: int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: class TrieNode *node = this->root;
   2: node->isWord = true
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Trie::search search
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Trie::startsWith startsWith
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Trie::retrieve retrieve
param-decl: const int &; _Bool; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: [B4.2] ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: node->isWord (ImplicitCastExpr, LValueToRValue, _Bool)
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: true
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: class TrieNode *node = this->root;
   2: isWord (ImplicitCastExpr, LValueToRValue, _Bool)
   T: [B4.2] ? ... : ...
   Preds (1): B6
   Succs (2): B2 B3

 [B5]
   1: return false;
   Preds (1): B6
   Succs (1): B0

 [B6]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B5 B4

 [B0 (EXIT)]
   Preds (2): B1 B5


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/stringWithoutAAAOrBBB/StringWithoutAAAOrBBB.cpp

function-decl: Solution::strWithout3a3b strWithout3a3b
param-decl: int; int; 

 [B15 (ENTRY)]
   Succs (1): B14

 [B1]
   Preds (3): B2 B3 B4
   Succs (1): B13

 [B2]
   1: B -= 2
   2: A--
   T: continue;
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: B > A
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: A -= 2
   2: B--
   T: continue;
   Preds (1): B5
   Succs (1): B1

 [B5]
   1: A > B
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   T: break;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: A + B < 3
   T: if [B7.1]
   Preds (1): B12
   Succs (2): B6 B5

 [B8]
   T: break;
   Preds (1): B10
   Succs (1): B0

 [B9]
   1: i++
   Preds (1): B10
   Succs (1): B10

 [B10]
   1: i < A
   T: for (...; [B10.1]; ...)
   Preds (2): B9 B11
   Succs (2): B9 B8

 [B11]
   1: int i = 0;
   Preds (1): B12
   Succs (1): B10

 [B12]
   1: A == B
   T: if [B12.1]
   Preds (1): B13
   Succs (2): B11 B7

 [B13]
   1: true
   T: while [B13.1]
   Preds (2): B1 B14
   Succs (2): B12 NULL

 [B14]
   1: int result;
   Preds (1): B15
   Succs (1): B13

 [B0 (EXIT)]
   Preds (2): B6 B8


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/binaryTreePaths/binaryTreePaths.cpp

function-decl: Solution::DFS DFS
param-decl: int *; int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::binaryTreePaths binaryTreePaths
param-decl: int *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/surroundedRegions/surroundedRegions.cpp

function-decl: markOpen markOpen
param-decl: int &; int; int; int; int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: solve_recursively solve_recursively
param-decl: int &; 

 [B27 (ENTRY)]
   Succs (1): B26

 [B1]
   1: r++
   Preds (1): B7
   Succs (1): B9

 [B2]
   1: c++
   Preds (3): B3 B4 B5
   Succs (1): B7

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   Preds (1): B6
   Succs (1): B2

 [B6]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: c < col
   T: for (...; [B7.1]; ...)
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B8]
   1: int c = 0;
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: r < row
   T: for (...; [B9.1]; ...)
   Preds (2): B1 B10
   Succs (2): B8 B0

 [B10]
   1: int r = 0;
   Preds (1): B16
   Succs (1): B9

 [B11]
   1: c++
   Preds (2): B12 B13
   Succs (1): B16

 [B12]
   Preds (1): B13
   Succs (1): B11

 [B13]
   T: if <null expr>
   Preds (2): B14 B15
   Succs (2): B12 B11

 [B14]
   Preds (1): B15
   Succs (1): B13

 [B15]
   T: if <null expr>
   Preds (1): B16
   Succs (2): B14 B13

 [B16]
   1: c < col - 1
   T: for (...; [B16.1]; ...)
   Preds (2): B11 B17
   Succs (2): B15 B10

 [B17]
   1: int c = 1;
   Preds (1): B23
   Succs (1): B16

 [B18]
   1: r++
   Preds (2): B19 B20
   Succs (1): B23

 [B19]
   Preds (1): B20
   Succs (1): B18

 [B20]
   T: if <null expr>
   Preds (2): B21 B22
   Succs (2): B19 B18

 [B21]
   Preds (1): B22
   Succs (1): B20

 [B22]
   T: if <null expr>
   Preds (1): B23
   Succs (2): B21 B20

 [B23]
   1: r < row
   T: for (...; [B23.1]; ...)
   Preds (2): B18 B24
   Succs (2): B22 B17

 [B24]
   1: int row;
   2: int col;
   3: int r = 0;
   Preds (1): B26
   Succs (1): B23

 [B25]
   1: return;
   Preds (1): B26
   Succs (1): B0

 [B26]
   T: if <null expr>
   Preds (1): B27
   Succs (2): B25 B24

 [B0 (EXIT)]
   Preds (2): B9 B25

function-decl: position::set set
param-decl: int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->row = r
   2: this->col = c
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: position::position position
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: solve_non_recursively solve_non_recursively
param-decl: int &; 

 [B27 (ENTRY)]
   Succs (1): B26

 [B1]
   1: r++
   Preds (1): B7
   Succs (1): B9

 [B2]
   1: c++
   Preds (3): B3 B4 B5
   Succs (1): B7

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   Preds (1): B6
   Succs (1): B2

 [B6]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: c < col
   T: for (...; [B7.1]; ...)
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B8]
   1: int c = 0;
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: r < row
   T: for (...; [B9.1]; ...)
   Preds (2): B1 B10
   Succs (2): B8 B0

 [B10]
   1: int r = 0;
   Preds (1): B16
   Succs (1): B9

 [B11]
   1: c++
   Preds (2): B12 B13
   Succs (1): B16

 [B12]
   1: p.set(row - 1, c)
   Preds (1): B13
   Succs (1): B11

 [B13]
   T: if <null expr>
   Preds (2): B14 B15
   Succs (2): B12 B11

 [B14]
   1: p.set(0, c)
   Preds (1): B15
   Succs (1): B13

 [B15]
   T: if <null expr>
   Preds (1): B16
   Succs (2): B14 B13

 [B16]
   1: c < col - 1
   T: for (...; [B16.1]; ...)
   Preds (2): B11 B17
   Succs (2): B15 B10

 [B17]
   1: int c = 1;
   Preds (1): B23
   Succs (1): B16

 [B18]
   1: r++
   Preds (2): B19 B20
   Succs (1): B23

 [B19]
   1: p.set(r, col - 1)
   Preds (1): B20
   Succs (1): B18

 [B20]
   T: if <null expr>
   Preds (2): B21 B22
   Succs (2): B19 B18

 [B21]
   1: p.set(r, 0)
   Preds (1): B22
   Succs (1): B20

 [B22]
   T: if <null expr>
   Preds (1): B23
   Succs (2): B21 B20

 [B23]
   1: r < row
   T: for (...; [B23.1]; ...)
   Preds (2): B18 B24
   Succs (2): B22 B17

 [B24]
   1: int row;
   2: int col;
   3: int q;
   4: 0, 0 (CXXConstructExpr, struct position)
   5: struct position p(0, 0);
   6: int r = 0;
   Preds (1): B26
   Succs (1): B23

 [B25]
   1: return;
   Preds (1): B26
   Succs (1): B0

 [B26]
   T: if <null expr>
   Preds (1): B27
   Succs (2): B25 B24

 [B0 (EXIT)]
   Preds (2): B9 B25

function-decl: UnionFind::UnionFind UnionFind
param-decl: int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: this->id_[i] = i
   2: this->rank_[i] = 0
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: i < n
   T: for (...; [B3.1]; ...)
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: this->count_ = n
   2: new int [n]
   3: this->rank_ = [B4.2]
   4: new int [n]
   5: this->id_ = [B4.4]
   6: int i = 0;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B3

function-decl: UnionFind::~UnionFind ~UnionFind
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: delete [] this->rank_
   2: delete [] this->id_
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: UnionFind::count count
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return this->count_;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: UnionFind::find find
param-decl: int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return p;
   Preds (1): B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: this->id_[p] = this->id_[this->id_[p]]
   2: p = this->id_[p]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: p != this->id_[p]
   T: while [B4.1]
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: UnionFind::connected connected
param-decl: int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->find(p)
   2: this->find(q)
   3: return [B1.1] == [B1.2];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: UnionFind::connect connect
param-decl: int; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: this->count_--
   Preds (3): B2 B3 B5
   Succs (1): B0

 [B2]
   1: this->id_[j] = i
   2: this->rank_[i]++
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: this->id_[j] = i
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: this->rank_[i] > this->rank_[j]
   T: if [B4.1]
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   1: this->id_[i] = j
   Preds (1): B6
   Succs (1): B1

 [B6]
   1: this->rank_[i] < this->rank_[j]
   T: if [B6.1]
   Preds (1): B8
   Succs (2): B5 B4

 [B7]
   1: return;
   Preds (1): B8
   Succs (1): B0

 [B8]
   1: this->find(p)
   2: int i = this->find(p);
   3: this->find(q)
   4: int j = this->find(q);
   5: i == j
   T: if [B8.5]
   Preds (1): B9
   Succs (2): B7 B6

 [B0 (EXIT)]
   Preds (2): B1 B7

function-decl: Solution::solve solve
param-decl: int &; 

 [B30 (ENTRY)]
   Succs (1): B29

 [B1]
   1: i++
   Preds (1): B5
   Succs (1): B7

 [B2]
   1: j++
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: j < m
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int j = 0;
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: i < n
   T: for (...; [B7.1]; ...)
   Preds (2): B1 B8
   Succs (2): B6 B0

 [B8]
   1: int i = 0;
   Preds (1): B26
   Succs (1): B7

 [B9]
   1: i++
   Preds (1): B24
   Succs (1): B26

 [B10]
   1: j++
   Preds (3): B11 B12 B19
   Succs (1): B24

 [B11]
   1: uf.connect(i * m + (j - 1), i * m + j)
   Preds (1): B12
   Succs (1): B10

 [B12]
   T: if <null expr>
   Preds (2): B13 B14
   Succs (2): B11 B10

 [B13]
   1: uf.connect(i * m + (j + 1), i * m + j)
   Preds (1): B14
   Succs (1): B12

 [B14]
   T: if <null expr>
   Preds (2): B15 B16
   Succs (2): B13 B12

 [B15]
   1: uf.connect((i - 1) * m + j, i * m + j)
   Preds (1): B16
   Succs (1): B14

 [B16]
   T: if <null expr>
   Preds (2): B17 B18
   Succs (2): B15 B14

 [B17]
   1: uf.connect((i + 1) * m + j, i * m + j)
   Preds (1): B18
   Succs (1): B16

 [B18]
   1: char c;
   T: if <null expr>
   Preds (1): B20
   Succs (2): B17 B16

 [B19]
   1: uf.connect(i * m + j, n * m)
   T: continue;
   Preds (4): B20 B21 B22 B23
   Succs (1): B10

 [B20]
   1: j == m - 1
   T: if [B23.1] || [B22.1] || [B21.1] || [B20.1]
   Preds (1): B21
   Succs (2): B19 B18

 [B21]
   1: j == 0
   T: [B23.1] || [B22.1] || [B21.1] || ...
   Preds (1): B22
   Succs (2): B19 B20

 [B22]
   1: i == n - 1
   T: [B23.1] || [B22.1] || ...
   Preds (1): B23
   Succs (2): B19 B21

 [B23]
   1: i == 0
   T: [B23.1] || ...
   Preds (1): B24
   Succs (2): B19 B22

 [B24]
   1: j < m
   T: for (...; [B24.1]; ...)
   Preds (2): B10 B25
   Succs (2): B23 B9

 [B25]
   1: int j = 0;
   Preds (1): B26
   Succs (1): B24

 [B26]
   1: i < n
   T: for (...; [B26.1]; ...)
   Preds (2): B9 B27
   Succs (2): B25 B8

 [B27]
   1: int m;
   2: n * m + 1 (CXXConstructExpr, class UnionFind)
   3: class UnionFind uf(n * m + 1);
   4: int i = 0;
   Preds (1): B29
   Succs (1): B26

 [B28]
   1: return;
   Preds (1): B29
   Succs (1): B0

 [B29]
   1: int n;
   2: n == 0
   T: if [B29.2]
   Preds (1): B30
   Succs (2): B28 B27

 [B0 (EXIT)]
   Preds (2): B7 B28

function-decl: solve solve
param-decl: int &; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: construct construct
param-decl: int &; int; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: i++
   Preds (1): B3
   Succs (1): B5

 [B2]
   1: j++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: j < col
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int line;
   2: int j = 0;
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: i < row
   T: for (...; [B5.1]; ...)
   Preds (2): B1 B6
   Succs (2): B4 B0

 [B6]
   1: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B5

function-decl: print print
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: argc > 2
   T: if [B3.1]
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: int row;
   2: int col;
   3: row = col = 6
   4: argc > 1
   T: if [B5.4]
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/productOfArrayExceptSelf/ProductOfArrayExceptSelf.cpp

function-decl: Solution::productExceptSelf productExceptSelf
param-decl: int &; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: i--
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i >= 0
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int factorial = 1;
   2: int i = len - 2;
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: i++
   Preds (1): B5
   Succs (1): B5

 [B5]
   1: i < len
   T: for (...; [B5.1]; ...)
   Preds (2): B4 B6
   Succs (2): B4 B3

 [B6]
   1: int len;
   2: int i = 1;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/decodeString/DecodeString.cpp

function-decl: Solution::decodeString decodeString
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int _nstack;
   2: int result;
   3: int tmp;
   4: int n = 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::isValid isValid
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int _stack;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::isNum isNum
param-decl: char; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: [B3.1] && [B2.1]
   2: return ([B1.1]);
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: ch <= '9'
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: ch >= '0'
   T: [B3.1] && ...
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/verifyPreorderSerializationOfABinaryTree/VerifyPreorderSerializationOfABinaryTree.cpp

function-decl: Solution::isValidSerialization isValidSerialization
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int node_expected = 1;
   2: return node_expected == 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::split split
param-decl: const int &; char; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int ss;
   2: int item;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/wordSearch/wordSearch.cpp

function-decl: exist exist
param-decl: int &; int &; int; int; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return true;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return true;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return false;
   Preds (1): B7
   Succs (1): B0

 [B7]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (4): B1 B2 B4 B6

function-decl: exist exist
param-decl: int &; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int row;
   2: int col;
   3: return false;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: buildBoard buildBoard
param-decl: char (*)[5]; int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < r
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: char b1[3][5] = {"CAA", "AAA", "BCD"};
   2: char b2[3][5] = {"ABCE", "SFES", "ADEE"};
   3: char b3[3][5] = {"aaaa", "aaaa", "aaaa"};
   4: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int s;
   2: char b[3][5] = {"ABCE", "SFCS", "ADEE"};
   3: argc > 1
   T: if [B3.3]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/wordSearch/wordSearch.II.cpp

function-decl: TrieNode::TrieNode TrieNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TrieNode::operator[] operator[]
param-decl: char; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return this->children[(ch - 'a') % MAX_CHARS];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TrieNode::operator[] operator[]
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return this->children[idx % MAX_CHARS];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TrieTree::TrieTree TrieTree
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TrieTree::~TrieTree ~TrieTree
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->freeTree(this->root)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TrieTree::getRoot getRoot
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return this->root;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TrieTree::addWord addWord
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: class TrieNode *node = this->root;
   2: int t;
   3: node->isWord = true
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TrieTree::freeTree freeTree
param-decl: class TrieNode *; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: delete node
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   1: (*node)[i] (OperatorCall)
   2: this->freeTree([B3.1])
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < MAX_CHARS
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::findWords findWords
param-decl: int &; class TrieNode *; int; int; int &; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: root->isWord = false
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: root->isWord (ImplicitCastExpr, LValueToRValue, _Bool)
   T: if [B2.1]
   Preds (1): B4
   Succs (2): B1 B0

 [B3]
   1: return;
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: char ch;
   2: (*root)[ch] (OperatorCall)
   3: root = [B4.2]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   1: return;
   Preds (1): B6
   Succs (1): B0

 [B6]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B5 B4

 [B0 (EXIT)]
   Preds (4): B1 B2 B3 B5

function-decl: Solution::findWords findWords
param-decl: int &; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1:  (CXXConstructExpr, class TrieTree)
   2: class TrieTree t;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/insertDeleteGetRandom/InsertDeleteGetrandomO1.cpp

function-decl: RandomizedSet::RandomizedSet RandomizedSet
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: RandomizedSet::insert insert
param-decl: int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return true;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: this->find(val)
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: RandomizedSet::remove remove
param-decl: int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int _idx;
   2: int _val;
   3: return true;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: this->find(val)
   2: ![B3.1]
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: RandomizedSet::getRandom getRandom
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: RandomizedSet::find find
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/insertDeleteGetRandom/InsertDeleteGetrandomO1DuplicatesAllowed.cpp

function-decl: RandomizedCollection::RandomizedCollection RandomizedCollection
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: RandomizedCollection::insert insert
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: RandomizedCollection::remove remove
param-decl: int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return true;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: int _idx;
   2: int _val;
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return false;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: this->find(val)
   2: ![B7.1]
   T: if [B7.2]
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (2): B1 B6

function-decl: RandomizedCollection::getRandom getRandom
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: RandomizedCollection::find find
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/longestSubstringWithAtMostTwoDistinctCharacters/longestSubstringWithAtMostTwoDistinctCharacters.cpp

function-decl: lengthOfLongestSubstringTwoDistinct lengthOfLongestSubstringTwoDistinct
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int maxLen = 0;
   2: int charMap[256] = {0};
   3: int wordCnt = 0;
   4: int start = 0;
   5: return maxLen;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int s;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/totalHammingDistance/totalHammingDistance.cpp

function-decl: Solution::totalHammingDistance totalHammingDistance
param-decl: int &; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return solution;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: ones[i] = 0
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < 31
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: long long solution = 0;
   2: int ones[31];
   3: int i = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/minimumWindowSubstring/minimumWindowSubstring.cpp

function-decl: minWindow minWindow
param-decl: int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: winSize > 0
   T: if [B3.11] && [B2.1]
   Preds (1): B3
   Succs (2): B1 B0

 [B3]
   1: int win;
   2: const int MAX_CHARS = 256;
   3: int window[256];
   4: int dict[256];
   5: const int NOT_EXISTED = -1;
   6: const int NOT_FOUND = 0;
   7: int start = -1;
   8: int winSize = 2147483647;
   9: int letterFound = 0;
  10: int left = 0;
  11: start >= 0
   T: [B3.11] && ...
   Preds (1): B4
   Succs (2): B2 B0

 [B0 (EXIT)]
   Preds (3): B1 B2 B3

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int S;
   2: int T;
   3: argc > 2
   T: if [B3.3]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/sumRootToLeafNumber/sumRootToLeafNumber.cpp

function-decl: Solution::sumNumbers sumNumbers
param-decl: int *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int sum = 0;
   2: return sum;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/lowestCommonAncestorOfABinaryTree/LowestCommonAncestorOfABinaryTree.cpp

function-decl: Solution::findPath findPath
param-decl: int *; int *; int &; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return true;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return true;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return true;
   Preds (1): B7
   Succs (1): B0

 [B7]
   T: if <null expr>
   Preds (1): B9
   Succs (2): B6 B5

 [B8]
   1: return false;
   Preds (1): B9
   Succs (1): B0

 [B9]
   T: if <null expr>
   Preds (1): B10
   Succs (2): B8 B7

 [B0 (EXIT)]
   Preds (5): B1 B2 B4 B6 B8

function-decl: Solution::lowestCommonAncestor01 lowestCommonAncestor01
param-decl: int *; int *; int *; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: i++
   Preds (2): B2 B3
   Succs (1): B4

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: i < len
   T: for (...; [B4.1]; ...)
   Preds (2): B1 B5
   Succs (2): B3 B0

 [B5]
   1: int len;
   2: int *result;
   3: int i = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B4

function-decl: Solution::lowestCommonAncestor02 lowestCommonAncestor02
param-decl: int *; int *; int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int *left;
   2: int *right;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::lowestCommonAncestor lowestCommonAncestor
param-decl: int *; int *; int *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/interleavingString/interleavingString.cpp

function-decl: isInterleave isInterleave
param-decl: int; int; int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return false;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: isInterleave_dfs isInterleave_dfs
param-decl: int; int; int; 

 [B22 (ENTRY)]
   Succs (1): B21

 [B1]
   1: [B4.1] && [B3.1] && [B2.1]
   2: return ([B1.1]);
   Preds (3): B2 B3 B4
   Succs (1): B0

 [B2]
   1: *p3 == '\x00'
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: *p2 == '\x00'
   T: [B4.1] && [B3.1] && ...
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: *p1 == '\x00'
   T: [B4.1] && ...
   Preds (1): B18
   Succs (2): B3 B1

 [B5]
   1: p3++
   Preds (2): B12 B15
   Succs (1): B18

 [B6]
   1: return false;
   Preds (2): B10 B11
   Succs (1): B0

 [B7]
   1: return true;
   Preds (2): B8 B9
   Succs (1): B0

 [B8]
   Preds (1): B9
   Succs (1): B7

 [B9]
   T: if <null expr>
   Preds (1): B10
   Succs (2): B8 B7

 [B10]
   1: *p3 == *p2
   T: if [B11.1] && [B10.1]
   Preds (1): B11
   Succs (2): B9 B6

 [B11]
   1: *p3 == *p1
   T: [B11.1] && ...
   Preds (2): B13 B14
   Succs (2): B10 B6

 [B12]
   1: p2++
   Preds (1): B13
   Succs (1): B5

 [B13]
   1: *p3 != *p1
   T: if [B14.1] && [B13.1]
   Preds (1): B14
   Succs (2): B12 B11

 [B14]
   1: *p3 == *p2
   T: [B14.1] && ...
   Preds (2): B16 B17
   Succs (2): B13 B11

 [B15]
   1: p1++
   Preds (1): B16
   Succs (1): B5

 [B16]
   1: *p3 != *p2
   T: if [B17.1] && [B16.1]
   Preds (1): B17
   Succs (2): B15 B14

 [B17]
   1: *p3 == *p1
   T: [B17.1] && ...
   Preds (1): B18
   Succs (2): B16 B14

 [B18]
   1: *p3 != '\x00'
   T: for (; [B18.1]; ...)
   Preds (2): B5 B19
   Succs (2): B17 B4

 [B19]
   1: const char *p1;
   2: const char *p2;
   3: const char *p3;
   Preds (1): B21
   Succs (1): B18

 [B20]
   1: return false;
   Preds (1): B21
   Succs (1): B0

 [B21]
   T: if <null expr>
   Preds (1): B22
   Succs (2): B20 B19

 [B0 (EXIT)]
   Preds (4): B1 B6 B7 B20

function-decl: main main
param-decl: int; char **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int s1;
   2: int s3;
   3: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/longestAbsoluteFilePath/LongestAbsoluteFilePath.cpp

function-decl: Solution::lengthLongestPath lengthLongestPath
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int ss;
   2: int line;
   3: int result = 0;
   4: int length;
   5: return result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/validSudoku/validSudoku.cpp

function-decl: Solution::isValidSudoku isValidSudoku
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: const int cnt = 9;
   2: _Bool row_mask[9][9] = {false};
   3: _Bool col_mask[9][9] = {false};
   4: _Bool area_mask[9][9] = {false};
   5: return true;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/jumpGame/jumpGame.cpp

function-decl: Solution::canJump canJump
param-decl: int *; int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: return false;
   Preds (2): B7 B8
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B4
   Succs (1): B8

 [B3]
   1: return true;
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: coverPos >= n - 1
   T: if [B4.1]
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   1: coverPos = A[i] + i
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: coverPos < A[i] + i
   T: if [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: i < n
   T: for (...; [B8.1] && [B7.1]; ...)
   Preds (1): B8
   Succs (2): B6 B1

 [B8]
   1: i <= coverPos
   T: [B8.1] && ...
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int coverPos = 0;
   2: int i = 0;
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: return false;
   Preds (1): B11
   Succs (1): B0

 [B11]
   1: n <= 0
   T: if [B11.1]
   Preds (1): B12
   Succs (2): B10 B9

 [B0 (EXIT)]
   Preds (3): B1 B3 B10


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/jumpGame/jumpGame.II.cpp

function-decl: jump jump
param-decl: int *; int; 

 [B20 (ENTRY)]
   Succs (1): B19

 [B1]
   1: return steps;
   Preds (2): B15 B16
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B16

 [B3]
   1: i = nextPos
   Preds (1): B7
   Succs (1): B2

 [B4]
   1: j++
   Preds (2): B5 B6
   Succs (1): B7

 [B5]
   1: maxDistance = A[j] + j
   2: nextPos = j
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: A[j] + j > maxDistance
   T: if [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: j <= coverPos
   T: for (...; [B7.1]; ...)
   Preds (2): B4 B8
   Succs (2): B6 B3

 [B8]
   1: int nextPos = 0;
   2: int maxDistance = 0;
   3: int j = i + 1;
   Preds (1): B10
   Succs (1): B7

 [B9]
   1: return steps;
   Preds (1): B10
   Succs (1): B0

 [B10]
   1: coverPos >= n - 1
   T: if [B10.1]
   Preds (2): B11 B12
   Succs (2): B9 B8

 [B11]
   1: coverPos = A[i] + i
   2: steps++
   Preds (1): B12
   Succs (1): B10

 [B12]
   1: coverPos < A[i] + i
   T: if [B12.1]
   Preds (1): B14
   Succs (2): B11 B10

 [B13]
   1: return -1;
   Preds (1): B14
   Succs (1): B0

 [B14]
   1: A[i] == 0
   T: if [B14.1]
   Preds (1): B15
   Succs (2): B13 B12

 [B15]
   1: i < n
   T: for (...; [B16.1] && [B15.1]; )
   Preds (1): B16
   Succs (2): B14 B1

 [B16]
   1: i <= coverPos
   T: [B16.1] && ...
   Preds (2): B2 B17
   Succs (2): B15 B1

 [B17]
   1: int steps = 0;
   2: int coverPos = 0;
   3: int i = 0;
   Preds (1): B19
   Succs (1): B16

 [B18]
   1: return 0;
   Preds (1): B19
   Succs (1): B0

 [B19]
   1: n <= 1
   T: if [B19.1]
   Preds (1): B20
   Succs (2): B18 B17

 [B0 (EXIT)]
   Preds (4): B1 B9 B13 B18

function-decl: printArray printArray
param-decl: int *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a1[] = {0};
   2: printArray(a1, sizeof (a1) / sizeof (a1[0]))
   3: int a2[] = {1};
   4: printArray(a2, sizeof (a2) / sizeof (a2[0]))
   5: int a3[] = {3, 2, 1, 0, 4};
   6: printArray(a3, sizeof (a3) / sizeof (a3[0]))
   7: int a4[] = {2, 3, 1, 1, 4};
   8: printArray(a4, sizeof (a4) / sizeof (a4[0]))
   9: int a5[] = {1, 2, 3};
  10: printArray(a5, sizeof (a5) / sizeof (a5[0]))
  11: int a6[] = {2, 3, 1, 1, 4, 0, 1};
  12: printArray(a6, sizeof (a6) / sizeof (a6[0]))
  13: int a7[] = {2, 3, 1, 2, 0, 1};
  14: printArray(a7, sizeof (a7) / sizeof (a7[0]))
  15: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/binaryTreeInorderTraversal/binaryTreeInorderTraversal.cpp

function-decl: Solution::inorderTraversal inorderTraversal
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int v;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/ransomNote/RansomNote.cpp

function-decl: Solution::canConstruct canConstruct
param-decl: int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int m;
   2: return true;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/validNumber/validNumber.cpp

function-decl: isdigit isdigit
param-decl: const char; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: [B3.1] && [B2.1]
   2: return ([B1.1]);
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: c <= '9'
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: c >= '0'
   T: [B3.1] && ...
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: isspace isspace
param-decl: const char; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: [B7.1] || [B6.1] || [B5.1] || [B4.1] || [B3.1] || [B2.1]
   2: return ([B1.1]);
   Preds (6): B2 B3 B4 B5 B6 B7
   Succs (1): B0

 [B2]
   1: c == '\v'
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: c == '\f'
   T: [B7.1] || [B6.1] || [B5.1] || [B4.1] || [B3.1] || ...
   Preds (1): B4
   Succs (2): B1 B2

 [B4]
   1: c == '\r'
   T: [B7.1] || [B6.1] || [B5.1] || [B4.1] || ...
   Preds (1): B5
   Succs (2): B1 B3

 [B5]
   1: c == '\n'
   T: [B7.1] || [B6.1] || [B5.1] || ...
   Preds (1): B6
   Succs (2): B1 B4

 [B6]
   1: c == '\t'
   T: [B7.1] || [B6.1] || ...
   Preds (1): B7
   Succs (2): B1 B5

 [B7]
   1: c == ' '
   T: [B7.1] || ...
   Preds (1): B8
   Succs (2): B1 B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: isNumber isNumber
param-decl: const char *; 

 [B40 (ENTRY)]
   Succs (1): B39

 [B1]
   1: return true;
   Preds (1): B29
   Succs (1): B0

 [B2]
   1: s++
   Preds (3): B4 B11 B21
   Succs (1): B29

 [B3]
   1: return false;
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: isdigit(*s)
   2: ![B4.1]
   T: if [B4.2]
   Preds (1): B10
   Succs (2): B3 B2

 [B5]
   1: return true;
   Preds (1): B9
   Succs (1): B0

 [B6]
   1: s++
   Preds (1): B8
   Succs (1): B9

 [B7]
   1: return false;
   Preds (1): B8
   Succs (1): B0

 [B8]
   1: isspace(*s)
   2: ![B8.1]
   T: if [B8.2]
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: *s != '\x00'
   T: for (; [B9.1]; ...)
   Preds (2): B6 B10
   Succs (2): B8 B5

 [B10]
   1: isspace(*s)
   T: if [B10.1]
   Preds (1): B20
   Succs (2): B9 B4

 [B11]
   1: hasE = true
   T: continue;
   Preds (1): B13
   Succs (1): B2

 [B12]
   1: return false;
   Preds (1): B13
   Succs (1): B0

 [B13]
   1: isdigit(*s)
   2: ![B13.1]
   T: if [B13.2]
   Preds (2): B14 B15
   Succs (2): B12 B11

 [B14]
   1: s++
   Preds (2): B15 B16
   Succs (1): B13

 [B15]
   1: *s == '-'
   T: if [B16.2] || [B15.1]
   Preds (1): B16
   Succs (2): B14 B13

 [B16]
   1: s++
   2: *s == '+'
   T: [B16.2] || ...
   Preds (1): B18
   Succs (2): B14 B15

 [B17]
   1: return false;
   Preds (2): B18 B19
   Succs (1): B0

 [B18]
   1: s == head
   T: if [B19.1] || [B18.1]
   Preds (1): B19
   Succs (2): B17 B16

 [B19]
   1: hasE == true
   T: [B19.1] || ...
   Preds (1): B20
   Succs (2): B17 B18

 [B20]
   1: *s == 'e'
   T: if [B20.1]
   Preds (1): B28
   Succs (2): B19 B10

 [B21]
   1: point = true
   T: continue;
   Preds (2): B23 B24
   Succs (1): B2

 [B22]
   1: return false;
   Preds (1): B23
   Succs (1): B0

 [B23]
   1: isdigit(*(s + 1))
   2: ![B23.1]
   T: if [B24.1] && [B23.2]
   Preds (1): B24
   Succs (2): B22 B21

 [B24]
   1: s == head
   T: [B24.1] && ...
   Preds (1): B26
   Succs (2): B23 B21

 [B25]
   1: return false;
   Preds (2): B26 B27
   Succs (1): B0

 [B26]
   1: point == true
   T: if [B27.1] || [B26.1]
   Preds (1): B27
   Succs (2): B25 B24

 [B27]
   1: hasE == true
   T: [B27.1] || ...
   Preds (1): B28
   Succs (2): B25 B26

 [B28]
   1: *s == '.'
   T: if [B28.1]
   Preds (1): B29
   Succs (2): B27 B20

 [B29]
   1: *s != '\x00'
   T: for (; [B29.1]; ...)
   Preds (2): B2 B30
   Succs (2): B28 B1

 [B30]
   1: const char *head = s;
   Preds (2): B31 B32
   Succs (1): B29

 [B31]
   1: s++
   Preds (2): B32 B33
   Succs (1): B30

 [B32]
   1: *s == '-'
   T: if [B33.1] || [B32.1]
   Preds (1): B33
   Succs (2): B31 B30

 [B33]
   1: *s == '+'
   T: [B33.1] || ...
   Preds (1): B35
   Succs (2): B31 B32

 [B34]
   1: return false;
   Preds (1): B35
   Succs (1): B0

 [B35]
   1: *s == '\x00'
   T: if [B35.1]
   Preds (1): B38
   Succs (2): B34 B33

 [B36]
   Preds (1): B37
   Succs (1): B38

 [B37]
   1: s++
   Preds (1): B38
   Succs (1): B36

 [B38]
   1: isspace(*s)
   T: while [B38.1]
   Preds (2): B36 B39
   Succs (2): B37 B35

 [B39]
   1: _Bool point = false;
   2: _Bool hasE = false;
   Preds (1): B40
   Succs (1): B38

 [B0 (EXIT)]
   Preds (9): B1 B3 B5 B7 B12 B17 B22 B25
      B34

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: s = argv[1]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: const char *s = "123";
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/countOfRangeSum/CountOfRangeSum.cpp

function-decl: Node::Node Node
param-decl: long long; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Tree::Tree Tree
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Tree::~Tree ~Tree
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->freeTree(this->root)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Tree::Insert Insert
param-decl: long long; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->Insert(this->root, val)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Tree::LessThan LessThan
param-decl: long long; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->LessThan(this->root, sum, val, 0)
   2: return [B1.1];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Tree::Insert Insert
param-decl: class Node *&; long long; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: this->Insert(root->right, val)
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: val > root->val
   T: if [B2.1]
   Preds (1): B4
   Succs (2): B1 B0

 [B3]
   1: this->Insert(root->left, val)
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: root->cnt++
   2: val < root->val
   T: if [B4.2]
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   1: val (CXXConstructExpr, class Node)
   2: new class Node([B5.1])
   3: root = [B5.2]
   4: return;
   Preds (1): B6
   Succs (1): B0

 [B6]
   1: !root
   T: if [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B0 (EXIT)]
   Preds (4): B1 B2 B3 B5

function-decl: Tree::LessThan LessThan
param-decl: class Node *; long long; int; int; 

 [B14 (ENTRY)]
   Succs (1): B13

 [B1]
   1: [B4.1] ? [B2.1] : [B3.1]
   2: return res + ([B1.1]);
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: root->right->cnt (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: 0
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: root->right (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B4.1] ? ... : ...
   Preds (1): B6
   Succs (2): B2 B3

 [B5]
   1: this->LessThan(root->right, sum, val, res)
   2: return [B5.1];
   Preds (1): B6
   Succs (1): B0

 [B6]
   1: sum - root->val > val
   T: if [B6.1]
   Preds (1): B11
   Succs (2): B5 B4

 [B7]
   1: [B10.1] ? [B8.1] : [B9.1]
   2: res += (root->cnt - ([B7.1]))
   3: this->LessThan(root->left, sum, val, res)
   4: return [B7.3];
   Preds (2): B8 B9
   Succs (1): B0

 [B8]
   1: root->left->cnt (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B10
   Succs (1): B7

 [B9]
   1: 0
   Preds (1): B10
   Succs (1): B7

 [B10]
   1: root->left (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B10.1] ? ... : ...
   Preds (1): B11
   Succs (2): B8 B9

 [B11]
   1: sum - root->val < val
   T: if [B11.1]
   Preds (1): B13
   Succs (2): B10 B6

 [B12]
   1: return res;
   Preds (1): B13
   Succs (1): B0

 [B13]
   1: !root
   T: if [B13.1]
   Preds (1): B14
   Succs (2): B12 B11

 [B0 (EXIT)]
   Preds (4): B1 B5 B7 B12

function-decl: Tree::freeTree freeTree
param-decl: class Node *; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: delete root
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: this->freeTree(root->right)
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: root->right (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B3.1]
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   1: this->freeTree(root->left)
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: root->left (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: !root
   T: if [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (2): B1 B6

function-decl: Solution::countRangeSum countRangeSum
param-decl: int &; int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1:  (CXXConstructExpr, class Tree)
   2: class Tree tree;
   3: tree.Insert(0)
   4: long long sum = 0;
   5: int res = 0;
   6: return res;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/perfectRectangle/PerfectRectangle.cpp

function-decl: Solution::isRectangleCover isRectangleCover
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int corners[4];
   2: int corner = 0;
   3: return true;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/uniqueMorseCodeWords/UniqueMorseCodeWords.cpp

function-decl: Solution::uniqueMorseRepresentations uniqueMorseRepresentations
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int MorseTable[26];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/evaluateReversePolishNotation/evaluateReversePolishNotation.cpp

function-decl: Solution::evalRPN evalRPN
param-decl: int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int i = 0;
   2: _Bool err = false;
   3: int exp;
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::isOp isOp
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::isNum isNum
param-decl: int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return true;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: char *end;
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < 5
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: char exps2[5][3] = {"2", "1", "+", "3", "*"};
   2: int i = 0;
   Preds (1): B6
   Succs (1): B3

 [B5]
   1: i++
   Preds (1): B6
   Succs (1): B6

 [B6]
   1: i < 5
   T: for (...; [B6.1]; ...)
   Preds (2): B5 B7
   Succs (2): B5 B4

 [B7]
   1:  (CXXConstructExpr, class Solution)
   2: class Solution s;
   3: char exps[5][3] = {"42", "9", "6", "-", "+"};
   4: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/gasStation/gasStation.cpp

function-decl: Solution::canCompleteCircuit canCompleteCircuit
param-decl: int &; int &; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: current != start
   T: do ... while [B1.1]
   Preds (2): B2 B3
   Succs (2): B5 B0

 [B2]
   1: start--
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: current++
   Preds (1): B4
   Succs (1): B1

 [B4]
   T: if <null expr>
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   Preds (1): B1
   Succs (1): B4

 [B6]
   1: int current = 0;
   2: int start;
   3: int total = 0;
   Preds (1): B7
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/numberOfIslands/NumberOfIslands.cpp

function-decl: mark mark
param-decl: int &; int; int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: numIslands numIslands
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int result = 0;
   2: return result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: initGrid initGrid
param-decl: int *; int; int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < len
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int g1[];
   2: int g2[];
   3: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/binaryTreeUpsideDown/binaryTreeUpsideDown.cpp

function-decl: Solution::upsideDownBinaryTree upsideDownBinaryTree
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int dummy;
   2: int *head;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/jewelsAndStones/JewelsAndStones.cpp

function-decl: Solution::numJewelsInStones numJewelsInStones
param-decl: int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: _Bool map[256] = {false};
   2: int cnt = 0;
   3: return cnt;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/minimumSizeSubarraySum/MinimumSizeSubarraySum.cpp

function-decl: Solution::minSubArrayLen minSubArrayLen
param-decl: int; int &; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: [B4.6] ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: min (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: 0
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: int min;
   2: int begin = 0;
   3: int end = 0;
   4: int sum = 0;
   5: _Bool has = false;
   6: has (ImplicitCastExpr, LValueToRValue, _Bool)
   T: [B4.6] ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/findMedianFromDataStream/FindMedianFromDataStream.cpp

function-decl: MedianFinder::addNum addNum
param-decl: int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (2): B3 B4
   Succs (2): B1 B0

 [B3]
   1: auto it;
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   Preds (1): B6
   Succs (1): B4

 [B6]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B5 B4

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: MedianFinder::findMedian findMedian
param-decl: 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: double x;
   2: double y;
   3: return (x + y) / 2;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/distinctSubsequences/distinctSubsequences.cpp

function-decl: numDistinct1 numDistinct1
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: numDistinct2 numDistinct2
param-decl: int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i--
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i >= 0
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int len;
   2: int i = len - 1;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: numDistinct numDistinct
param-decl: int; int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int s;
   2: int t;
   3: argc > 2
   T: if [B3.3]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/reorderList/reorderList.cpp

function-decl: ListNode::ListNode ListNode
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: ListNode::ListNode ListNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::reorderList reorderList
param-decl: class ListNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->findMidPos(head)
   2: class ListNode *pMid = this->findMidPos(head);
   3: this->reverseList(pMid)
   4: pMid = [B1.3]
   5: this->Merge(head, pMid)
   6: head = [B1.5]
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::findMidPos findMidPos
param-decl: class ListNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return p1;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: class ListNode *p1;
   2: class ListNode *p2;
   3: class ListNode *p;
   4: p1 = p2 = head
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::reverseList reverseList
param-decl: class ListNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: class ListNode *h;
   2: class ListNode *p;
   3: return h;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::Merge Merge
param-decl: class ListNode *; class ListNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: class ListNode *p1 = h1;
   2: class ListNode *p2 = h2;
   3: class ListNode *p1nxt;
   4: class ListNode *p2nxt;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printList printList
param-decl: class ListNode *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1:  (CXXConstructExpr, class Solution)
   2: class Solution s;
   3: s.reorderList(&n[0])
   4: printList(&n[0])
   5: return 0;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   1: n[i].next = &n[i + 1]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: n[i].val = i
   2: i + 1 < size
   T: if [B4.2]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < size
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int size;
   2:  (CXXConstructExpr, class ListNode [])
   3: new class ListNode [size]
   4: class ListNode *n = new class ListNode [size];
   5: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/bulbSwitcher/bulbSwitcher.cpp

function-decl: Solution::bulbSwitch bulbSwitch
param-decl: int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return cnt;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: cnt++
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i * i <= n
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int cnt = 0;
   2: int i = 1;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/regularExpressionMatching/regularExpressionMatching.cpp

function-decl: isMatch isMatch
param-decl: const char *; const char *; 

 [B20 (ENTRY)]
   Succs (1): B19

 [B1]
   1: return false;
   Preds (2): B6 B9
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B9

 [B3]
   1: i++
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: return true;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: isMatch(s + i + 1, p + 2)
   T: if [B5.1]
   Preds (3): B6 B7 B8
   Succs (2): B4 B3

 [B6]
   1: *p == *(s + i)
   T: while [B9.1] && ([B8.1] || [B7.1] || [B6.1])
   Preds (1): B7
   Succs (2): B5 B1

 [B7]
   1: *p == '.'
   T: [B8.1] || [B7.1] || ...
   Preds (1): B8
   Succs (2): B5 B6

 [B8]
   1: i < 0
   T: [B8.1] || ...
   Preds (1): B9
   Succs (2): B5 B7

 [B9]
   1: i < len
   T: [B9.1] && ...
   Preds (2): B2 B10
   Succs (2): B8 B1

 [B10]
   1: int len;
   2: int i = -1;
   Preds (1): B16
   Succs (1): B9

 [B11]
   1: isMatch(s + 1, p + 1)
   2: return [B11.1];
   Preds (2): B13 B14
   Succs (1): B0

 [B12]
   1: return false;
   Preds (2): B13 B15
   Succs (1): B0

 [B13]
   1: *s != *p
   T: if [B15.1] || ([B14.1] && [B13.1])
   Preds (1): B14
   Succs (2): B12 B11

 [B14]
   1: *p != '.'
   T: [B14.1] && ...
   Preds (1): B15
   Succs (2): B13 B11

 [B15]
   1: *s == '\x00'
   T: [B15.1] || ...
   Preds (2): B16 B17
   Succs (2): B12 B14

 [B16]
   1: *(p + 1) != '*'
   T: if [B17.1] || [B16.1]
   Preds (1): B17
   Succs (2): B15 B10

 [B17]
   1: *(p + 1) == '\x00'
   T: [B17.1] || ...
   Preds (1): B19
   Succs (2): B15 B16

 [B18]
   1: return *s == '\x00';
   Preds (1): B19
   Succs (1): B0

 [B19]
   1: *p == '\x00'
   T: if [B19.1]
   Preds (1): B20
   Succs (2): B18 B17

 [B0 (EXIT)]
   Preds (5): B1 B4 B11 B12 B18

function-decl: main main
param-decl: int; char **; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: s = argv[1]
   2: p = argv[2]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: const char *s = "aaa";
   2: const char *p = "a.*";
   3: argc > 2
   T: if [B2.3]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/missingRanges/missingRanges.cpp

function-decl: makeRange makeRange
param-decl: int; int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: static int result;
   2: int ss;
   3: lo != hi
   T: if [B2.3]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: findMissingRanges findMissingRanges
param-decl: int *; int; int; int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: upper > A[n - 1]
   T: if [B2.1]
   Preds (1): B6
   Succs (2): B1 B0

 [B3]
   1: i++
   Preds (2): B4 B5
   Succs (1): B6

 [B4]
   T: continue;
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: A[i] + 1 == A[i + 1]
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: i < n - 1
   T: for (...; [B6.1]; ...)
   Preds (2): B3 B7
   Succs (2): B5 B2

 [B7]
   1: int i = 0;
   Preds (2): B8 B9
   Succs (1): B6

 [B8]
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: lower < A[0]
   T: if [B9.1]
   Preds (2): B10 B11
   Succs (2): B8 B7

 [B10]
   Preds (1): B11
   Succs (1): B9

 [B11]
   1: n <= 0
   T: if [B11.1]
   Preds (1): B12
   Succs (2): B10 B9

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: printVector printVector
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int i = 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: string2Array string2Array
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int iss;
   2: int result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: int a;
   2: int *pA;
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int A[] = {0, 1, 3, 50, 75};
   2: int lo = 0;
   3: int hi = 99;
   4: argc > 3
   T: if [B3.4]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/combinationSumIV/combinationSumIV.cpp

function-decl: Solution::combinationSum4 combinationSum4
param-decl: int &; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return sol[target];
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: sol[i] = 0
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i <= target
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: target + 1
   2: int sol[target + 1];
   3: sol[0] = 1
   4: int i = 1;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/invertBinaryTree/InvertBinaryTree.cpp

function-decl: Solution::invertTree_recursive invertTree_recursive
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int *node;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::invertTree_non_recursive invertTree_non_recursive
param-decl: int *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::invertTree invertTree
param-decl: int *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/linkedListCycle/linkedListCycle.II.cpp

function-decl: Solution::hasCycle hasCycle
param-decl: int *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::detectCycle detectCycle
param-decl: int *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/linkedListCycle/linkedListCycle.cpp

function-decl: Solution::hasCycle hasCycle
param-decl: int *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::hasCycle01 hasCycle01
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int *p;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::hasCycle02 hasCycle02
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int *p;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::hasCycle03 hasCycle03
param-decl: int *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int *fast;
   2: int *slow;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::hasCycle04 hasCycle04
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int dummy;
   2: int *p;
   3: return false;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/validateBinarySearchTree/validateBinarySearchTree.cpp

function-decl: TreeNode::TreeNode TreeNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: isValidBST isValidBST
param-decl: struct TreeNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int stack;
   2: struct TreeNode *node = root;
   3: int v;
   4: return true;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: createTree createTree
param-decl: int *; int; 

 [B15 (ENTRY)]
   Succs (1): B14

 [B1]
   1: return tree[0];
   Preds (2): B6 B7
   Succs (1): B0

 [B2]
   1: i++
   Preds (3): B3 B4 B5
   Succs (1): B7

 [B3]
   1: tree[i]->right = tree[pos++]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: tree[i]->left = tree[pos++]
   2: pos < n
   T: if [B4.2]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: tree[i] (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B2

 [B6]
   1: pos < n
   T: for (...; [B7.1] && [B6.1]; ...)
   Preds (1): B7
   Succs (2): B5 B1

 [B7]
   1: i < n
   T: [B7.1] && ...
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B8]
   1: int pos = 1;
   2: int i = 0;
   Preds (1): B13
   Succs (1): B7

 [B9]
   1: i++
   Preds (2): B10 B11
   Succs (1): B13

 [B10]
   1: a[i] (CXXConstructExpr, struct TreeNode)
   2: new struct TreeNode([B10.1])
   3: tree[i] = [B10.2]
   Preds (1): B12
   Succs (1): B9

 [B11]
   T: continue;
   Preds (1): B12
   Succs (1): B9

 [B12]
   1: a[i] == 0
   T: if [B12.1]
   Preds (1): B13
   Succs (2): B11 B10

 [B13]
   1: i < n
   T: for (...; [B13.1]; ...)
   Preds (2): B9 B14
   Succs (2): B12 B8

 [B14]
   1: new struct TreeNode *[n]
   2: struct TreeNode **tree = new struct TreeNode *[n];
   3: int i = 0;
   Preds (1): B15
   Succs (1): B13

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {1, 1};
   2: int b[] = {4, 2, 6, 1, 7, 5, 7};
   3: int c[] = {4, 2, 6, 1, 3, 5, 7};
   4: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/zigZagConversion/zigZagConversion.cpp

function-decl: convert convert
param-decl: int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < nRows
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int row = 0;
   2: int step = 1;
   3: int result;
   4: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: main main
param-decl: int; char **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int s;
   2: int r;
   3: r = 3
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/minimumCostForTickets/MinimumCostForTickets.cpp

function-decl: Solution::min min
param-decl: int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: [B4.1] ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: x
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: y
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: x < y
   T: [B4.1] ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::min min
param-decl: int; int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->min(x, y)
   2: this->min([B1.1], z)
   3: return [B1.2];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::mincostTickets mincostTickets
param-decl: int &; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/factorialTrailingZeroes/factorialTrailingZeroes.cpp

function-decl: Solution::trailingZeroes trailingZeroes
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int result = 0;
   2: return result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::trailingZeroes trailingZeroes
param-decl: int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return sum;
   Preds (1): B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: tmp = n / 5
   2: sum += tmp
   3: n = tmp
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: n / 5 > 0
   T: while [B4.1]
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int sum = 0;
   2: int tmp = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/reverseLinkedList/reverseLinkedList.cpp

function-decl: Solution::reverseList_iteratively reverseList_iteratively
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int *h;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::reverseList_recursively reverseList_recursively
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int *h;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::reverseList reverseList
param-decl: int *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/reverseLinkedList/reverseLinkedList.II.cpp

function-decl: ListNode::ListNode ListNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: reverseBetween reverseBetween
param-decl: struct ListNode *; int; int; 

 [B20 (ENTRY)]
   Succs (1): B19

 [B1]
   1: pBegin->next = pHead
   2: return fake.next;
   Preds (1): B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: struct ListNode *node = p->next;
   2: p->next = pHead
   3: pHead = p
   4: p = node
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: p != q
   T: while [B4.1]
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: struct ListNode *p = pBegin->next;
   2: struct ListNode *q = pEnd->next->next;
   3: struct ListNode *pHead = q;
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: return head;
   Preds (1): B7
   Succs (1): B0

 [B7]
   T: if <null expr>
   Preds (3): B10 B11 B12
   Succs (2): B6 B5

 [B8]
   Preds (1): B9
   Succs (1): B12

 [B9]
   1: pBegin = pBegin->next
   2: pEnd = pEnd->next
   3: m--
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: m - 1 > 0
   T: while [B12.1] && [B11.1] && [B10.1]
   Preds (1): B11
   Succs (2): B9 B7

 [B11]
   1: pEnd (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B12.1] && [B11.1] && ...
   Preds (1): B12
   Succs (2): B10 B7

 [B12]
   1: pBegin (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B12.1] && ...
   Preds (3): B8 B15 B16
   Succs (2): B11 B7

 [B13]
   Preds (1): B14
   Succs (1): B16

 [B14]
   1: pEnd = pEnd->next
   2: distance--
   Preds (1): B15
   Succs (1): B13

 [B15]
   1: distance > 0
   T: while [B16.1] && [B15.1]
   Preds (1): B16
   Succs (2): B14 B12

 [B16]
   1: pEnd (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B16.1] && ...
   Preds (2): B13 B17
   Succs (2): B15 B12

 [B17]
   1: 0 (CXXConstructExpr, struct ListNode)
   2: struct ListNode fake(0);
   3: fake.next = head
   4: struct ListNode *pBegin = &fake;
   5: struct ListNode *pEnd = &fake;
   6: int distance = n - m;
   Preds (1): B19
   Succs (1): B16

 [B18]
   1: return head;
   Preds (1): B19
   Succs (1): B0

 [B19]
   T: if <null expr>
   Preds (1): B20
   Succs (2): B18 B17

 [B0 (EXIT)]
   Preds (3): B1 B6 B18

function-decl: printList printList
param-decl: struct ListNode *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: createList createList
param-decl: int *; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return head;
   Preds (1): B6
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B6

 [B3]
   1: a[i] (CXXConstructExpr, struct ListNode)
   2: new struct ListNode([B3.1])
   3: p->next = [B3.2]
   4: p = p->next
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: a[i] (CXXConstructExpr, struct ListNode)
   2: new struct ListNode([B4.1])
   3: head = p = [B4.2]
   Preds (1): B5
   Succs (1): B2

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: i < n
   T: for (...; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: struct ListNode *head;
   2: struct ListNode *p;
   3: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: createList createList
param-decl: int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: createList(a, len)
   2: struct ListNode *h = createList(a, len);
   3: delete [] a
   4: return h;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: a[i] = i + 1
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < len
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: new int [len]
   2: int *a = new int [len];
   3: int i = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: createList(l)
   2: struct ListNode *h = createList(l);
   3: printList(h)
   4: reverseBetween(h, m, n)
   5: printList([B1.4])
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: argc > 3
   T: if [B3.1]
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: argc > 2
   T: if [B5.1]
   Preds (2): B6 B7
   Succs (2): B4 B3

 [B6]
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: int l = 5;
   2: int m = 2;
   3: int n = 4;
   4: argc > 1
   T: if [B7.4]
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/numberOf1Bits/numberOf1Bits.cpp

function-decl: Solution::hammingWeight hammingWeight
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int cnt = 0;
   2: return cnt;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/sumOfLeftLeaves/SumOfLeftLeaves.cpp

function-decl: Solution::sumOfLeftLeaves_recursion_v1 sumOfLeftLeaves_recursion_v1
param-decl: int *; int &; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B1 B0

 [B3]
   1: return;
   Preds (1): B4
   Succs (1): B0

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B0 (EXIT)]
   Preds (3): B1 B2 B3

function-decl: Solution::sumOfLeftLeaves_recursion_v2 sumOfLeftLeaves_recursion_v2
param-decl: int *; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return result;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int result = 0;
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return 0;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (2): B1 B4

function-decl: Solution::sumOfLeftLeaves sumOfLeftLeaves
param-decl: int *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: int result = 0;
   2: return result;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/theSkylineProblem/TheSkylineProblem.cpp

function-decl: Solution::getSkyline getSkyline
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int left;
   2: int right;
   3: int height;
   4: int m;
   5: int pre = 0;
   6: int cur = 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/search2DMatrix/search2DMatrix.II.cpp

function-decl: Solution::binary_search binary_search
param-decl: int &; int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return false;
   Preds (1): B8
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B8

 [B3]
   1: low = mid + 1
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: high = mid - 1
   Preds (1): B5
   Succs (1): B2

 [B5]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return true;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: int mid = low + (high - low) / 2;
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: low <= high
   T: while [B8.1]
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int low = 0;
   2: int high;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (2): B1 B6

function-decl: Solution::searchMatrix01 searchMatrix01
param-decl: int &; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::searchMatrix02 searchMatrix02
param-decl: int &; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int row = 0;
   2: int col;
   3: return false;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::searchMatrix021 searchMatrix021
param-decl: int &; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int row = 0;
   2: int col;
   3: return false;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::searchMatrix022 searchMatrix022
param-decl: int &; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int row = 0;
   2: int col;
   3: return false;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::searchMatrix searchMatrix
param-decl: int &; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/search2DMatrix/search2DMatrix.cpp

function-decl: Solution::searchMatrix searchMatrix
param-decl: int &; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::searchMatrix01 searchMatrix01
param-decl: int &; int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return false;
   Preds (1): B8
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B8

 [B3]
   1: high = mid - 1
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: low = mid + 1
   Preds (1): B5
   Succs (1): B2

 [B5]
   1: n < target
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return true;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: int mid = low + (high - low) / 2;
   2: int r = mid / col;
   3: int c = mid % col;
   4: int n;
   5: n == target
   T: if [B7.5]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: low <= high
   T: while [B8.1]
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int row;
   2: int col;
   3: int len = row * col;
   4: int low = 0;
   5: int high = len - 1;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (2): B1 B6

function-decl: Solution::searchMatrix02 searchMatrix02
param-decl: int &; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: [B4.1] ? [B2.1] : [B3.1]
   2: return ([B1.1]);
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: false
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: true
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: idx < 0
   T: [B4.1] ? ... : ...
   Preds (1): B6
   Succs (2): B2 B3

 [B5]
   1: return false;
   Preds (1): B6
   Succs (1): B0

 [B6]
   1: int idx;
   2: idx < 0
   T: if [B6.2]
   Preds (1): B7
   Succs (2): B5 B4

 [B0 (EXIT)]
   Preds (2): B1 B5

function-decl: Solution::vertical_binary_search vertical_binary_search
param-decl: int; int; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: return low - 1;
   Preds (1): B9
   Succs (1): B0

 [B2]
   Preds (3): B3 B4 B5
   Succs (1): B9

 [B3]
   1: low = mid + 1
   T: continue;
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   1: high = mid - 1
   T: continue;
   Preds (1): B6
   Succs (1): B2

 [B6]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B5 B4

 [B7]
   1: return mid;
   Preds (1): B8
   Succs (1): B0

 [B8]
   1: int mid = low + (high - low) / 2;
   T: if <null expr>
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: low <= high
   T: while [B9.1]
   Preds (2): B2 B10
   Succs (2): B8 B1

 [B10]
   1: int low = 0;
   2: int high;
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (2): B1 B7

function-decl: Solution::binary_search binary_search
param-decl: int; int; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: return -1;
   Preds (1): B9
   Succs (1): B0

 [B2]
   Preds (3): B3 B4 B5
   Succs (1): B9

 [B3]
   1: low = mid + 1
   T: continue;
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   1: high = mid - 1
   T: continue;
   Preds (1): B6
   Succs (1): B2

 [B6]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B5 B4

 [B7]
   1: return mid;
   Preds (1): B8
   Succs (1): B0

 [B8]
   1: int mid = low + (high - low) / 2;
   T: if <null expr>
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: low <= high
   T: while [B9.1]
   Preds (2): B2 B10
   Succs (2): B8 B1

 [B10]
   1: int low = 0;
   2: int high;
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (2): B1 B7


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/brokenCalculator/BrokenCalculator.cpp

function-decl: Solution::brokenCalc brokenCalc
param-decl: int; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: this->brokenCalc(X, Y + 1)
   2: return [B1.1] + 1;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: this->brokenCalc(X, Y / 2)
   2: return [B2.1] + 1;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: Y % 2 == 0
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return X - Y;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: X >= Y
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (3): B1 B2 B4


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/miniParser/MiniParser.cpp

function-decl: Solution::deserialize deserialize
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int pos = 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::helper helper
param-decl: int &; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int ni;
   2: pos++
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::atoni atoni
param-decl: int &; int &; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: sign = -1
   2: pos++
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int sign = 1;
   2: int num = 0;
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::isnum isnum
param-decl: char &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: [B3.1] && [B2.1]
   2: return ([B1.1]);
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: c <= '9'
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: c >= '0'
   T: [B3.1] && ...
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/convertSortedArrayToBinarySearchTree/convertSortedArrayToBinarySearchTree.cpp

function-decl: Solution::sortedArrayToBST sortedArrayToBST
param-decl: int &; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int mid;
   2: int *node;
   3: int first;
   4: int last;
   T: if <null expr>
   Preds (2): B3 B4
   Succs (2): B1 B0

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   Preds (1): B6
   Succs (1): B4

 [B6]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B5 B4

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/satisfiabilityOfEqualityEquations/SatisfiabilityOfEqualityEquations.cpp

function-decl: Solution::init init
param-decl: 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: ch++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: ch <= 'z'
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: char ch = 'a';
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: Solution::Solution Solution
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->init()
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::find find
param-decl: char; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return ch;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::join join
param-decl: char; char; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: this->find(x)
   2: char tx = this->find(x);
   3: this->find(y)
   4: char ty = this->find(y);
   5: tx != ty
   T: if [B2.5]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::equationsPossible equationsPossible
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return true;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/topKFrequentElements/topKFrequentElements.cpp

function-decl: Solution::element::operator< operator<
param-decl: const struct Solution::element; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return this->frequency < arg.frequency;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::topKFrequent topKFrequent
param-decl: int &; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: k--
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: k (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: while [B3.1]
   Preds (3): B1 B4 B5
   Succs (2): B2 B0

 [B4]
   1:  (CXXConstructExpr, struct Solution::element)
   2: struct Solution::element el;
   3: el.frequency = 1
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: int i = 1;
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (1): B3


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/sortList/sortList.cpp

function-decl: ListNode::ListNode ListNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: sortList sortList
param-decl: struct ListNode *; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: p2 = p1->next
   2: sortList(head)
   3: sortList(p2)
   4: mergeTwoLists([B1.2], [B1.3])
   5: return [B1.4];
   Preds (2): B4 B5
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B5

 [B3]
   1: p1 = p1->next
   2: p2 = p2->next->next
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: p2->next (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: while [B5.1] && [B4.1]
   Preds (1): B5
   Succs (2): B3 B1

 [B5]
   1: p2 (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B5.1] && ...
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: struct ListNode *p1 = head;
   2: struct ListNode *p2 = head->next;
   Preds (1): B8
   Succs (1): B5

 [B7]
   1: return head;
   Preds (1): B8
   Succs (1): B0

 [B8]
   T: if <null expr>
   Preds (1): B9
   Succs (2): B7 B6

 [B0 (EXIT)]
   Preds (2): B1 B7

function-decl: mergeTwoLists mergeTwoLists
param-decl: struct ListNode *; struct ListNode *; 

 [B14 (ENTRY)]
   Succs (1): B13

 [B1]
   1: return dummy.next;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: tail->next = p2
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: p2 (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B3.1]
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   1: tail->next = p1
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: p1 (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B5.1]
   Preds (2): B11 B12
   Succs (2): B4 B3

 [B6]
   Preds (1): B7
   Succs (1): B12

 [B7]
   1: tail = tail->next
   Preds (2): B8 B9
   Succs (1): B6

 [B8]
   1: tail->next = p2
   2: p2 = p2->next
   Preds (1): B10
   Succs (1): B7

 [B9]
   1: tail->next = p1
   2: p1 = p1->next
   Preds (1): B10
   Succs (1): B7

 [B10]
   1: p1->val < p2->val
   T: if [B10.1]
   Preds (1): B11
   Succs (2): B9 B8

 [B11]
   1: p2 (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: while [B12.1] && [B11.1]
   Preds (1): B12
   Succs (2): B10 B5

 [B12]
   1: p1 (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B12.1] && ...
   Preds (2): B6 B13
   Succs (2): B11 B5

 [B13]
   1: struct ListNode *p1 = head1;
   2: struct ListNode *p2 = head2;
   3: 0 (CXXConstructExpr, struct ListNode)
   4: static struct ListNode dummy(0);
   5: struct ListNode *tail = &dummy;
   Preds (1): B14
   Succs (1): B12

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printList printList
param-decl: struct ListNode *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: createList createList
param-decl: int *; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return head;
   Preds (1): B6
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B6

 [B3]
   1: a[i] (CXXConstructExpr, struct ListNode)
   2: new struct ListNode([B3.1])
   3: p->next = [B3.2]
   4: p = p->next
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: a[i] (CXXConstructExpr, struct ListNode)
   2: new struct ListNode([B4.1])
   3: head = p = [B4.2]
   Preds (1): B5
   Succs (1): B2

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: i < n
   T: for (...; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: struct ListNode *head;
   2: struct ListNode *p;
   3: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: createList(a, n)
   2: struct ListNode *p = createList(a, n);
   3: printList(p)
   4: sortList(p)
   5: printList([B1.4])
   6: delete [] a
   7: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < n
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: new int [n]
   2: int *a = new int [n];
   3: int i = 0;
   Preds (2): B5 B6
   Succs (1): B3

 [B5]
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: int n = 10;
   2: argc > 1
   T: if [B6.2]
   Preds (1): B7
   Succs (2): B5 B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/squaresOfASortedArray/SquaresOfASortedArray.cpp

function-decl: Solution::sortedSquares sortedSquares
param-decl: int &; 

 [B17 (ENTRY)]
   Succs (1): B16

 [B1]
   Preds (2): B2 B3
   Succs (1): B6

 [B2]
   1: high++
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: low--
   Preds (1): B4
   Succs (1): B1

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: high < len
   T: while [B6.1] && [B5.1]
   Preds (1): B6
   Succs (2): B4 B0

 [B6]
   1: low >= 0
   T: [B6.1] && ...
   Preds (2): B1 B7
   Succs (2): B5 B0

 [B7]
   1: int result;
   2: low = mid
   3: high = mid + 1
   Preds (2): B8 B9
   Succs (1): B6

 [B8]
   1: mid--
   Preds (1): B9
   Succs (1): B7

 [B9]
   T: if <null expr>
   Preds (1): B15
   Succs (2): B8 B7

 [B10]
   Preds (2): B11 B12
   Succs (1): B15

 [B11]
   1: low = mid + 1
   Preds (1): B12
   Succs (1): B10

 [B12]
   T: if <null expr>
   Preds (2): B13 B14
   Succs (2): B11 B10

 [B13]
   1: high = mid - 1
   Preds (1): B14
   Succs (1): B12

 [B14]
   1: mid = low + (high - low) / 2
   T: if <null expr>
   Preds (1): B15
   Succs (2): B13 B12

 [B15]
   1: low <= high
   T: while [B15.1]
   Preds (2): B10 B16
   Succs (2): B14 B9

 [B16]
   1: const int len;
   2: int low = 0;
   3: int high = len - 1;
   4: int mid = 0;
   Preds (1): B17
   Succs (1): B15

 [B0 (EXIT)]
   Preds (2): B5 B6


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/convertANumberToHexadecimal/ConvertANumberToHexadecimal.cpp

function-decl: Solution::toHex toHex
param-decl: int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: x /= 16
   Preds (2): B2 B3
   Succs (1): B5

 [B2]
   1: c = 'a' + n - 10
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: c = n + '0'
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: int n = x % 16;
   2: char c;
   3: n < 10
   T: if [B4.3]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: x > 0
   T: for (; [B5.1]; ...)
   Preds (2): B1 B6
   Succs (2): B4 B0

 [B6]
   1: unsigned int x = num;
   2: int result;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B5


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/arithmeticSlices/ArithmeticSlices.cpp

function-decl: Solution::sum1toN sum1toN
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return n * (n + 1) / 2;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::numberOfArithmeticSlices numberOfArithmeticSlices
param-decl: int &; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: [B4.3] ? [B2.1] : [B3.2]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: result (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: this->sum1toN(len)
   2: result + [B3.1]
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: int result = 0;
   2: int len = 0;
   3: len == 0
   T: [B4.3] ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/moveZeroes/moveZeroes.cpp

function-decl: Solution::moveZeroes moveZeroes
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int i = 0;
   2: int poz = 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::moveZeroes moveZeroes
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int p1 = 0;
   2: int p2 = 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/findPeakElement/findPeakElement.cpp

function-decl: findPeakElement findPeakElement
param-decl: const int &; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return low;
   Preds (1): B8
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B8

 [B3]
   1: low = mid + 1
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: high = mid - 1
   Preds (1): B5
   Succs (1): B2

 [B5]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return mid;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: mid = low + (high - low) / 2
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: low < high
   T: while [B8.1]
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int n;
   2: int low = 0;
   3: int high = n - 1;
   4: int mid = 0;
   5: int v1;
   6: int v2;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (2): B1 B6

function-decl: printVector printVector
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int i;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: test test
param-decl: int *; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int n0[] = {1};
   2: test(n0, sizeof (n0) / sizeof (n0[0]))
   3: int n1[] = {1, 2};
   4: test(n1, sizeof (n1) / sizeof (n1[0]))
   5: int n2[] = {2, 1};
   6: test(n2, sizeof (n2) / sizeof (n2[0]))
   7: int n3[] = {1, 2, 3};
   8: test(n3, sizeof (n3) / sizeof (n3[0]))
   9: int n4[] = {3, 2, 1};
  10: test(n4, sizeof (n4) / sizeof (n4[0]))
  11: int n5[] = {1, 2, 3, 2};
  12: test(n5, sizeof (n5) / sizeof (n5[0]))
  13: int n6[] = {0, 1, 2, 9, 7, 5, 4, 2, 1};
  14: test(n6, sizeof (n6) / sizeof (n6[0]))
  15: int n7[] = {1, 2, 1, 2, 1};
  16: test(n7, sizeof (n7) / sizeof (n7[0]))
  17: int n8[] = {1, 2, 1, 2, 3, 1};
  18: test(n8, sizeof (n8) / sizeof (n8[0]))
  19: int n9[] = {1, 2, 3, 2, 4, 2, 1};
  20: test(n9, sizeof (n9) / sizeof (n9[0]))
  21: int n10[] = {1, 3, 1, 2, 1, 3, 1};
  22: test(n10, sizeof (n10) / sizeof (n10[0]))
  23: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/bullsAndCows/bullsAndCows.cpp

function-decl: Solution::getHint getHint
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::getHint01 getHint01
param-decl: int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: total_bulls += bulls[i]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: i <= 9
   T: for (...; [B3.1]; ...)
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: int appears_in_secret[10] = {0};
   2: int appears_in_guess[10] = {0};
   3: int bulls[10] = {0};
   4: int total_bulls = 0;
   5: int total_cows = 0;
   6: int i = 0;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B3

function-decl: Solution::getHint02 getHint02
param-decl: int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: const int digital_num = 10;
   2: int secret_stat[10] = {0};
   3: int bull = 0;
   4: int cow = 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/countNumbersWithUniqueDigits/CountNumbersWithUniqueDigits.cpp

function-decl: Solution::countNumbersWithUniqueDigits countNumbersWithUniqueDigits
param-decl: int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return result;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: this->nine_factor(i)
   2: result += (9 * [B3.1])
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < n
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int result = 1;
   2: int i = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::nine_factor nine_factor
param-decl: int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return result;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: result *= (9 - i)
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < n
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int result = 1;
   2: int i = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/minStack/minStack.cpp

function-decl: Stack::Stack<T> Stack<T>
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: malloc(this->_capacity * sizeof(T))
   2: this->_stack = (T *)[B1.1]
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Stack::~Stack<T> ~Stack<T>
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: free(this->_stack)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Stack::push push
param-decl: T; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: this->_stack[this->_top] = x
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: this->_capacity *= 5
   2: realloc(this->_stack, this->_capacity * sizeof(T))
   3: this->_stack = (T *)[B2.2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: this->_top++
   2: this->_top >= this->_capacity
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Stack::pop pop
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->top(true)
   2: return [B1.1];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Stack::top top
param-decl: _Bool; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: static T null;
   2: return null;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: return this->_stack[this->_top];
   Preds (1): B4
   Succs (1): B0

 [B3]
   1: return this->_stack[this->_top--];
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: pop (ImplicitCastExpr, LValueToRValue, _Bool)
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: this->_top >= 0
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B1

 [B0 (EXIT)]
   Preds (3): B1 B2 B3

function-decl: Stack::empty empty
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return (this->_top < 0);
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Stack::size size
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return this->_top + 1;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Stack::clear clear
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->_top = -1
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: MinStack::minData::minData minData
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: MinStack::minData::minData minData
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: MinStack::push push
param-decl: int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: this->min = x
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B3]
   1: this->min >= x
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B0

 [B4]
   1: this->min = x
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (4): B1 B2 B3 B4

function-decl: MinStack::pop pop
param-decl: 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B3]
   1: int x;
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B0

 [B4]
   1: return;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (4): B1 B2 B3 B4

function-decl: MinStack::top top
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: MinStack::getMin getMin
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return this->min;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: MinStack::clear clear
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1:  (CXXConstructExpr, class MinStack)
   2: class MinStack ms;
   3: ms.push(2)
   4: ms.push(0)
   5: ms.push(3)
   6: ms.push(0)
   7: ms.pop()
   8: ms.pop()
   9: ms.pop()
  10: ms.clear()
  11: ms.push(2147483646)
  12: ms.push(2147483646)
  13: ms.push(2147483647)
  14: ms.pop()
  15: ms.pop()
  16: ms.pop()
  17: ms.push(2147483647)
  18: ms.push(-2147483648L)
  19: ms.pop()
  20: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/flattenBinaryTreeToLinkedList/flattenBinaryTreeToLinkedList.cpp

function-decl: Solution::flatten flatten
param-decl: int *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/recoverATreeFromPreorderTraversal/recoverATreeFromPreorderTraversal.cpp

function-decl: Solution::recoverFromPreorder recoverFromPreorder
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int values;
   2: int cur_val = 0;
   3: int cur_depth = 0;
   4: _Bool dash = false;
   5: int ptr = 1;
   6: int *root;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/nextPermutation/nextPermutation.cpp

function-decl: nextPermutation nextPermutation
param-decl: int &; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: i--
   Preds (1): B3
   Succs (1): B6

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: i == 1
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: int j;
   2: int tmp;
   3: return;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: i > 0
   T: for (...; [B6.1]; ...)
   Preds (2): B1 B7
   Succs (2): B5 B0

 [B7]
   1: int i;
   Preds (1): B9
   Succs (1): B6

 [B8]
   1: return;
   Preds (1): B9
   Succs (1): B0

 [B9]
   T: if <null expr>
   Preds (1): B10
   Succs (2): B8 B7

 [B0 (EXIT)]
   Preds (4): B2 B4 B6 B8

function-decl: printVector printVector
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: isBeginVector isBeginVector
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return true;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   Preds (1): B4
   Succs (1): B5

 [B3]
   T: break;
   Preds (1): B4
   Succs (1): B1

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: true
   T: while [B5.1]
   Preds (2): B2 B7
   Succs (2): B4 NULL

 [B6]
   1: i++
   Preds (1): B7
   Succs (1): B7

 [B7]
   1: i <= n
   T: for (...; [B7.1]; ...)
   Preds (2): B6 B8
   Succs (2): B6 B5

 [B8]
   1: int num;
   2: int i = 1;
   Preds (2): B9 B10
   Succs (1): B7

 [B9]
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: int n = 4;
   2: argc > 1
   T: if [B10.2]
   Preds (1): B11
   Succs (2): B9 B8

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/rangeSumQuery-Immutable/rangeSumQuery-Mutable/RangeSumQueryMutable.cpp

function-decl: update update
param-decl: int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int oldv;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: sumRange sumRange
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: sumRange sumRange
param-decl: int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return ret;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: idx -= (idx & (-idx))
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: idx > 0
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int ret = 0;
   2: int idx = i;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/rangeSumQuery-Immutable/rangeSumQuery-Immutable.cpp


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/4Sum/4Sum.cpp

function-decl: fourSum fourSum
param-decl: int &; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: threeSum threeSum
param-decl: int; int; 

 [B14 (ENTRY)]
   Succs (1): B13

 [B1]
   1: i++
   Preds (2): B8 B10
   Succs (1): B12

 [B2]
   Preds (3): B3 B4 B6
   Succs (1): B8

 [B3]
   1: low++
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: high--
   Preds (1): B5
   Succs (1): B2

 [B5]
   1: a + b + c > target
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: int v;
   2: low++
   3: high--
   Preds (1): B7
   Succs (1): B2

 [B7]
   1: int b;
   2: int c;
   3: a + b + c == target
   T: if [B7.3]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: low < high
   T: while [B8.1]
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int a;
   2: int low = i + 1;
   3: int high = n - 1;
   Preds (1): B11
   Succs (1): B8

 [B10]
   T: continue;
   Preds (1): B11
   Succs (1): B1

 [B11]
   T: if <null expr>
   Preds (1): B12
   Succs (2): B10 B9

 [B12]
   1: i < n - 2
   T: for (...; [B12.1]; ...)
   Preds (2): B1 B13
   Succs (2): B11 B0

 [B13]
   1: int n;
   2: int i = 0;
   Preds (1): B14
   Succs (1): B12

 [B0 (EXIT)]
   Preds (1): B12

function-decl: printMatrix printMatrix
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {1, 0, -1, 0, -2, 2};
   2: int t = 0;
   3: int b[] = {-1, -5, -5, -3, 2, 5, 0, 4};
   4: t = -7
   5: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/pascalTriangle/pascalTriangle.cpp

function-decl: generate generate
param-decl: int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: i++
   Preds (2): B2 B3
   Succs (1): B4

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int v;
   2: i == 0
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: i < numRows
   T: for (...; [B4.1]; ...)
   Preds (2): B1 B5
   Succs (2): B3 B0

 [B5]
   1: int i = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B4

function-decl: printTriangle printTriangle
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int n = 3;
   2: argc > 1
   T: if [B2.2]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/pascalTriangle/pascalTriangle.II.cpp

function-decl: getRow getRow
param-decl: int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: i++
   Preds (1): B3
   Succs (1): B5

 [B2]
   1: j--
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: j > 0
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int j = i + 1;
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: i < rowIndex
   T: for (...; [B5.1]; ...)
   Preds (2): B1 B6
   Succs (2): B4 B0

 [B6]
   1: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B5

function-decl: printVector printVector
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int n = 3;
   2: argc > 1
   T: if [B2.2]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/eliminationGame/EliminationGame.cpp

function-decl: Solution::lastRemaining lastRemaining
param-decl: int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return start;
   Preds (1): B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: start += step + (n - 2) / 2 * 2 * step
   2: n /= 2
   3: step *= -2
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: n > 1
   T: while [B4.1]
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int start = 1;
   2: int step = 1;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/isSubsequence/IsSubsequence.cpp

function-decl: Solution::isSubsequence isSubsequence
param-decl: int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int ps = 0;
   2: int pt = 0;
   3: return false;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return true;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/powerOfThree/PowerOfThree.cpp

function-decl: Solution::isPowerOfThree isPowerOfThree
param-decl: int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: this->isPowerOfThree_recursive(n)
   2: return [B1.1];
   Succs (1): B0

 [B2]
   1: this->isPowerOfThree_loop(n)
   2: return [B2.1];
   Succs (1): B0

 [B3]
   1: this->isPowerOfThree01(n)
   2: return [B3.1];
   Succs (1): B0

 [B4]
   1: this->isPowerOfThree02(n)
   2: return [B4.1];
   Succs (1): B0

 [B5]
   1: this->isPowerOfThree03(n)
   2: return [B5.1];
   Preds (1): B6
   Succs (1): B0

 [B0 (EXIT)]
   Preds (5): B1 B2 B3 B4 B5

function-decl: Solution::isPowerOfThree03 isPowerOfThree03
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: double logRes;
   2: return (logRes - int(logRes) == 0);
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::isPowerOfThree02 isPowerOfThree02
param-decl: int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: [B4.1] ? ([B2.1]) : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: 1162261467 % n == 0
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: false
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: n > 0
   T: [B4.1] ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::init init
param-decl: int &; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   Preds (1): B3
   Succs (1): B4

 [B2]
   T: break;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: p *= 3
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: 1 (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: while [B4.1]
   Preds (2): B1 B5
   Succs (2): B3 NULL

 [B5]
   1: int p = 1;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B2

function-decl: Solution::isPowerOfThree01 isPowerOfThree01
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: static int power;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::isPowerOfThree_loop isPowerOfThree_loop
param-decl: int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: return false;
   Preds (1): B8
   Succs (1): B0

 [B2]
   1: n /= 3
   Preds (1): B4
   Succs (1): B8

 [B3]
   1: return false;
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: n % 3 != 0
   T: if [B4.1]
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   1: return true;
   Preds (2): B6 B7
   Succs (1): B0

 [B6]
   1: n == 3
   T: if [B7.1] || [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: n == 1
   T: [B7.1] || ...
   Preds (1): B8
   Succs (2): B5 B6

 [B8]
   1: n > 0
   T: for (; [B8.1]; ...)
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B0 (EXIT)]
   Preds (3): B1 B3 B5

function-decl: Solution::isPowerOfThree_recursive isPowerOfThree_recursive
param-decl: int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: this->isPowerOfThree_recursive(n / 3)
   2: return [B1.1];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return false;
   Preds (2): B3 B4
   Succs (1): B0

 [B3]
   1: n % 3 != 0
   T: if [B4.1] || [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: n == 0
   T: [B4.1] || ...
   Preds (1): B6
   Succs (2): B2 B3

 [B5]
   1: return true;
   Preds (2): B6 B7
   Succs (1): B0

 [B6]
   1: n == 3
   T: if [B7.1] || [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: n == 1
   T: [B7.1] || ...
   Preds (1): B8
   Succs (2): B5 B6

 [B0 (EXIT)]
   Preds (3): B1 B2 B5


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/uniqueBinarySearchTrees/uniqueBinarySearchTrees.II.cpp

function-decl: TreeNode::TreeNode TreeNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: generateTrees generateTrees
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int v;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: generateTrees generateTrees
param-decl: int; int; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: int vleft;
   2: int vright;
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: i <= high
   T: for (...; [B3.1]; ...)
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: int i = low;
   Preds (2): B5 B6
   Succs (1): B3

 [B5]
   1: low (CXXConstructExpr, struct TreeNode)
   2: new struct TreeNode([B5.1])
   3: struct TreeNode *node = new struct TreeNode(low);
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: low == high
   T: if [B6.1]
   Preds (2): B7 B8
   Succs (2): B5 B4

 [B7]
   Preds (3): B8 B9 B10
   Succs (1): B6

 [B8]
   1: high <= 0
   T: if [B10.2] || [B9.1] || [B8.1]
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: low <= 0
   T: [B10.2] || [B9.1] || ...
   Preds (1): B10
   Succs (2): B7 B8

 [B10]
   1: int v;
   2: low > high
   T: [B10.2] || ...
   Preds (1): B11
   Succs (2): B7 B9

 [B0 (EXIT)]
   Preds (1): B3

function-decl: printTree printTree
param-decl: struct TreeNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: printTree(root->left)
   2: printTree(root->right)
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int v;
   2: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int n = 2;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/uniqueBinarySearchTrees/uniqueBinarySearchTrees.cpp

function-decl: numTrees numTrees
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: numTrees1(n)
   2: return [B1.1];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: numTrees1 numTrees1
param-decl: int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: int sum = cnt[n];
   2: return sum;
   Preds (1): B7
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B5
   Succs (1): B7

 [B3]
   1: j++
   Preds (1): B4
   Succs (1): B5

 [B4]
   1: cnt[i] += cnt[j] * cnt[i - j - 1]
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: j < i
   T: for (...; [B5.1]; ...)
   Preds (2): B3 B6
   Succs (2): B4 B2

 [B6]
   1: int j = 0;
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: i <= n
   T: for (...; [B7.1]; ...)
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B8]
   1: int *cnt;
   2: cnt[0] = 1
   3: cnt[1] = 1
   4: int i = 2;
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (1): B1

function-decl: numTrees2 numTrees2
param-decl: int; 

 [B13 (ENTRY)]
   Succs (1): B12

 [B1]
   1: return sum;
   Preds (1): B7
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B7

 [B3]
   1: numTrees(i - 1)
   2: numTrees(n - i)
   3: sum += ([B3.1] * [B3.2])
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: numTrees(n - 1)
   2: sum += [B4.1]
   Preds (2): B5 B6
   Succs (1): B2

 [B5]
   1: i == n
   T: if [B6.1] || [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: i == 1
   T: [B6.1] || ...
   Preds (1): B7
   Succs (2): B4 B5

 [B7]
   1: i <= n
   T: for (...; [B7.1]; ...)
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B8]
   1: int sum = 0;
   2: int i = 1;
   Preds (1): B10
   Succs (1): B7

 [B9]
   1: return 1;
   Preds (1): B10
   Succs (1): B0

 [B10]
   1: n == 1
   T: if [B10.1]
   Preds (1): B12
   Succs (2): B9 B8

 [B11]
   1: return 0;
   Preds (1): B12
   Succs (1): B0

 [B12]
   1: n <= 0
   T: if [B12.1]
   Preds (1): B13
   Succs (2): B11 B10

 [B0 (EXIT)]
   Preds (3): B1 B9 B11

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int n = 2;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/deleteNodeInALinkedList/DeleteNodeInALinkedList.cpp

function-decl: Solution::deleteNode deleteNode
param-decl: int *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/triangle/triangle.cpp

function-decl: Solution::minimumTotal minimumTotal
param-decl: int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return min;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: int &vb;
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int min = 32767;
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::min min
param-decl: int; int; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: [B4.3] ? [B2.1] : [B3.1]
   2: return ([B1.1]);
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: n
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: z
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: [B7.1] ? [B5.1] : [B6.1]
   2: int n = x < y ? x : y;
   3: n < z
   T: [B4.3] ? ... : ...
   Preds (2): B5 B6
   Succs (2): B2 B3

 [B5]
   1: x
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: y
   Preds (1): B7
   Succs (1): B4

 [B7]
   1: x < y
   T: [B7.1] ? ... : ...
   Preds (1): B8
   Succs (2): B5 B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int i;
   2:  (CXXConstructExpr, class Solution)
   3: class Solution s;
   4: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/longestConsecutiveSequence/longestConsecutiveSequence.cpp

function-decl: Solution::longestConsecutive longestConsecutive
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int m;
   2: int max_seq = 0;
   3: return max_seq;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/expressionAddOperators/ExpressionAddOperators.cpp

function-decl: Solution::addOperators addOperators
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::helper helper
param-decl: const int &; const int; int &; int; int; long long; long long; char; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: int n;
   2: long long v = 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (3): B1 B2 B4


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/basicCalculator/BasicCalculator.cpp

function-decl: Expression::~Expression ~Expression
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Number::Number Number
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Number::~Number ~Number
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Number::interpret interpret
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return this->number;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Plus::Plus Plus
param-decl: class Expression *; class Expression *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Plus::~Plus ~Plus
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: ->~Expression() (Implicit destructor)
   2: delete this->leftOperand
   3: ->~Expression() (Implicit destructor)
   4: delete this->rightOperand
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Plus::interpret interpret
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->leftOperand->interpret()
   2: this->rightOperand->interpret()
   3: return [B1.1] + [B1.2];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Minus::Minus Minus
param-decl: class Expression *; class Expression *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Minus::~Minus ~Minus
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: ->~Expression() (Implicit destructor)
   2: delete this->leftOperand
   3: ->~Expression() (Implicit destructor)
   4: delete this->rightOperand
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Minus::interpret interpret
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->leftOperand->interpret()
   2: this->rightOperand->interpret()
   3: return [B1.1] - [B1.2];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Multiply::Multiply Multiply
param-decl: class Expression *; class Expression *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Multiply::~Multiply ~Multiply
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: ->~Expression() (Implicit destructor)
   2: delete this->leftOperand
   3: ->~Expression() (Implicit destructor)
   4: delete this->rightOperand
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Multiply::interpret interpret
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->leftOperand->interpret()
   2: this->rightOperand->interpret()
   3: return [B1.1] * [B1.2];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Divide::Divide Divide
param-decl: class Expression *; class Expression *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Divide::~Divide ~Divide
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: ->~Expression() (Implicit destructor)
   2: delete this->leftOperand
   3: ->~Expression() (Implicit destructor)
   4: delete this->rightOperand
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Divide::interpret interpret
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->leftOperand->interpret()
   2: this->rightOperand->interpret()
   3: return [B1.1] / [B1.2];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: isOperator isOperator
param-decl: const int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: isOperator isOperator
param-decl: const char &; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: [B5.1] || [B4.1] || [B3.1] || [B2.1]
   2: return ([B1.1]);
   Preds (4): B2 B3 B4 B5
   Succs (1): B0

 [B2]
   1: c == '/'
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: c == '*'
   T: [B5.1] || [B4.1] || [B3.1] || ...
   Preds (1): B4
   Succs (2): B1 B2

 [B4]
   1: c == '-'
   T: [B5.1] || [B4.1] || ...
   Preds (1): B5
   Succs (2): B1 B3

 [B5]
   1: c == '+'
   T: [B5.1] || ...
   Preds (1): B6
   Succs (2): B1 B4

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Evaluator::Evaluator Evaluator
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int stack;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Evaluator::~Evaluator ~Evaluator
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: ->~Expression() (Implicit destructor)
   2: delete this->syntaxTree
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Evaluator::interpret interpret
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->syntaxTree->interpret()
   2: return [B1.1];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Parse Parse
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Priority Priority
param-decl: const int &; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 1;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return 2;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (3): B1 B2 B4

function-decl: Infix2RPN Infix2RPN
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: calculate_RPN_design_pattern calculate_RPN_design_pattern
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: calculate_RPN_evluation calculate_RPN_evluation
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int ss;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: calculate_two_stacks calculate_two_stacks
param-decl: int &; int &; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: rhs = -rhs
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int lhs;
   2: int rhs;
   3: char op;
   4: op == '-'
   T: if [B2.4]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: calculate_two_stacks calculate_two_stacks
param-decl: int &; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: i--
   Preds (4): B2 B3 B4 B6
   Succs (1): B8

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: int num;
   Preds (1): B5
   Succs (1): B1

 [B5]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   Preds (1): B7
   Succs (1): B1

 [B7]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: i >= 0
   T: for (...; [B8.1]; ...)
   Preds (2): B1 B9
   Succs (2): B7 B0

 [B9]
   1: int num_stack;
   2: int op_stack;
   3: int i;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B8

function-decl: calculate calculate
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int s;
   2: argc > 1
   T: if [B2.2]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/basicCalculator/BasicCalculator.II.cpp

function-decl: isOperator isOperator
param-decl: const char; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: [B5.1] || [B4.1] || [B3.1] || [B2.1]
   2: return ([B1.1]);
   Preds (4): B2 B3 B4 B5
   Succs (1): B0

 [B2]
   1: ch == '/'
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: ch == '*'
   T: [B5.1] || [B4.1] || [B3.1] || ...
   Preds (1): B4
   Succs (2): B1 B2

 [B4]
   1: ch == '-'
   T: [B5.1] || [B4.1] || ...
   Preds (1): B5
   Succs (2): B1 B3

 [B5]
   1: ch == '+'
   T: [B5.1] || ...
   Preds (1): B6
   Succs (2): B1 B4

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Priority Priority
param-decl: const char; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 1;
   Preds (2): B3 B4
   Succs (1): B0

 [B3]
   1: c == '-'
   T: if [B4.1] || [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: c == '+'
   T: [B4.1] || ...
   Preds (1): B6
   Succs (2): B2 B3

 [B5]
   1: return 2;
   Preds (2): B6 B7
   Succs (1): B0

 [B6]
   1: c == '/'
   T: if [B7.1] || [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: c == '*'
   T: [B7.1] || ...
   Preds (1): B8
   Succs (2): B5 B6

 [B0 (EXIT)]
   Preds (3): B1 B2 B5

function-decl: calculate_exp calculate_exp
param-decl: long long; long long; char; 

 [B7 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return -1;
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: op (ImplicitCastExpr, IntegralCast, int)
   T: switch [B2.1]
   Preds (1): B7
   Succs (5): B3 B4 B5 B6 B1

 [B3]
  case '/':
   1: return x / y;
   Preds (1): B2
   Succs (1): B0

 [B4]
  case '*':
   1: return x * y;
   Preds (1): B2
   Succs (1): B0

 [B5]
  case '-':
   1: return x - y;
   Preds (1): B2
   Succs (1): B0

 [B6]
  case '+':
   1: return x + y;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (5): B1 B3 B4 B5 B6

function-decl: calculate_two_stacks calculate_two_stacks
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int num_stack;
   2: int op_stack;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: calculate calculate
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int exp;
   2: argc > 1
   T: if [B2.2]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/bitwiseANDOfNumbersRange/BitwiseAndOfNumbersRange.cpp

function-decl: rangeBitwiseAnd rangeBitwiseAnd
param-decl: int; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return m & mask;
   Preds (2): B4 B6
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B6

 [B3]
   1: mask <<= 1
   Preds (1): B5
   Succs (1): B2

 [B4]
   T: break;
   Preds (1): B5
   Succs (1): B1

 [B5]
   1: (m & mask) == (n & mask)
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: mask != 0
   T: while [B6.1]
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: int mask = 4294967295U;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int m = 5;
   2: int n = 7;
   3: argc > 2
   T: if [B3.3]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/UTF8Validation/UTF8Validation.cpp

function-decl: Solution::validUtf8 validUtf8
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int i = 0;
   2: return true;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/countAndSay/countAndSay.cpp

function-decl: vecToStr vecToStr
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int ss;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: getNext getNext
param-decl: int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: val > 0
   T: if [B3.4] && [B2.1]
   Preds (1): B3
   Succs (2): B1 B0

 [B3]
   1: int cnt = 0;
   2: int val = 0;
   3: int ret;
   4: cnt > 0
   T: [B3.4] && ...
   Preds (1): B4
   Succs (2): B2 B0

 [B0 (EXIT)]
   Preds (3): B1 B2 B3

function-decl: countAndSay countAndSay
param-decl: int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i <= n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int s;
   2: int v;
   3: int i = 2;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int n = 4;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/sortColors/sortColors.cpp

function-decl: swap swap
param-decl: int *; int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int t;
   2: t = *a
   3: *a = *b
   4: *b = t
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: sortColors sortColors
param-decl: int *; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: i++
   Preds (2): B2 B3
   Succs (1): B6

 [B2]
   1: swap(&a[two], &a[i])
   2: two--
   3: i--
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: a[i] == 2
   T: if [B3.1]
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   1: swap(&a[zero], &a[i])
   2: zero++
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: a[i] == 0
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: i <= two
   T: for (...; [B6.1]; ...)
   Preds (2): B1 B7
   Succs (2): B5 B0

 [B7]
   1: int zero = 0;
   2: int two = n - 1;
   3: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B6

function-decl: printArray printArray
param-decl: int *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: main main
param-decl: int; char **; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: printArray(a, n)
   2: sortColors(a, n)
   3: printArray(a, n)
   4: delete [] a
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < n
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int n = 7;
   2: new int [n]
   3: int *a = new int [n];
   4: int i = 0;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/reverseBits/reverseBits.cpp

function-decl: Solution::reverseBits reverseBits
param-decl: int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < 32
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int ret;
   2: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/flattenNestedListIterator/FlattenNestedListIterator.cpp

function-decl: NestedIterator::flatten flatten
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: NestedIterator::NestedIterator NestedIterator
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->index = 0
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: NestedIterator::next next
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: NestedIterator::hasNext hasNext
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/houseRobber/houseRobber.cpp

function-decl: rob1 rob1
param-decl: int &; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 2;
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: return 0;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: int n;
   2: n == 0
   T: if [B5.2]
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (2): B2 B4

function-decl: rob2 rob2
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int n2 = 0;
   2: int n1 = 0;
   3: return n1;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: rob rob
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printVector printVector
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < argc
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 1;
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: int money;
   2: argc > 1
   T: if [B4.2]
   Preds (1): B5
   Succs (2): B3 B0

 [B0 (EXIT)]
   Preds (2): B2 B4


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/houseRobber/houseRobberIII.cpp

function-decl: Solution::rob rob
param-decl: int *; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: int lwith;
   2: int rwith;
   3: int lwithout = 0;
   4: int rwithout = 0;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B1 B0

 [B3]
   1: return 0;
   Preds (1): B4
   Succs (1): B0

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B0 (EXIT)]
   Preds (3): B1 B2 B3


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/houseRobber/houseRobber.II.cpp

function-decl: Solution::orginal_rob orginal_rob
param-decl: int &; int; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return n1;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: int current;
   2: n2 = n1
   3: n1 = current
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < end
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int n2 = 0;
   2: int n1 = 0;
   3: int i = start;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::rob rob
param-decl: int &; 

 [B6 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int n;
   2: n (ImplicitCastExpr, LValueToRValue, int)
   T: switch [B1.2]
   Preds (1): B6
   Succs (4): B3 B4 B5 B2

 [B2]
  default:
   1: int m1;
   2: int m2;
   Preds (2): B3 B1
   Succs (1): B0

 [B3]
  case 2:
   Preds (2): B1 B4
   Succs (1): B2

 [B4]
  case 1:
   Preds (1): B1
   Succs (1): B3

 [B5]
  case 0:
   1: return 0;
   Preds (1): B1
   Succs (1): B0

 [B0 (EXIT)]
   Preds (2): B2 B5


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/reverseInteger/reverseInteger.cpp

function-decl: reverse reverse
param-decl: int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: return y;
   Preds (1): B7
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B7

 [B3]
   1: y = y * 10 + n
   2: x /= 10
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: return 0;
   Preds (2): B5 B6
   Succs (1): B0

 [B5]
   1: y < (-2147483647 - 1) / 10
   T: if [B6.2] || [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: n = x % 10
   2: y > 2147483647 / 10
   T: [B6.2] || ...
   Preds (1): B7
   Succs (2): B4 B5

 [B7]
   1: x != 0
   T: while [B7.1]
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B8]
   1: int y = 0;
   2: int n;
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (2): B1 B4

function-decl: main main
param-decl: int; char **; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: int n;
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < argc
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int i = 1;
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: return 0;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: argc < 2
   T: if [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (2): B1 B6


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/binaryTreeMaximumPathSum/binaryTreeMaximumPathSum.cpp

function-decl: TreeNode::TreeNode TreeNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: maxPathSum maxPathSum
param-decl: struct TreeNode *; int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: maxPathSum(root->left, maxSum)
   2: int left = maxPathSum(root->left, maxSum);
   3: maxPathSum(root->right, maxSum)
   4: int right = maxPathSum(root->right, maxSum);
   5: int val = root->val;
   6: int maxBranch;
   7: int m;
   8: return maxBranch;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: maxPathSum maxPathSum
param-decl: struct TreeNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int maxSum = (-2147483647 - 1);
   2: maxPathSum(root, maxSum)
   3: return maxSum;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: 1 (CXXConstructExpr, struct TreeNode)
   2: struct TreeNode root(1);
   3: 2 (CXXConstructExpr, struct TreeNode)
   4: struct TreeNode left(2);
   5: 3 (CXXConstructExpr, struct TreeNode)
   6: struct TreeNode right(3);
   7: root.left = &left
   8: root.right = &right
   9: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/editDistance/editDistance.cpp

function-decl: min min
param-decl: int; int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: minDistance minDistance
param-decl: int; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: int row;
   2: int col;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return n1;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: n2 == 0
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return n2;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: int n1;
   2: int n2;
   3: n1 == 0
   T: if [B5.3]
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (3): B1 B2 B4

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int steps;
   2: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int word1;
   2: argc > 2
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/minimumASCIIDeleteSumForTwoStrings/MinimumAsciiDeleteSumForTwoStrings.cpp

function-decl: Solution::minimumDeleteSum minimumDeleteSum
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/sameTree/sameTree.cpp

function-decl: Solution::Solution Solution
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::isSameTree isSameTree
param-decl: int *; int *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::isSameTree1 isSameTree1
param-decl: int *; int *; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return false;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B1 B0

 [B3]
   1: return true;
   Preds (1): B4
   Succs (1): B0

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B0 (EXIT)]
   Preds (3): B1 B2 B3

function-decl: Solution::isSameTree2 isSameTree2
param-decl: int *; int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return true;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/nimGame/nimGame.cpp

function-decl: Solution::canWinNim canWinNim
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return !(n % 4 == 0);
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/maximumDepthOfBinaryTree/maximumDepthOfBinaryTree.cpp

function-decl: Solution::maxDepth maxDepth
param-decl: int *; 

 [B13 (ENTRY)]
   Succs (1): B12

 [B1]
   1: [B4.1] ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: left
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: right
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: left > right
   T: [B4.1] ? ... : ...
   Preds (2): B5 B6
   Succs (2): B2 B3

 [B5]
   Preds (1): B6
   Succs (1): B4

 [B6]
   T: if <null expr>
   Preds (2): B7 B8
   Succs (2): B5 B4

 [B7]
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: int left = 1;
   2: int right = 1;
   T: if <null expr>
   Preds (1): B10
   Succs (2): B7 B6

 [B9]
   1: return 1;
   Preds (1): B10
   Succs (1): B0

 [B10]
   T: if <null expr>
   Preds (1): B12
   Succs (2): B9 B8

 [B11]
   1: return 0;
   Preds (1): B12
   Succs (1): B0

 [B12]
   T: if <null expr>
   Preds (1): B13
   Succs (2): B11 B10

 [B0 (EXIT)]
   Preds (3): B1 B9 B11

function-decl: Solution2::maxDepth maxDepth
param-decl: int *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return 0;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/countCompleteTreeNodes/CountCompleteTreeNodes.cpp

function-decl: Solution::isCompleteTree isCompleteTree
param-decl: int *; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return cnt - 1;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return -1;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: int cnt = 1;
   2: int *left;
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return 0;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (3): B1 B2 B4

function-decl: Solution::countNodes countNodes
param-decl: int *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int leftCnt;
   2: int rightCnt;
   3: return leftCnt + rightCnt + 1;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return cnt;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: int cnt;
   2: cnt != -1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/backspaceStringCompare/BackspaceStringCompare.cpp

function-decl: Solution::removeBackspaces removeBackspaces
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int i = 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::backspaceCompare backspaceCompare
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/twoCityScheduling/TwoCityScheduling.cpp

function-decl: Solution::diff diff
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::cmpfunc cmpfunc
param-decl: int &; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::twoCitySchedCost twoCitySchedCost
param-decl: int &; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return result;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < len / 2
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int result = 0;
   2: int len;
   3: int i = 0;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/maximumAverageSubarray/MaximumAverageSubarray.I.cpp

function-decl: Solution::findMaxAverage findMaxAverage
param-decl: int &; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: int s = sum;
   2: return (double)sum / k;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < k
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int sum = 0;
   2: int i = 0;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/swapNodesInPairs/swapNodesInPairs.cpp

function-decl: Solution::Solution Solution
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::swapPairs swapPairs
param-decl: int *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::swapPairs1 swapPairs1
param-decl: int *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::swapPairs2 swapPairs2
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int *h;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::swapPairs3 swapPairs3
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int *Curr;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/combinationSum/combinationSum.II.cpp

function-decl: combinationSumHelper combinationSumHelper
param-decl: int &; int; int; int &; int &; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return;
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: target == 0
   T: if [B2.1]
   Preds (1): B4
   Succs (2): B1 B0

 [B3]
   1: return;
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: target < 0
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B0 (EXIT)]
   Preds (3): B1 B2 B3

function-decl: combinationSum2 combinationSum2
param-decl: int &; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int solution;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printMatrix printMatrix
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printArray printArray
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: test test
param-decl: int *; int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {4, 2, 3, 3, 5, 7};
   2: int target = 7;
   3: test(a, sizeof (a) / sizeof(int), target)
   4: int b[] = {10, 1, 2, 7, 6, 1, 5};
   5: target = 8
   6: test(b, sizeof (b) / sizeof(int), target)
   7: int c[] = {2, 2, 2};
   8: target = 2
   9: test(c, sizeof (c) / sizeof(int), target)
  10: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/combinationSum/combinationSum.III.cpp

function-decl: combinationSumHelper combinationSumHelper
param-decl: int &; int; int; int; int &; int &; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B1 B0

 [B3]
   1: return;
   Preds (1): B4
   Succs (1): B0

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B0 (EXIT)]
   Preds (3): B1 B2 B3

function-decl: combinationSum3 combinationSum3
param-decl: int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: int solution;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i <= 9
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int v;
   2: int i = 1;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: PrintResults PrintResults
param-decl: int; int; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int k = 3;
   2: int n = 9;
   3: argc > 2
   T: if [B3.3]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/combinationSum/combinationSum.cpp

function-decl: combinationSumHelper combinationSumHelper
param-decl: int &; int; int; int &; int &; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return;
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: target == 0
   T: if [B2.1]
   Preds (1): B4
   Succs (2): B1 B0

 [B3]
   1: return;
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: target < 0
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B0 (EXIT)]
   Preds (3): B1 B2 B3

function-decl: combinationSum combinationSum
param-decl: int &; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int solution;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printMatrix printMatrix
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printArray printArray
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {4, 2, 3, 3, 5, 7};
   2: int target = 7;
   3: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/maximumGap/maximumGap.cpp

function-decl: maximumGap maximumGap
param-decl: int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int min;
   2: int max;
   3: int bucket_size;
   4: int maxGap = 0;
   5: int prev = 0;
   6: return maxGap;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {1, 1, 1, 1, 1, 5, 5, 5, 5, 5};
   2: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/islandPerimeter/IslandPerimeter.cpp

function-decl: Solution::edge edge
param-decl: int &; int; int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return edge;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: edge++
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   1: edge++
   Preds (1): B5
   Succs (1): B3

 [B5]
   T: if <null expr>
   Preds (2): B6 B7
   Succs (2): B4 B3

 [B6]
   1: edge++
   Preds (1): B7
   Succs (1): B5

 [B7]
   T: if <null expr>
   Preds (2): B8 B9
   Succs (2): B6 B5

 [B8]
   1: edge++
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: int edge = 0;
   T: if <null expr>
   Preds (1): B10
   Succs (2): B8 B7

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::islandPerimeter islandPerimeter
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int perimeter = 0;
   2: return perimeter;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/lowestCommonAncestorOfABinarySearchTree/LowestCommonAncestorOfABinarySearchTree.cpp

function-decl: Solution::lowestCommonAncestor lowestCommonAncestor
param-decl: int *; int *; int *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/singleNumber/singleNumber.II.cpp

function-decl: Solution::Solution Solution
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::singleNumber singleNumber
param-decl: int *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: this->singleNumber_2(A, n)
   2: return [B1.1];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: this->singleNumber_1(A, n)
   2: return [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::singleNumber_1 singleNumber_1
param-decl: int *; int; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: return result;
   Preds (1): B9
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B9

 [B3]
   1: result |= ((count[i] % 3) << i)
   Preds (1): B7
   Succs (1): B2

 [B4]
   1: j++
   Preds (2): B5 B6
   Succs (1): B7

 [B5]
   1: count[i]++
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: (A[j] >> i) & 1 (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: if [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: j < n
   T: for (...; [B7.1]; ...)
   Preds (2): B4 B8
   Succs (2): B6 B3

 [B8]
   1: int j = 0;
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: i < 32
   T: for (...; [B9.1]; ...)
   Preds (2): B2 B10
   Succs (2): B8 B1

 [B10]
   1: int count[32] = {0};
   2: int result = 0;
   3: int i = 0;
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::singleNumber_2 singleNumber_2
param-decl: int *; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return ones;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: twos |= ones & A[i]
   2: ones ^= A[i]
   3: threes = ones & twos
   4: ones &= ~threes
   5: twos &= ~threes
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < n
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int ones = 0;
   2: int twos = 0;
   3: int threes = 0;
   4: int i = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/singleNumber/singleNumber.III.cpp

function-decl: Solution::singleNumber singleNumber
param-decl: int &; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: int zero = 0;
   2: int one = 0;
   3: int result;
   Preds (1): B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: mask <<= 1
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: (mask & allxor) == 0
   T: while [B4.1]
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int allxor = 0;
   2: int mask = 1;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/singleNumber/singleNumber.cpp

function-decl: singleNumber singleNumber
param-decl: int *; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return s;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: s = s ^ A[i]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < n
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int s = 0;
   2: int i = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {1, 1, 2, 2, 3};
   2: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/wiggleSort/WiggleSort.II.cpp

function-decl: Solution::wiggleSort01 wiggleSort01
param-decl: int &; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: int v;
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: i < half
   T: for (...; [B3.1]; ...)
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: int half;
   2: int i = 0;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B3

function-decl: Solution::wiggleSort02 wiggleSort02
param-decl: int &; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   Preds (3): B2 B3 B5
   Succs (1): B7

 [B2]
   1: j++
   Preds (1): B4
   Succs (1): B1

 [B3]
   Preds (1): B4
   Succs (1): B1

 [B4]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   Preds (1): B6
   Succs (1): B1

 [B6]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: j <= k
   T: while [B7.1]
   Preds (2): B1 B8
   Succs (2): B6 B0

 [B8]
   1: int n;
   2: auto midptr;
   3: int mid;
   4: int i = 0;
   5: int j = 0;
   6: int k = n - 1;
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (1): B7

function-decl: Solution::wiggleSort wiggleSort
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/peakIndexInAMountainArray/PeakIndexInAMountainArray.cpp

function-decl: Solution::peakIndexInMountainArray peakIndexInMountainArray
param-decl: int &; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: return -1;
   Preds (1): B9
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B9

 [B3]
   1: right = mid - 1
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   1: left = mid + 1
   Preds (1): B6
   Succs (1): B4

 [B6]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B5 B4

 [B7]
   1: return mid - 1;
   Preds (1): B8
   Succs (1): B0

 [B8]
   1: int mid = left + (right - left) / 2;
   T: if <null expr>
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: left <= right
   T: while [B9.1]
   Preds (2): B2 B10
   Succs (2): B8 B1

 [B10]
   1: int len;
   2: int left = 1;
   3: int right = len - 2;
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (2): B1 B7


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/removeDuplicateLetters/RemoveDuplicateLetters.cpp

function-decl: Solution::removeDuplicateLetters removeDuplicateLetters
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: const int ASCII_LEN = 256;
   2: int counter[256] = {0};
   3: _Bool visited[256] = {false};
   4: int result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/sqrt/sqrt.cpp

function-decl: sqrt sqrt
param-decl: int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: return e;
   Preds (1): B8
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B8

 [B3]
   1: e = mid - 1
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: s = mid + 1
   Preds (1): B5
   Succs (1): B2

 [B5]
   1: sq < x
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return mid;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: int mid = s + (e - s) / 2;
   2: long long sq = (long long)mid * (long long)mid;
   3: sq == x
   T: if [B7.3]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: s <= e
   T: while [B8.1]
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int e = x / 2 + 1;
   2: int s = 0;
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: return 0;
   Preds (1): B11
   Succs (1): B0

 [B11]
   1: x <= 0
   T: if [B11.1]
   Preds (1): B12
   Succs (2): B10 B9

 [B0 (EXIT)]
   Preds (3): B1 B6 B10

function-decl: sqrt_nt sqrt_nt
param-decl: int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return int(res);
   Preds (1): B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: last = res
   2: res = (res + x / res) / 2
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: res != last
   T: while [B4.1]
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: double last = 0;
   2: double res = 1;
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: return 0;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: x == 0
   T: if [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (2): B1 B6

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int n = 2;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/simplifyPath/simplifyPath.cpp

function-decl: split split
param-decl: const int &; char; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int ss;
   2: int item;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: split split
param-decl: const int &; char; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: simplifyPath simplifyPath
param-decl: int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: i--
   Preds (5): B2 B3 B4 B6 B8
   Succs (1): B10

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: ignor--
   T: continue;
   Preds (1): B5
   Succs (1): B1

 [B5]
   1: ignor > 0
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: ignor++
   T: continue;
   Preds (1): B7
   Succs (1): B1

 [B7]
   T: if <null expr>
   Preds (1): B9
   Succs (2): B6 B5

 [B8]
   T: continue;
   Preds (1): B9
   Succs (1): B1

 [B9]
   T: if <null expr>
   Preds (1): B10
   Succs (2): B8 B7

 [B10]
   1: i >= 0
   T: for (...; [B10.1]; ...)
   Preds (2): B1 B11
   Succs (2): B9 B0

 [B11]
   1: int result;
   2: int ignor = 0;
   3: int i;
   Preds (1): B12
   Succs (1): B10

 [B0 (EXIT)]
   Preds (1): B10

function-decl: main main
param-decl: int; char **; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int path;
   2: argc > 1
   T: if [B2.2]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/lexicographicalNumbers/LexicographicalNumbers.cpp

function-decl: Solution::lexicalOrder01 lexicalOrder01
param-decl: int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i <= n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int result;
   2: int i = 1;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: Solution::myComp myComp
param-decl: int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: static char si[32] = {0};
   2: static char sj[32] = {0};
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::lexicalOrder02 lexicalOrder02
param-decl: int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: i <= 9
   T: for (...; [B3.1] && [B2.1]; ...)
   Preds (1): B3
   Succs (2): B1 B0

 [B3]
   1: i <= n
   T: [B3.1] && ...
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: int result;
   2: int i = 1;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (2): B2 B3

function-decl: Solution::lexicalOrder_helper lexicalOrder_helper
param-decl: int; int &; int &; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B2]
   T: break;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: int tmp = num * 10 + i;
   2: tmp > n
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: i <= 9
   T: for (...; [B4.1]; ...)
   Preds (2): B1 B5
   Succs (2): B3 B0

 [B5]
   1: int i = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (2): B2 B4

function-decl: Solution::lexicalOrder03 lexicalOrder03
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int result;
   2: int curr = 1;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::lexicalOrder lexicalOrder
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/substringWithConcatenationOfAllWords/substringWithConcatenationOfAllWords.cpp

function-decl: findSubstring findSubstring
param-decl: int; int &; 

 [B22 (ENTRY)]
   Succs (1): B21

 [B1]
   1: i++
   Preds (1): B11
   Succs (1): B13

 [B2]
   1: j += l
   Preds (3): B3 B4 B9
   Succs (1): B11

 [B3]
   1: int tmp;
   2: winLeft += l
   3: count--
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: count == m
   T: if [B4.1]
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   1: int tmp;
   Preds (1): B6
   Succs (1): B4

 [B6]
   T: if <null expr>
   Preds (2): B7 B8
   Succs (2): B5 B4

 [B7]
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: count++
   T: if <null expr>
   Preds (1): B10
   Succs (2): B7 B6

 [B9]
   1: count = 0
   2: winLeft = j + l
   T: continue;
   Preds (1): B10
   Succs (1): B2

 [B10]
   1: int word;
   T: if <null expr>
   Preds (1): B11
   Succs (2): B9 B8

 [B11]
   1: j <= n - l
   T: for (...; [B11.1]; ...)
   Preds (2): B2 B12
   Succs (2): B10 B1

 [B12]
   1: int count = 0;
   2: int winLeft = i;
   3: int j = i;
   Preds (1): B13
   Succs (1): B11

 [B13]
   1: i < l
   T: for (...; [B13.1]; ...)
   Preds (2): B1 B14
   Succs (2): B12 B0

 [B14]
   1: int i = 0;
   Preds (1): B18
   Succs (1): B13

 [B15]
   1: i++
   Preds (2): B16 B17
   Succs (1): B18

 [B16]
   Preds (1): B17
   Succs (1): B15

 [B17]
   T: if <null expr>
   Preds (1): B18
   Succs (2): B16 B15

 [B18]
   1: i < m
   T: for (...; [B18.1]; ...)
   Preds (2): B15 B19
   Succs (2): B17 B14

 [B19]
   1: int n;
   2: int m;
   3: int l;
   4: int i = 0;
   Preds (2): B20 B21
   Succs (1): B18

 [B20]
   Preds (1): B21
   Succs (1): B19

 [B21]
   1: int result;
   T: if <null expr>
   Preds (1): B22
   Succs (2): B20 B19

 [B0 (EXIT)]
   Preds (1): B13

function-decl: main main
param-decl: int; char **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int s;
   2: int indics;
   3: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/findTheDuplicateNumber/findTheDuplicateNumber.cpp

function-decl: Solution::findDuplicate findDuplicate
param-decl: int &; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return one;
   Preds (1): B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: one != two
   T: while [B3.1]
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: one = n
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: one != two
   T: do ... while [B5.1]
   Preds (2): B6 B7
   Succs (2): B6 B4

 [B6]
   Preds (1): B5
   Succs (1): B5

 [B7]
   1: int n;
   2: int one = n;
   3: int two = n;
   Preds (1): B8
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/nthDigit/NthDigit.cpp

function-decl: Solution::findNthDigit findNthDigit
param-decl: int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: target++
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return (target) % 10;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: int target;
   2: int left = n - digits_cnt_prev - (n - digits_cnt_prev) / base * base;
   3: left == 0
   T: if [B3.3]
   Preds (1): B6
   Succs (2): B2 B1

 [B4]
   1: base++
   Preds (1): B5
   Succs (1): B6

 [B5]
   1: digits_cnt_prev = digits_cnt
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: digits_cnt < n
   T: for (; [B6.1]; ...)
   Preds (2): B4 B7
   Succs (2): B5 B3

 [B7]
   1: long digits_cnt = 0;
   2: long digits_cnt_prev = 0;
   3: int base = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/minimumPathSum/minimumPathSum.cpp

function-decl: minPathSum minPathSum
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return 0;
   Preds (1): B6
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B4
   Succs (1): B6

 [B3]
   1: j++
   Preds (1): B4
   Succs (1): B4

 [B4]
   1: j < 2
   T: for (...; [B4.1]; ...)
   Preds (2): B3 B5
   Succs (2): B3 B2

 [B5]
   1: int v;
   2: int j = 0;
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: i < 6
   T: for (...; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: int a[6][2] = {{7, 2}, {6, 6}, {8, 6}, {8, 7}, {5, 0}, {6, 0}};
   2: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/lengthOfLastWord/lengthOfLastWord.cpp

function-decl: lengthOfLastWord lengthOfLastWord
param-decl: const char *; 

 [B17 (ENTRY)]
   Succs (1): B16

 [B1]
   1: [B4.1] ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: cnt
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: wordLen
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: cnt > 0
   T: [B4.1] ? ... : ...
   Preds (1): B12
   Succs (2): B2 B3

 [B5]
   1: s++
   Preds (2): B6 B9
   Succs (1): B12

 [B6]
   1: cnt = 0
   Preds (2): B7 B8
   Succs (1): B5

 [B7]
   1: wordLen = cnt
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: cnt > 0
   T: if [B8.1]
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   T: if <null expr>
   Preds (2): B10 B11
   Succs (2): B8 B5

 [B10]
   1: cnt++
   Preds (1): B11
   Succs (1): B9

 [B11]
   T: if <null expr>
   Preds (1): B12
   Succs (2): B10 B9

 [B12]
   1: *s != '\x00'
   T: for (; [B12.1]; ...)
   Preds (2): B5 B13
   Succs (2): B11 B4

 [B13]
   1: int wordLen = 0;
   2: int cnt = 0;
   Preds (1): B15
   Succs (1): B12

 [B14]
   1: return 0;
   Preds (2): B15 B16
   Succs (1): B0

 [B15]
   1: !*s
   T: if [B16.1] || [B15.1]
   Preds (1): B16
   Succs (2): B14 B13

 [B16]
   1: !s
   T: [B16.1] || ...
   Preds (1): B17
   Succs (2): B14 B15

 [B0 (EXIT)]
   Preds (2): B1 B14

function-decl: main main
param-decl: int; char **; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: p = argv[1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: const char *p;
   2: p = "hello world"
   3: p = "a"
   4: argc > 1
   T: if [B2.4]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/minCostClimbingStairs/MinCostClimbingStairs.cpp

function-decl: Solution::minCostClimbingStairs minCostClimbingStairs
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::minCostClimbingStairs01 minCostClimbingStairs01
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::minCostClimbingStairs02 minCostClimbingStairs02
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int dp1;
   2: int dp2;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/increasingTripletSubsequence/increasingTripletSubsequence.cpp

function-decl: Solution::increasingTriplet increasingTriplet
param-decl: int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return solution;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: int first;
   2: int second = 2147483647;
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: _Bool solution = false;
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/frogJump/FrogJump.cpp

function-decl: Solution::canCross_recursion canCross_recursion
param-decl: int &; int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return false;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::canCross_recursion_with_cache canCross_recursion_with_cache
param-decl: int &; int; int; int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return false;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::canCross_non_recursion canCross_non_recursion
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::canCross canCross
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/searchInRotatedSortedArray/searchInRotatedSortedArray.cpp

function-decl: search search
param-decl: int *; int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: search2(A, n, target)
   2: return [B1.1];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: search1(A, n, target)
   2: return [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: search1 search1
param-decl: int *; int; int; 

 [B30 (ENTRY)]
   Succs (1): B29

 [B1]
   1: return -1;
   Preds (1): B21
   Succs (1): B0

 [B2]
   Preds (5): B3 B4 B5 B7 B11
   Succs (1): B21

 [B3]
   1: low = mid + 1
   T: continue;
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: A[mid] > A[high]
   T: if [B4.1]
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   1: high = mid - 1
   T: continue;
   Preds (1): B6
   Succs (1): B2

 [B6]
   1: A[low] > A[mid]
   T: if [B6.1]
   Preds (3): B8 B9 B10
   Succs (2): B5 B4

 [B7]
   1: low = mid + 1
   T: continue;
   Preds (1): B8
   Succs (1): B2

 [B8]
   1: key <= A[high]
   T: if [B10.1] && [B9.1] && [B8.1]
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: key > A[mid]
   T: [B10.1] && [B9.1] && ...
   Preds (1): B10
   Succs (2): B8 B6

 [B10]
   1: A[mid] < A[high]
   T: [B10.1] && ...
   Preds (3): B12 B13 B14
   Succs (2): B9 B6

 [B11]
   1: high = mid - 1
   T: continue;
   Preds (1): B12
   Succs (1): B2

 [B12]
   1: key < A[mid]
   T: if [B14.1] && [B13.1] && [B12.1]
   Preds (1): B13
   Succs (2): B11 B10

 [B13]
   1: key >= A[low]
   T: [B14.1] && [B13.1] && ...
   Preds (1): B14
   Succs (2): B12 B10

 [B14]
   1: A[low] < A[mid]
   T: [B14.1] && ...
   Preds (1): B16
   Succs (2): B13 B10

 [B15]
   1: return mid;
   Preds (1): B16
   Succs (1): B0

 [B16]
   1: int mid = low + (high - low) / 2;
   2: A[mid] == key
   T: if [B16.2]
   Preds (2): B18 B20
   Succs (2): B15 B14

 [B17]
   1: return -1;
   Preds (2): B18 B19
   Succs (1): B0

 [B18]
   1: key > A[high]
   T: if [B20.1] && ([B19.1] || [B18.1])
   Preds (1): B19
   Succs (2): B17 B16

 [B19]
   1: key < A[low]
   T: [B19.1] || ...
   Preds (1): B20
   Succs (2): B17 B18

 [B20]
   1: A[low] <= A[high]
   T: [B20.1] && ...
   Preds (1): B21
   Succs (2): B19 B16

 [B21]
   1: low <= high
   T: while [B21.1]
   Preds (2): B2 B22
   Succs (2): B20 B1

 [B22]
   1: int low = 0;
   2: int high = n - 1;
   Preds (1): B27
   Succs (1): B21

 [B23]
   1: ([B26.1]) ? [B24.1] : [B25.1]
   2: return [B23.1];
   Preds (2): B24 B25
   Succs (1): B0

 [B24]
   1: 0
   Preds (1): B26
   Succs (1): B23

 [B25]
   1: -1
   Preds (1): B26
   Succs (1): B23

 [B26]
   1: A[0] == key
   T: ([B26.1]) ? ... : ...
   Preds (1): B27
   Succs (2): B24 B25

 [B27]
   1: n == 1
   T: if [B27.1]
   Preds (1): B29
   Succs (2): B26 B22

 [B28]
   1: return -1;
   Preds (1): B29
   Succs (1): B0

 [B29]
   1: n <= 0
   T: if [B29.1]
   Preds (1): B30
   Succs (2): B28 B27

 [B0 (EXIT)]
   Preds (5): B1 B15 B17 B23 B28

function-decl: search2 search2
param-decl: int *; int; int; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: rotate_search(A, 0, n - 1, target)
   2: return [B1.1];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: binary_search(A, n, target)
   2: return [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: A[0] < A[n - 1]
   T: if [B3.1]
   Preds (1): B8
   Succs (2): B2 B1

 [B4]
   1: [B7.1] ? [B5.1] : [B6.1]
   2: return [B4.1];
   Preds (2): B5 B6
   Succs (1): B0

 [B5]
   1: 0
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: -1
   Preds (1): B7
   Succs (1): B4

 [B7]
   1: A[0] == target
   T: [B7.1] ? ... : ...
   Preds (1): B8
   Succs (2): B5 B6

 [B8]
   1: n == 1
   T: if [B8.1]
   Preds (1): B10
   Succs (2): B7 B3

 [B9]
   1: return -1;
   Preds (1): B10
   Succs (1): B0

 [B10]
   1: n <= 0
   T: if [B10.1]
   Preds (1): B11
   Succs (2): B9 B8

 [B0 (EXIT)]
   Preds (4): B1 B2 B4 B9

function-decl: rotate_search rotate_search
param-decl: int *; int; int; int; 

 [B23 (ENTRY)]
   Succs (1): B22

 [B1]
   1: return -1;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: rotate_search(A, mid + 1, high, key)
   2: return [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: A[mid] > A[high]
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: rotate_search(A, low, mid - 1, key)
   2: return [B4.1];
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: A[low] > A[mid]
   T: if [B5.1]
   Preds (3): B7 B8 B9
   Succs (2): B4 B3

 [B6]
   1: binary_search(A, mid + 1, high, key)
   2: return [B6.1];
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: key <= A[high]
   T: if [B9.1] && [B8.1] && [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: key > A[mid]
   T: [B9.1] && [B8.1] && ...
   Preds (1): B9
   Succs (2): B7 B5

 [B9]
   1: A[mid] < A[high]
   T: [B9.1] && ...
   Preds (3): B11 B12 B13
   Succs (2): B8 B5

 [B10]
   1: binary_search(A, low, mid - 1, key)
   2: return [B10.1];
   Preds (1): B11
   Succs (1): B0

 [B11]
   1: key < A[mid]
   T: if [B13.1] && [B12.1] && [B11.1]
   Preds (1): B12
   Succs (2): B10 B9

 [B12]
   1: key >= A[low]
   T: [B13.1] && [B12.1] && ...
   Preds (1): B13
   Succs (2): B11 B9

 [B13]
   1: A[low] < A[mid]
   T: [B13.1] && ...
   Preds (1): B15
   Succs (2): B12 B9

 [B14]
   1: return mid;
   Preds (1): B15
   Succs (1): B0

 [B15]
   1: int mid = low + (high - low) / 2;
   2: A[mid] == key
   T: if [B15.2]
   Preds (1): B20
   Succs (2): B14 B13

 [B16]
   1: [B19.1] ? [B17.1] : [B18.1]
   2: return [B16.1];
   Preds (2): B17 B18
   Succs (1): B0

 [B17]
   1: low (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B19
   Succs (1): B16

 [B18]
   1: -1
   Preds (1): B19
   Succs (1): B16

 [B19]
   1: A[low] == key
   T: [B19.1] ? ... : ...
   Preds (1): B20
   Succs (2): B17 B18

 [B20]
   1: low == high
   T: if [B20.1]
   Preds (1): B22
   Succs (2): B19 B15

 [B21]
   1: return -1;
   Preds (1): B22
   Succs (1): B0

 [B22]
   1: low > high
   T: if [B22.1]
   Preds (1): B23
   Succs (2): B21 B20

 [B0 (EXIT)]
   Preds (8): B1 B2 B4 B6 B10 B14 B16 B21

function-decl: binary_search binary_search
param-decl: int *; int; int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return -1;
   Preds (1): B8
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B8

 [B3]
   1: high = mid - 1
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: low = mid + 1
   Preds (1): B5
   Succs (1): B2

 [B5]
   1: key > A[mid]
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return mid;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: int mid = low + (high - low) / 2;
   2: A[mid] == key
   T: if [B7.2]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: low <= high
   T: while [B8.1]
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int low = 0;
   2: int high = n - 1;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (2): B1 B6

function-decl: binary_search binary_search
param-decl: int *; int; int; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: binary_search(A, low, mid - 1, key)
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: binary_search(A, mid + 1, high, key)
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: key > A[mid]
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return mid;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: A[mid] == key
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return -1;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: int mid = low + (high - low) / 2;
   2: low > high
   T: if [B7.2]
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (4): B1 B2 B4 B6

function-decl: rotate_array rotate_array
param-decl: int *; int; int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: step++
   Preds (2): B2 B3
   Succs (1): B8

 [B2]
   1: i++
   2: from++
   3: tmp = a[from]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int t;
   2: t = a[to]
   3: a[to] = tmp
   4: tmp = t
   5: from = to
   6: to == i
   T: if [B3.6]
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   1: to = from - pos
   Preds (1): B6
   Succs (1): B3

 [B5]
   1: to = n - pos + from
   Preds (1): B6
   Succs (1): B3

 [B6]
   1: int to;
   2: from - pos < 0
   T: if [B6.2]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: i < pos
   T: for (...; [B8.1] && [B7.1]; ...)
   Preds (1): B8
   Succs (2): B6 B0

 [B8]
   1: step < n
   T: [B8.1] && ...
   Preds (2): B1 B9
   Succs (2): B7 B0

 [B9]
   1: int tmp = a[0];
   2: int i = 0;
   3: int step = 0;
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: return;
   Preds (1): B11
   Succs (1): B0

 [B11]
   1: int i;
   2: int from = 0;
   3: pos = pos % n
   4: n <= 0
   T: if [B11.4]
   Preds (1): B12
   Succs (2): B10 B9

 [B0 (EXIT)]
   Preds (3): B7 B8 B10

function-decl: printArray printArray
param-decl: int *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: main main
param-decl: int; char **; 

 [B14 (ENTRY)]
   Succs (1): B13

 [B1]
   1: return 0;
   Preds (1): B10
   Succs (1): B0

 [B2]
   1: n++
   Preds (1): B3
   Succs (1): B10

 [B3]
   1: delete [] a
   Preds (2): B4 B5
   Succs (1): B2

 [B4]
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: int rotate;
   2: rotate_array(a, cnt, rotate)
   3: printArray(a, cnt)
   4: int target;
   5: search(a, cnt, target)
   6: int idx = search(a, cnt, target);
   7: idx < 0
   T: if [B5.7]
   Preds (1): B8
   Succs (2): B4 B3

 [B6]
   1: i++
   Preds (1): B7
   Succs (1): B8

 [B7]
   1: a[i] = i * 2
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: i < cnt
   T: for (...; [B8.1]; ...)
   Preds (2): B6 B9
   Succs (2): B7 B5

 [B9]
   1: new int [cnt]
   2: int *a = new int [cnt];
   3: int i = 0;
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: n <= cnt
   T: for (...; [B10.1]; ...)
   Preds (2): B2 B11
   Succs (2): B9 B1

 [B11]
   1: int n = 0;
   Preds (2): B12 B13
   Succs (1): B10

 [B12]
   Preds (1): B13
   Succs (1): B11

 [B13]
   1: int cnt = 20;
   2: argc > 1
   T: if [B13.2]
   Preds (1): B14
   Succs (2): B12 B11

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/searchInRotatedSortedArray/searchInRotatedSortedArray.II.cpp

function-decl: Solution::search search
param-decl: int *; int; int; 

 [B35 (ENTRY)]
   Succs (1): B34

 [B1]
   1: return false;
   Preds (1): B26
   Succs (1): B0

 [B2]
   Preds (5): B3 B4 B6 B8 B12
   Succs (1): B26

 [B3]
   1: low++
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: low = mid + 1
   T: continue;
   Preds (1): B5
   Succs (1): B2

 [B5]
   1: A[mid] > A[high]
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: high = mid - 1
   T: continue;
   Preds (1): B7
   Succs (1): B2

 [B7]
   1: A[low] > A[mid]
   T: if [B7.1]
   Preds (3): B9 B10 B11
   Succs (2): B6 B5

 [B8]
   1: low = mid + 1
   T: continue;
   Preds (1): B9
   Succs (1): B2

 [B9]
   1: key <= A[high]
   T: if [B11.1] && [B10.1] && [B9.1]
   Preds (1): B10
   Succs (2): B8 B7

 [B10]
   1: key > A[mid]
   T: [B11.1] && [B10.1] && ...
   Preds (1): B11
   Succs (2): B9 B7

 [B11]
   1: A[mid] < A[high]
   T: [B11.1] && ...
   Preds (3): B13 B14 B15
   Succs (2): B10 B7

 [B12]
   1: high = mid - 1
   T: continue;
   Preds (1): B13
   Succs (1): B2

 [B13]
   1: key < A[mid]
   T: if [B15.1] && [B14.1] && [B13.1]
   Preds (1): B14
   Succs (2): B12 B11

 [B14]
   1: key >= A[low]
   T: [B15.1] && [B14.1] && ...
   Preds (1): B15
   Succs (2): B13 B11

 [B15]
   1: A[low] < A[mid]
   T: [B15.1] && ...
   Preds (1): B17
   Succs (2): B14 B11

 [B16]
   1: return true;
   Preds (1): B17
   Succs (1): B0

 [B17]
   1: int mid = low + (high - low) / 2;
   2: A[mid] == key
   T: if [B17.2]
   Preds (2): B20 B21
   Succs (2): B16 B15

 [B18]
   Preds (1): B19
   Succs (1): B21

 [B19]
   1: low++
   Preds (1): B20
   Succs (1): B18

 [B20]
   1: A[low] == A[high]
   T: while [B21.1] && [B20.1]
   Preds (1): B21
   Succs (2): B19 B17

 [B21]
   1: low < high
   T: [B21.1] && ...
   Preds (3): B18 B23 B25
   Succs (2): B20 B17

 [B22]
   1: return false;
   Preds (2): B23 B24
   Succs (1): B0

 [B23]
   1: key > A[high]
   T: if [B25.1] && ([B24.1] || [B23.1])
   Preds (1): B24
   Succs (2): B22 B21

 [B24]
   1: key < A[low]
   T: [B24.1] || ...
   Preds (1): B25
   Succs (2): B22 B23

 [B25]
   1: A[low] < A[high]
   T: [B25.1] && ...
   Preds (1): B26
   Succs (2): B24 B21

 [B26]
   1: low <= high
   T: while [B26.1]
   Preds (2): B2 B27
   Succs (2): B25 B1

 [B27]
   1: int low = 0;
   2: int high = n - 1;
   Preds (1): B32
   Succs (1): B26

 [B28]
   1: ([B31.1]) ? [B29.1] : [B30.1]
   2: return [B28.1];
   Preds (2): B29 B30
   Succs (1): B0

 [B29]
   1: true
   Preds (1): B31
   Succs (1): B28

 [B30]
   1: false
   Preds (1): B31
   Succs (1): B28

 [B31]
   1: A[0] == key
   T: ([B31.1]) ? ... : ...
   Preds (1): B32
   Succs (2): B29 B30

 [B32]
   1: n == 1
   T: if [B32.1]
   Preds (1): B34
   Succs (2): B31 B27

 [B33]
   1: return false;
   Preds (1): B34
   Succs (1): B0

 [B34]
   1: n <= 0
   T: if [B34.1]
   Preds (1): B35
   Succs (2): B33 B32

 [B0 (EXIT)]
   Preds (5): B1 B16 B22 B28 B33


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/implementQueueUsingStacks/ImplementQueueUsingStacks.cpp

function-decl: Queue::push push
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Queue::pop pop
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Queue::peek peek
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int ret;
   2: return ret;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Queue::empty empty
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Queue::transfer transfer
param-decl: int &; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/binaryWatch/BinaryWatch.cpp

function-decl: Solution::Solution Solution
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::readBinaryWatch readBinaryWatch
param-decl: int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: i++
   Preds (2): B2 B3
   Succs (1): B5

 [B2]
   T: continue;
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: num - i > 5
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: i <= num
   T: for (...; [B5.1] && [B4.1]; ...)
   Preds (1): B5
   Succs (2): B3 B0

 [B5]
   1: i <= 3
   T: [B5.1] && ...
   Preds (2): B1 B6
   Succs (2): B4 B0

 [B6]
   1: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (2): B4 B5


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/removeKDigits/RemoveKDigits.cpp

function-decl: Solution::removeKdigits_pick removeKdigits_pick
param-decl: int &; int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B10

 [B2]
   1: idx = min_idx + 1
   Preds (2): B3 B4
   Succs (1): B1

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B3 B2

 [B5]
   1: j++
   Preds (2): B6 B7
   Succs (1): B8

 [B6]
   1: min_idx = j
   Preds (1): B7
   Succs (1): B5

 [B7]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: j <= i + k
   T: for (...; [B8.1]; ...)
   Preds (2): B5 B9
   Succs (2): B7 B4

 [B9]
   1: int min_idx = idx;
   2: int j = min_idx;
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: i < len - k
   T: for (...; [B10.1]; ...)
   Preds (2): B1 B11
   Succs (2): B9 B0

 [B11]
   1: int len;
   2: int result;
   3: int idx = 0;
   4: int i = 0;
   Preds (1): B12
   Succs (1): B10

 [B0 (EXIT)]
   Preds (1): B10

function-decl: Solution::removeKdigits_remove removeKdigits_remove
param-decl: int &; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B1 B0

 [B3]
   1: i++
   Preds (1): B4
   Succs (1): B5

 [B4]
   1: int len;
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: i < k
   T: for (...; [B5.1]; ...)
   Preds (2): B3 B6
   Succs (2): B4 B2

 [B6]
   1: int left_len;
   2: int idx = 0;
   3: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::removeKdigits removeKdigits
param-decl: int; int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/reconstructItinerary/ReconstructItinerary.cpp

function-decl: Solution::travel travel
param-decl: int &; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/climbStairs/climbStairs.cpp

function-decl: Solution::climbStairs climbStairs
param-decl: int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return a[1];
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: int t = a[0] + a[1];
   2: a[0] = a[1]
   3: a[1] = t
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i <= n
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int a[2] = {2, 3};
   2: int i = 4;
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: return n;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: n <= 3
   T: if [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (2): B1 B6

function-decl: Solution::climbStairs2 climbStairs2
param-decl: int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: this->climbStairs(n - 1)
   2: this->climbStairs(n - 2)
   3: return [B1.1] + [B1.2];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return n;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: n <= 3
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/removeDuplicatesFromSortedArray/removeDuplicatesFromSortedArray.II.cpp

function-decl: removeDuplicates removeDuplicates
param-decl: int *; int; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: return pos + 1;
   Preds (1): B7
   Succs (1): B0

 [B2]
   1: i++
   Preds (3): B3 B4 B5
   Succs (1): B7

 [B3]
   1: cnt = 1
   2: A[++pos] = A[i]
   Preds (1): B6
   Succs (1): B2

 [B4]
   1: A[++pos] = A[i]
   Preds (1): B5
   Succs (1): B2

 [B5]
   1: cnt++
   2: cnt == 2
   T: if [B5.2]
   Preds (1): B6
   Succs (2): B4 B2

 [B6]
   1: A[i] == A[pos]
   T: if [B6.1]
   Preds (1): B7
   Succs (2): B5 B3

 [B7]
   1: i < n
   T: for (...; [B7.1]; ...)
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B8]
   1: int pos = 0;
   2: int cnt = 1;
   3: int i = 1;
   Preds (1): B10
   Succs (1): B7

 [B9]
   1: return n;
   Preds (1): B10
   Succs (1): B0

 [B10]
   1: n <= 2
   T: if [B10.1]
   Preds (1): B11
   Succs (2): B9 B8

 [B0 (EXIT)]
   Preds (2): B1 B9

function-decl: printfArray printfArray
param-decl: int *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: testSuite testSuite
param-decl: int *; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: printfArray(a, n)
   2: removeDuplicates(a, n)
   3: n = [B1.2]
   4: printfArray(a, n)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a0[] = {1, 2, 3, 4, 5};
   2: testSuite(a0, sizeof (a0) / sizeof(int))
   3: int a1[] = {1, 1, 1};
   4: testSuite(a1, sizeof (a1) / sizeof(int))
   5: int a2[] = {1, 2, 2};
   6: testSuite(a2, sizeof (a2) / sizeof(int))
   7: int a3[] = {1, 1, 2};
   8: testSuite(a3, sizeof (a3) / sizeof(int))
   9: int a4[] = {1, 1, 1, 1};
  10: testSuite(a4, sizeof (a4) / sizeof(int))
  11: int a5[] = {1, 1, 1, 2};
  12: testSuite(a5, sizeof (a5) / sizeof(int))
  13: int a6[] = {1, 2, 2, 2};
  14: testSuite(a6, sizeof (a6) / sizeof(int))
  15: int a7[] = {1, 2, 2, 2, 3};
  16: testSuite(a7, sizeof (a7) / sizeof(int))
  17: int a8[] = {1, 2, 2, 2, 3, 3};
  18: testSuite(a8, sizeof (a8) / sizeof(int))
  19: int a9[] = {1, 1, 1, 2, 2, 3};
  20: testSuite(a9, sizeof (a9) / sizeof(int))
  21: int a10[] = {1, 1, 1, 2, 2, 2};
  22: testSuite(a10, sizeof (a10) / sizeof(int))
  23: int a11[] = {1, 1, 1, 1, 3, 3};
  24: testSuite(a11, sizeof (a11) / sizeof(int))
  25: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/removeDuplicatesFromSortedArray/removeDuplicatesFromSortedArray.cpp

function-decl: Solution::removeDuplicates removeDuplicates
param-decl: int *; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: return pos + 1;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   1: A[++pos] = A[i + 1]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: A[i] != A[i + 1]
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < n - 1
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int pos = 0;
   2: int i = 0;
   Preds (1): B8
   Succs (1): B5

 [B7]
   1: return n;
   Preds (1): B8
   Succs (1): B0

 [B8]
   1: n <= 1
   T: if [B8.1]
   Preds (1): B9
   Succs (2): B7 B6

 [B0 (EXIT)]
   Preds (2): B1 B7


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/mirrorReflection/MirrorReflection.cpp

function-decl: Solution::greatestCommonDivisor greatestCommonDivisor
param-decl: int; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return a + b;
   Preds (3): B3 B4 B5
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: (b %= a) (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: while [B4.1] && [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: (a %= b) (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: [B4.1] && ...
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: b (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::leastCommonMultiple leastCommonMultiple
param-decl: int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->greatestCommonDivisor(a, b)
   2: return a * b / [B1.1];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::mirrorReflection mirrorReflection
param-decl: int; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return 1;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 2;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: int nq = lcm / q;
   2: nq % 2 == 0
   T: if [B3.2]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return 0;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: this->leastCommonMultiple(p, q)
   2: int lcm = this->leastCommonMultiple(p, q);
   3: lcm % (2 * p) == 0
   T: if [B5.3]
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (3): B1 B2 B4


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/verticalOrderTraversalOfABinaryTree/VerticalOrderTraversalOfABinaryTree.cpp

function-decl: Item::Item Item
param-decl: int; int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: ItemCmp::operator() operator()
param-decl: const class Item &; const class Item &; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: [B4.1] ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: lhs.y > rhs.y
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: lhs.val < rhs.val
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: lhs.y != rhs.y
   T: [B4.1] ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: getValue getValue
param-decl: const class Item &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return i.val;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::verticalTraversal verticalTraversal
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int rows;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::verticalTraversalHelper verticalTraversalHelper
param-decl: int *; int; int; int &; int &; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/sumOfEvenNumbersAfterQueries/SumOfEvenNumbersAfterQueries.cpp

function-decl: Solution::sumEvenAfterQueries sumEvenAfterQueries
param-decl: int &; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int sum = 0;
   2: int result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/3Sum/3Sum.cpp

function-decl: threeSum threeSum
param-decl: int &; 

 [B14 (ENTRY)]
   Succs (1): B13

 [B1]
   1: i++
   Preds (2): B8 B10
   Succs (1): B12

 [B2]
   Preds (3): B3 B4 B6
   Succs (1): B8

 [B3]
   1: low++
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: high--
   Preds (1): B5
   Succs (1): B2

 [B5]
   1: a + b + c > 0
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: int v;
   2: low++
   3: high--
   Preds (1): B7
   Succs (1): B2

 [B7]
   1: int b;
   2: int c;
   3: a + b + c == 0
   T: if [B7.3]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: low < high
   T: while [B8.1]
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int a;
   2: int low = i + 1;
   3: int high = n - 1;
   Preds (1): B11
   Succs (1): B8

 [B10]
   T: continue;
   Preds (1): B11
   Succs (1): B1

 [B11]
   T: if <null expr>
   Preds (1): B12
   Succs (2): B10 B9

 [B12]
   1: i < n - 2
   T: for (...; [B12.1]; ...)
   Preds (2): B1 B13
   Succs (2): B11 B0

 [B13]
   1: int n;
   2: int i = 0;
   Preds (1): B14
   Succs (1): B12

 [B0 (EXIT)]
   Preds (1): B12

function-decl: threeSum2 threeSum2
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: isSumZero isSumZero
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: sum sum
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int s = 0;
   2: return s;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: combination combination
param-decl: int &; int; 

 [B22 (ENTRY)]
   Succs (1): B21

 [B1]
   Preds (1): B3
   Succs (1): B18

 [B2]
   T: break;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: !found
   T: if [B3.1]
   Preds (2): B7 B13
   Succs (2): B2 B1

 [B4]
   1: i++
   Preds (2): B5 B6
   Succs (1): B13

 [B5]
   1: ones++
   Preds (1): B6
   Succs (1): B4

 [B6]
   T: if <null expr>
   Preds (1): B12
   Succs (2): B5 B4

 [B7]
   T: break;
   Preds (1): B10
   Succs (1): B3

 [B8]
   1: j++
   Preds (1): B9
   Succs (1): B10

 [B9]
   1: ones--
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: j < i
   T: for (...; [B10.1]; ...)
   Preds (2): B8 B11
   Succs (2): B9 B7

 [B11]
   1: found = true
   2: int j = 0;
   Preds (1): B12
   Succs (1): B10

 [B12]
   T: if <null expr>
   Preds (1): B13
   Succs (2): B11 B6

 [B13]
   1: i < n - 1
   T: for (...; [B13.1]; ...)
   Preds (2): B4 B14
   Succs (2): B12 B3

 [B14]
   1: int i;
   2: _Bool found = false;
   3: int ones = 0;
   4: i = 0
   Preds (1): B16
   Succs (1): B13

 [B15]
   1: x++
   Preds (1): B16
   Succs (1): B16

 [B16]
   1: x < n
   T: for (...; [B16.1]; ...)
   Preds (2): B15 B17
   Succs (2): B15 B14

 [B17]
   1: int tmp;
   2: int x = 0;
   Preds (1): B18
   Succs (1): B16

 [B18]
   1: 1 (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: while [B18.1]
   Preds (2): B1 B20
   Succs (2): B17 NULL

 [B19]
   1: i++
   Preds (1): B20
   Succs (1): B20

 [B20]
   1: i < n
   T: for (...; [B20.1]; ...)
   Preds (2): B19 B21
   Succs (2): B19 B18

 [B21]
   1: int d;
   2: int n;
   3: int i = 0;
   Preds (1): B22
   Succs (1): B20

 [B0 (EXIT)]
   Preds (1): B2

function-decl: printMatrix printMatrix
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {-1, 1, 1, 1, -1, -1, 0, 0, 0};
   2: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/recoverBinarySearchTree/recoverBinarySearchTree.cpp

function-decl: Solution::recoverTreeHelper recoverTreeHelper
param-decl: int *; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B0

 [B4]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B3 B0

 [B5]
   1: return;
   Preds (1): B6
   Succs (1): B0

 [B6]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B5 B4

 [B0 (EXIT)]
   Preds (5): B1 B2 B3 B4 B5

function-decl: Solution::recoverTree recoverTree
param-decl: int *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/multiplyStrings/multiplyStrings.cpp

function-decl: multiply multiply
param-decl: int &; char; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: carry > 0
   T: if [B2.1]
   Preds (1): B5
   Succs (2): B1 B0

 [B3]
   1: i--
   Preds (1): B4
   Succs (1): B5

 [B4]
   1: carry = x / 10
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: i >= 0
   T: for (...; [B5.1]; ...)
   Preds (2): B3 B6
   Succs (2): B4 B2

 [B6]
   1: int n = ch - '0';
   2: int s;
   3: int carry = 0;
   4: int x;
   5: int i;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: strPlus strPlus
param-decl: int &; int &; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: carry > 0
   T: if [B2.1]
   Preds (1): B5
   Succs (2): B1 B0

 [B3]
   1: i--
   2: j--
   3: ... , [B3.2]
   Preds (1): B4
   Succs (1): B6

 [B4]
   1: int x1;
   2: int x2;
   3: x = x1 + x2 + carry
   4: carry = x / 10
   Preds (2): B5 B6
   Succs (1): B3

 [B5]
   1: j >= 0
   T: for (...; [B6.1] || [B5.1]; ...)
   Preds (1): B6
   Succs (2): B4 B2

 [B6]
   1: i >= 0
   T: [B6.1] || ...
   Preds (2): B3 B7
   Succs (2): B4 B5

 [B7]
   1: int s;
   2: int carry = 0;
   3: int x;
   4: int n1;
   5: int n2;
   6: int i;
   7: int j;
   8: i = n1 - 1
   9: j = n2 - 1
  10: ... , [B7.9]
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: multiply multiply
param-decl: int; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: i--
   Preds (1): B2
   Succs (1): B6

 [B2]
   1: shift++
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: j++
   Preds (1): B4
   Succs (1): B4

 [B4]
   1: j < shift
   T: for (...; [B4.1]; ...)
   Preds (2): B3 B5
   Succs (2): B3 B2

 [B5]
   1: int s;
   2: int j = 0;
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: i >= 0
   T: for (...; [B6.1]; ...)
   Preds (2): B1 B7
   Succs (2): B5 B0

 [B7]
   1: int shift = 0;
   2: int result;
   3: int i;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B6

function-decl: Solution::strPlus strPlus
param-decl: int &; int &; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: carry > 0
   T: if [B2.1]
   Preds (1): B7
   Succs (2): B1 B0

 [B3]
   1: i--
   2: j--
   3: ... , [B3.2]
   Preds (1): B4
   Succs (1): B7

 [B4]
   1: carry = x / 10
   Preds (2): B5 B6
   Succs (1): B3

 [B5]
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: j >= 0
   T: if [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: i >= 0
   T: for (...; [B7.1]; ...)
   Preds (2): B3 B8
   Succs (2): B6 B2

 [B8]
   1: int s;
   2: int carry = 0;
   3: int x;
   4: int i;
   5: int j;
   Preds (2): B9 B10
   Succs (1): B7

 [B9]
   Preds (1): B10
   Succs (1): B8

 [B10]
   T: if <null expr>
   Preds (1): B11
   Succs (2): B9 B8

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::multiply multiply
param-decl: int; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: i--
   Preds (1): B4
   Succs (1): B6

 [B2]
   1: j--
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: int v;
   2: carry = v / 10
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: j >= 0
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int carry = 0;
   2: int val;
   3: int j;
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: i >= 0
   T: for (...; [B6.1]; ...)
   Preds (2): B1 B7
   Succs (2): B5 B0

 [B7]
   1: int result;
   2: int i;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B6

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int s1;
   2: int s2;
   3: argc > 2
   T: if [B3.3]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/longestPalindrome/LongestPalindrome.cpp

function-decl: Solution::longestPalindrome longestPalindrome
param-decl: int; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: [B4.1] ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: result + 1
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: result (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: hasOdd (ImplicitCastExpr, LValueToRValue, _Bool)
   T: [B4.1] ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B5]
   1: __begin1 != __end1
   T: for (int n : hashtable) {
    if ([B9.2]) {
        [B8.1];
    } else {
        [B7.1];
        [B7.2];
    }
}

   Preds (2): B6 B10
   Succs (2): B9 B4

 [B6]
   1: ++__begin1
   Preds (2): B7 B8
   Succs (1): B5

 [B7]
   1: result += n - 1
   2: hasOdd = true
   Preds (1): B9
   Succs (1): B6

 [B8]
   1: result += n
   Preds (1): B9
   Succs (1): B6

 [B9]
   1: int n = *__begin1;
   2: n % 2 == 0
   T: if [B9.2]
   Preds (1): B5
   Succs (2): B8 B7

 [B10]
   1: int hashtable[128];
   2: int result = 0;
   3: _Bool hasOdd = false;
   4: auto &&__range1 = hashtable;
   5: auto __end1 = __range1 + 128L;
   6: auto __begin1 = __range1;
   Preds (1): B11
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/longestIncreasingSubsequence/longestIncreasingSubsequence.cpp

function-decl: Solution::lengthOfLIS lengthOfLIS
param-decl: int &; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return maxLen;
   Preds (1): B8
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B6
   Succs (1): B8

 [B3]
   1: j++
   Preds (2): B4 B5
   Succs (1): B6

 [B4]
   Preds (1): B5
   Succs (1): B3

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: j < i
   T: for (...; [B6.1]; ...)
   Preds (2): B3 B7
   Succs (2): B5 B2

 [B7]
   1: int j = 0;
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: i < len
   T: for (...; [B8.1]; ...)
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int len;
   2: int maxLen = 0;
   3: int i = 0;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/insertInterval/insertInterval.cpp

function-decl: Interval::Interval Interval
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Interval::Interval Interval
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: compare compare
param-decl: const struct Interval &; const struct Interval &; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: ([B4.1]) ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: lhs.end < rhs.end
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: lhs.start < rhs.start
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: lhs.start == rhs.start
   T: ([B4.1]) ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: merge merge
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: insert insert
param-decl: int &; struct Interval; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: 1, 2 (CXXConstructExpr, struct Interval)
   2: struct Interval i1(1, 2);
   3: 3, 5 (CXXConstructExpr, struct Interval)
   4: struct Interval i2(3, 5);
   5: 6, 7 (CXXConstructExpr, struct Interval)
   6: struct Interval i3(6, 7);
   7: 8, 10 (CXXConstructExpr, struct Interval)
   8: struct Interval i4(8, 10);
   9: 12, 16 (CXXConstructExpr, struct Interval)
  10: struct Interval i5(12, 16);
  11: int intervals;
  12: 4, 9 (CXXConstructExpr, struct Interval)
  13: struct Interval n(4, 9);
  14: int r;
  15: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/minimumFallingPathSum/MinimumFallingPathSum.cpp

function-decl: Solution::min min
param-decl: int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: [B4.1] ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: x
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: y
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: x < y
   T: [B4.1] ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::min min
param-decl: int; int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->min(x, y)
   2: this->min([B1.1], z)
   3: return [B1.2];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::minFallingPathSum minFallingPathSum
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int m;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/mergeTwoSortedArray/mergeTwoSortedArray.cpp

function-decl: merge merge
param-decl: int *; int; int *; int; 

 [B15 (ENTRY)]
   Succs (1): B14

 [B1]
   1: i--
   Preds (5): B2 B3 B5 B6 B7
   Succs (1): B13

 [B2]
   1: A[i] = B[ib--]
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: A[i] = A[ia--]
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: A[ia] > B[ib]
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: ib >= 0
   T: if [B6.1] && [B5.1]
   Preds (1): B6
   Succs (2): B4 B1

 [B6]
   1: ia >= 0
   T: [B6.1] && ...
   Preds (2): B8 B9
   Succs (2): B5 B1

 [B7]
   1: A[i] = B[ib--]
   T: continue;
   Preds (1): B8
   Succs (1): B1

 [B8]
   1: ib >= 0
   T: if [B9.1] && [B8.1]
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: ia < 0
   T: [B9.1] && ...
   Preds (2): B11 B12
   Succs (2): B8 B6

 [B10]
   T: break;
   Preds (1): B11
   Succs (1): B0

 [B11]
   1: ib < 0
   T: if [B12.1] && [B11.1]
   Preds (1): B12
   Succs (2): B10 B9

 [B12]
   1: ia >= 0
   T: [B12.1] && ...
   Preds (1): B13
   Succs (2): B11 B9

 [B13]
   1: i >= 0
   T: for (...; [B13.1]; ...)
   Preds (2): B1 B14
   Succs (2): B12 B0

 [B14]
   1: int ia = m - 1;
   2: int ib = n - 1;
   3: int i = m + n - 1;
   4: int i = m + n - 1;
   Preds (1): B15
   Succs (1): B13

 [B0 (EXIT)]
   Preds (2): B10 B13

function-decl: printArray printArray
param-decl: int *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {2, 4, 6, 8, 10, 0, 0, 0};
   2: int b[] = {1, 3, 5};
   3: merge(a, 5, b, 3)
   4: printArray(a, sizeof (a) / sizeof(int))
   5: int a1[] = {2, 4, 0, 0, 0};
   6: int b1[] = {3, 5, 7};
   7: merge(a1, 2, b1, 3)
   8: printArray(a1, sizeof (a1) / sizeof(int))
   9: int a2[] = {12, 14, 16, 18, 20, 0, 0, 0};
  10: int b2[] = {1, 3, 5};
  11: merge(a2, 5, b2, 3)
  12: printArray(a2, sizeof (a2) / sizeof(int))
  13: int a3[] = {2, 0};
  14: int b3[] = {3};
  15: merge(a3, 1, b3, 1)
  16: printArray(a3, sizeof (a3) / sizeof(int))
  17: int a4[] = {0, 0, 0};
  18: int b4[] = {1, 3, 5};
  19: merge(a4, 0, b4, 3)
  20: printArray(a4, sizeof (a4) / sizeof(int))
  21: int a5[] = {2, 4, 6, 8, 10, 0, 0, 0};
  22: int b5[] = {11, 13, 15};
  23: merge(a5, 5, b5, 3)
  24: printArray(a5, sizeof (a5) / sizeof(int))
  25: int a6[] = {2, 4, 0, 0, 0, 0, 0, 0};
  26: int b6[] = {1, 3, 5, 7, 9, 11};
  27: merge(a6, 2, b6, 6)
  28: printArray(a6, sizeof (a6) / sizeof(int))
  29: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/courseSchedule/CourseSchedule.cpp

function-decl: Solution::hasCycle hasCycle
param-decl: int; int &; int &; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return false;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::canFinish canFinish
param-decl: int; int &; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: return true;
   Preds (1): B7
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B4 B5
   Succs (1): B7

 [B3]
   1: return false;
   Preds (1): B4
   Succs (1): B0

 [B4]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   T: continue;
   Preds (1): B6
   Succs (1): B2

 [B6]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: i < numCourses
   T: for (...; [B7.1]; ...)
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B8]
   1: int i = 0;
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (2): B1 B3


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/courseSchedule/non-recursive/course_schedule.cpp

function-decl: Solution::canFinish canFinish
param-decl: int; int &; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return true;
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int vex;
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::to_neighbor_repr to_neighbor_repr
param-decl: int; int &; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::dsf dsf
param-decl: int; int &; int &; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: return true;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B2 B1

 [B4]
   1: i++
   Preds (2): B5 B6
   Succs (1): B7

 [B5]
   Preds (1): B6
   Succs (1): B4

 [B6]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: i < numOfvex
   T: for (...; [B7.1]; ...)
   Preds (2): B4 B8
   Succs (2): B6 B3

 [B8]
   1: int s;
   2: int starts;
   3: int i;
   4: int children;
   5: i = 0
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/courseSchedule/non-recursive/main.cpp

function-decl: Solution::canFinish canFinish
param-decl: int; int &; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return true;
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int vex;
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::to_neighbor_repr to_neighbor_repr
param-decl: int; int &; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::dsf dsf
param-decl: int; int &; int &; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: return true;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B2 B1

 [B4]
   1: i++
   Preds (2): B5 B6
   Succs (1): B7

 [B5]
   Preds (1): B6
   Succs (1): B4

 [B6]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: i < numOfvex
   T: for (...; [B7.1]; ...)
   Preds (2): B4 B8
   Succs (2): B6 B3

 [B8]
   1: int s;
   2: int starts;
   3: int i;
   4: int children;
   5: i = 0
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: int; const char **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1:  (CXXConstructExpr, class Solution)
   2: class Solution sl;
   3: int numCourses = 4;
   4: int prerequisites;
   5: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/courseSchedule/CourseSchedule.II.cpp

function-decl: Solution::topologicalSort topologicalSort
param-decl: int; int &; int &; int &; int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return true;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::findOrder findOrder
param-decl: int; int &; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < numCourses
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 0;
   Preds (1): B7
   Succs (1): B2

 [B4]
   1: i++
   Preds (2): B5 B6
   Succs (1): B7

 [B5]
   T: continue;
   Preds (1): B6
   Succs (1): B4

 [B6]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: i < numCourses
   T: for (...; [B7.1]; ...)
   Preds (2): B4 B8
   Succs (2): B6 B3

 [B8]
   1: int result;
   2: int i = 0;
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (1): B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/kthLargestElementInAnArray/KthLargestElementInAnArray.cpp

function-decl: Solution::findKthLargest_buildin findKthLargest_buildin
param-decl: int &; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int n;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::partition partition
param-decl: int &; int; int; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: return r;
   Preds (1): B9
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B9

 [B3]
   1: r--
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   1: l++
   Preds (1): B6
   Succs (1): B4

 [B6]
   T: if <null expr>
   Preds (2): B7 B8
   Succs (2): B5 B4

 [B7]
   Preds (1): B8
   Succs (1): B6

 [B8]
   T: if <null expr>
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: l <= r
   T: while [B9.1]
   Preds (2): B2 B10
   Succs (2): B8 B1

 [B10]
   1: int pivot;
   2: int l = left + 1;
   3: int r = right;
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::findKthLargest_qsort findKthLargest_qsort
param-decl: int &; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   Preds (2): B2 B3
   Succs (1): B7

 [B2]
   1: left = pos + 1
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: right = pos - 1
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: pos > k - 1
   T: if [B4.1]
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: int pos;
   2: pos == k - 1
   T: if [B6.2]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: true
   T: while [B7.1]
   Preds (2): B1 B8
   Succs (2): B6 NULL

 [B8]
   1: int left = 0;
   2: int right;
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]

function-decl: Solution::findKthLargest findKthLargest
param-decl: int &; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/uniquePaths/UniquePaths.III.cpp

function-decl: Solution::uniquePathsIII uniquePathsIII
param-decl: int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return path;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: int path = 0;
   2: int startX;
   3: int startY;
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::findStartPoint findStartPoint
param-decl: int &; int &; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return false;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::check check
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return true;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::uniquePathsHelper uniquePathsHelper
param-decl: int &; int; int; int &; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: return;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: path++
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B3 B0

 [B5]
   1: return;
   Preds (1): B6
   Succs (1): B0

 [B6]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B5 B4

 [B7]
   1: return;
   Preds (1): B8
   Succs (1): B0

 [B8]
   T: if <null expr>
   Preds (1): B9
   Succs (2): B7 B6

 [B0 (EXIT)]
   Preds (4): B1 B4 B5 B7


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/uniquePaths/uniquePaths.cpp

function-decl: uniquePaths uniquePaths
param-decl: int; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: row++
   Preds (1): B3
   Succs (1): B5

 [B2]
   1: col++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: col < m
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int col = 1;
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: row < n
   T: for (...; [B5.1]; ...)
   Preds (2): B1 B6
   Succs (2): B4 B0

 [B6]
   1: int row = 1;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B5

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int m = 3;
   2: int n = 7;
   3: argc > 2
   T: if [B3.3]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/uniquePaths/uniquePaths.II.cpp

function-decl: uniquePathsWithObstacles uniquePathsWithObstacles
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: unsigned int max = 0;
   2: return max;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: uniquePathsWithObstacles uniquePathsWithObstacles
param-decl: int &; 

 [B13 (ENTRY)]
   Succs (1): B12

 [B1]
   1: r++
   Preds (1): B3
   Succs (1): B5

 [B2]
   1: c++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: c < col
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int c = 1;
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: r < row
   T: for (...; [B5.1]; ...)
   Preds (2): B1 B6
   Succs (2): B4 B0

 [B6]
   1: int r = 1;
   Preds (1): B8
   Succs (1): B5

 [B7]
   1: c++
   Preds (1): B8
   Succs (1): B8

 [B8]
   1: c < col
   T: for (...; [B8.1]; ...)
   Preds (2): B7 B9
   Succs (2): B7 B6

 [B9]
   1: int c = 1;
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: r++
   Preds (1): B11
   Succs (1): B11

 [B11]
   1: r < row
   T: for (...; [B11.1]; ...)
   Preds (2): B10 B12
   Succs (2): B10 B9

 [B12]
   1: int row;
   2: int col;
   3: int r = 1;
   Preds (1): B13
   Succs (1): B11

 [B0 (EXIT)]
   Preds (1): B5


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/twoSum/twoSum.II.cpp

function-decl: Solution::twoSum twoSum
param-decl: int &; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   Preds (2): B2 B3
   Succs (1): B4

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: low < high
   T: while [B4.1]
   Preds (2): B1 B5
   Succs (2): B3 B0

 [B5]
   1: int result;
   2: int low = 0;
   3: int high;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B4


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/twoSum/twoSum.III.cpp

function-decl: TwoSum::add add
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TwoSum::find find
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int one;
   2: int two;
   3: return false;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/twoSum/twoSum.cpp

function-decl: Solution::twoSum twoSum
param-decl: int &; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int m;
   2: int result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::twoSum twoSum
param-decl: int &; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int m;
   2: int result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/minimumHeightTrees/MinimumHeightTrees.cpp

function-decl: Solution::findMinHeightTrees findMinHeightTrees
param-decl: int; int &; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   Preds (1): B3
   Succs (1): B4

 [B2]
   T: break;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: int next;
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: true
   T: while [B4.1]
   Preds (2): B1 B5
   Succs (2): B3 NULL

 [B5]
   1: int current;
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: return {0};
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: n <= 1
   T: if [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (2): B2 B6


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/summaryRanges/SummaryRanges.cpp

function-decl: Solution::makeRange makeRange
param-decl: int; int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int oss;
   2: start != end
   T: if [B2.2]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::summaryRanges summaryRanges
param-decl: int &; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: i++
   Preds (2): B2 B3
   Succs (1): B4

 [B2]
   T: continue;
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: i < len
   T: for (...; [B4.1]; ...)
   Preds (2): B1 B5
   Succs (2): B3 B0

 [B5]
   1: int len;
   2: int start;
   3: int end;
   4: int i = 1;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B4


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/reverseWordsInAString/reverseWordsInAString.cpp

function-decl: reverseWords reverseWords
param-decl: int &; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: char space = ' ';
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (2): B3 B4
   Succs (2): B1 B0

 [B3]
   1: pEnd = pStr
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: wordStart == true
   T: if [B4.1]
   Preds (1): B10
   Succs (2): B3 B2

 [B5]
   1: pStr++
   Preds (3): B6 B7 B8
   Succs (1): B10

 [B6]
   1: wordStart = false
   2: pEnd = pStr
   Preds (1): B7
   Succs (1): B5

 [B7]
   T: if <null expr>
   Preds (1): B9
   Succs (2): B6 B5

 [B8]
   1: wordStart = true
   2: pBegin = pStr
   T: continue;
   Preds (1): B9
   Succs (1): B5

 [B9]
   T: if <null expr>
   Preds (1): B10
   Succs (2): B8 B7

 [B10]
   1: *pStr != '\x00'
   T: for (...; [B10.1]; ...)
   Preds (2): B5 B11
   Succs (2): B9 B4

 [B11]
   1: _Bool wordStart = false;
   2: const char *pHead;
   3: const char *pStr;
   4: const char *pBegin;
   5: const char *pEnd;
   6: pStr = pHead
   Preds (1): B12
   Succs (1): B10

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: reverseWords2 reverseWords2
param-decl: int &; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: int first;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: int last;
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int result;
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (2): B1 B4

function-decl: reverse reverse
param-decl: char *; char *; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: b++
   2: e--
   3: ... , [B1.2]
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: char t = *b;
   2: *b = *e
   3: *e = t
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: e - b > 0
   T: for (...; [B3.1]; ...)
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: --e
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B3

function-decl: reverseWords reverseWords
param-decl: char *; 

 [B22 (ENTRY)]
   Succs (1): B21

 [B1]
   1: reverse(s, last)
   2: *last = '\x00'
   Preds (2): B4 B15
   Succs (1): B0

 [B2]
   1: p++
   Preds (1): B3
   Succs (1): B15

 [B3]
   1: *last++ = ' '
   Preds (1): B5
   Succs (1): B2

 [B4]
   T: break;
   Preds (1): B5
   Succs (1): B1

 [B5]
   1: ws = p
   2: *p == '\x00'
   T: if [B5.2]
   Preds (2): B8 B9
   Succs (2): B4 B3

 [B6]
   Preds (1): B7
   Succs (1): B9

 [B7]
   1: p++
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: *p == ' '
   T: while [B9.1] && [B8.1]
   Preds (1): B9
   Succs (2): B7 B5

 [B9]
   1: *p (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: [B9.1] && ...
   Preds (2): B6 B10
   Succs (2): B8 B5

 [B10]
   1: reverse(ws, p)
   2: last += (p - ws)
   Preds (2): B13 B14
   Succs (1): B9

 [B11]
   Preds (1): B12
   Succs (1): B14

 [B12]
   1: p++
   Preds (1): B13
   Succs (1): B11

 [B13]
   1: *p != ' '
   T: while [B14.1] && [B13.1]
   Preds (1): B14
   Succs (2): B12 B10

 [B14]
   1: *p (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: [B14.1] && ...
   Preds (2): B11 B15
   Succs (2): B13 B10

 [B15]
   1: *p (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: for (; [B15.1]; ...)
   Preds (2): B2 B16
   Succs (2): B14 B1

 [B16]
   1: ws = p
   Preds (2): B19 B20
   Succs (1): B15

 [B17]
   Preds (1): B18
   Succs (1): B20

 [B18]
   1: p++
   Preds (1): B19
   Succs (1): B17

 [B19]
   1: *p == ' '
   T: while [B20.1] && [B19.1]
   Preds (1): B20
   Succs (2): B18 B16

 [B20]
   1: *p (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: [B20.1] && ...
   Preds (2): B17 B21
   Succs (2): B19 B16

 [B21]
   1: char *p = s;
   2: char *ws;
   3: char *last = s;
   Preds (1): B22
   Succs (1): B20

 [B0 (EXIT)]
   Preds (1): B1

function-decl: test test
param-decl: 

 [B7 (ENTRY)]
   Succs (1): B5

 [B1]
   1: 0 (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: do ... while [B1.1]
   Preds (1): B2
   Succs (2): NULL B0

 [B2]
   1: char *s;
   2: reverseWords(s)
   Preds (2): B3 B4
   Succs (1): B1

 [B3]
   Succs (1): B2

 [B4]
   1: 0 (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: do ... while [B4.1]
   Preds (1): B5
   Succs (2): NULL B2

 [B5]
   1: char *s;
   2: reverseWords(s)
   Preds (2): B6 B7
   Succs (1): B4

 [B6]
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int s;
   2: test()
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/reverseWordsInAString/reverseWordsInAString.II.cpp

function-decl: swap swap
param-decl: char &; char &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: char temp = a;
   2: a = b
   3: b = temp
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: reverse reverse
param-decl: int &; int; int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: begin < end
   T: while [B2.1]
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (1): B2

function-decl: reverseWords reverseWords
param-decl: int &; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: int; char **; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int s;
   2: argc > 1
   T: if [B2.2]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/constructBinaryTreeFromPreorderAndInorderTraversal/constructBinaryTreeFromPreorderAndInorderTraversal.cpp

function-decl: TreeNode::TreeNode TreeNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: buildTree buildTree
param-decl: int &; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int preidx = 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: buildTree buildTree
param-decl: int &; int &; int &; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return root;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: preidx++
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   1: preidx++
   Preds (1): B5
   Succs (1): B3

 [B5]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return root;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: int i;
   T: if <null expr>
   Preds (1): B9
   Succs (2): B6 B5

 [B8]
   1: return root;
   Preds (1): B9
   Succs (1): B0

 [B9]
   1: struct TreeNode *root;
   T: if <null expr>
   Preds (1): B10
   Succs (2): B8 B7

 [B0 (EXIT)]
   Preds (3): B1 B6 B8

function-decl: printTree_pre_order printTree_pre_order
param-decl: struct TreeNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: printTree_pre_order(root->left)
   2: printTree_pre_order(root->right)
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: printTree_in_order printTree_in_order
param-decl: struct TreeNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: printTree_in_order(root->left)
   2: printTree_in_order(root->right)
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: printTree_level_order printTree_level_order
param-decl: struct TreeNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int q;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int pre_order[] = {'F', 'B', 'A', 'D', 'C', 'E', 'G', 'I', 'H'};
   2: int in_order[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'};
   3: struct TreeNode *tree;
   4: printTree_level_order(tree)
   5: printTree_pre_order(tree)
   6: printTree_in_order(tree)
   7: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/populatingNextRightPointersInEachNode/populatingNextRightPointersInEachNode.II.cpp

function-decl: TreeLinkNode::TreeLinkNode TreeLinkNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TreeLinkNode::TreeLinkNode TreeLinkNode
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: connect connect
param-decl: struct TreeLinkNode *; 

 [B13 (ENTRY)]
   Succs (1): B12

 [B1]
   1: connect(root->right)
   2: connect(root->left)
   Preds (3): B2 B3 B7
   Succs (1): B0

 [B2]
   1: left->next = right
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: [B6.3] ? [B4.1] : [B5.1]
   2: left = [B3.1]
   3: left (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B3.3]
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   1: root->right
   Preds (1): B6
   Succs (1): B3

 [B5]
   1: root->left
   Preds (1): B6
   Succs (1): B3

 [B6]
   1: struct TreeLinkNode *left;
   2: struct TreeLinkNode *right;
   3: root->right (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B6.3] ? ... : ...
   Preds (1): B7
   Succs (2): B4 B5

 [B7]
   1: root->next (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B7.1]
   Preds (3): B8 B9 B10
   Succs (2): B6 B1

 [B8]
   1: root->left->next = root->right
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: root->right (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B10.1] && [B9.1]
   Preds (1): B10
   Succs (2): B8 B7

 [B10]
   1: root->left (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B10.1] && ...
   Preds (1): B12
   Succs (2): B9 B7

 [B11]
   1: return;
   Preds (1): B12
   Succs (1): B0

 [B12]
   T: if <null expr>
   Preds (1): B13
   Succs (2): B11 B10

 [B0 (EXIT)]
   Preds (2): B1 B11

function-decl: connect1 connect1
param-decl: struct TreeLinkNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int v;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: connect3 connect3
param-decl: struct TreeLinkNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int q;
   2: struct TreeLinkNode *prev;
   3: struct TreeLinkNode *last;
   4: prev = last = root
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: connect4 connect4
param-decl: struct TreeLinkNode *; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: tail->next = root
   2: tail = root
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: head = tail = root
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: struct TreeLinkNode *head;
   2: struct TreeLinkNode *tail;
   3: struct TreeLinkNode *prev;
   4: struct TreeLinkNode *last;
   5: prev = last = root
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (3): B1 B2 B4

function-decl: printTree printTree
param-decl: struct TreeLinkNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: printTree(root->left)
   2: printTree(root->right)
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: 100 (CXXConstructExpr, struct TreeLinkNode)
   2: struct TreeLinkNode b(100);
   3: 200 (CXXConstructExpr, struct TreeLinkNode)
   4: struct TreeLinkNode c(200);
   5: a[9].left = &b
   6: connect(&a[0])
   7: printTree(&a[0])
   8: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: a[i].left = &a[++pos]
   2: a[i].right = &a[++pos]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: pos < cnt - 1
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int i = 0;
   2: int pos = 0;
   Preds (1): B8
   Succs (1): B4

 [B6]
   1: i++
   Preds (1): B7
   Succs (1): B8

 [B7]
   1: a[i].val = i + 1
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: i < cnt
   T: for (...; [B8.1]; ...)
   Preds (2): B6 B9
   Succs (2): B7 B5

 [B9]
   1: const int cnt = 15;
   2:  (CXXConstructExpr, struct TreeLinkNode [15])
   3: struct TreeLinkNode a[15];
   4: int i = 0;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/populatingNextRightPointersInEachNode/populatingNextRightPointersInEachNode.cpp

function-decl: TreeLinkNode::TreeLinkNode TreeLinkNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TreeLinkNode::TreeLinkNode TreeLinkNode
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: connect connect
param-decl: struct TreeLinkNode *; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: connect(root->left)
   2: connect(root->right)
   Preds (3): B2 B3 B4
   Succs (1): B0

 [B2]
   1: root->right->next = root->next->left
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: root->right (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B4.1] && [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: root->next (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B4.1] && ...
   Preds (3): B5 B6 B7
   Succs (2): B3 B1

 [B5]
   1: root->left->next = root->right
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: root->right (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B7.1] && [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: root->left (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B7.1] && ...
   Preds (1): B9
   Succs (2): B6 B4

 [B8]
   1: return;
   Preds (1): B9
   Succs (1): B0

 [B9]
   T: if <null expr>
   Preds (1): B10
   Succs (2): B8 B7

 [B0 (EXIT)]
   Preds (2): B1 B8

function-decl: connect1 connect1
param-decl: struct TreeLinkNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int v;
   2: int i = 0;
   3: i = 1
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: connect2 connect2
param-decl: struct TreeLinkNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int v;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: connect3 connect3
param-decl: struct TreeLinkNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int q;
   2: struct TreeLinkNode *prev;
   3: struct TreeLinkNode *last;
   4: prev = last = root
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: connect4 connect4
param-decl: struct TreeLinkNode *; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: tail->next = root
   2: tail = root
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: head = tail = root
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: struct TreeLinkNode *head;
   2: struct TreeLinkNode *tail;
   3: struct TreeLinkNode *prev;
   4: struct TreeLinkNode *last;
   5: prev = last = root
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (3): B1 B2 B4

function-decl: printTree printTree
param-decl: struct TreeLinkNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: printTree(root->left)
   2: printTree(root->right)
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: connect(&a[0])
   2: printTree(&a[0])
   3: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: a[i].left = &a[++pos]
   2: a[i].right = &a[++pos]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: pos < cnt - 1
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int i = 0;
   2: int pos = 0;
   Preds (1): B8
   Succs (1): B4

 [B6]
   1: i++
   Preds (1): B7
   Succs (1): B8

 [B7]
   1: a[i].val = i + 1
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: i < cnt
   T: for (...; [B8.1]; ...)
   Preds (2): B6 B9
   Succs (2): B7 B5

 [B9]
   1: const int cnt = 7;
   2:  (CXXConstructExpr, struct TreeLinkNode [7])
   3: struct TreeLinkNode a[7];
   4: int i = 0;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/partitionEqualSubsetSum/PartitionEqualSubsetSum.cpp

function-decl: Solution::canPartitionRecrusion canPartitionRecrusion
param-decl: int &; int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return false;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::canPartition canPartition
param-decl: int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int half = sum / 2;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: int sum = 0;
   2: sum & 1 (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/rotateList/rotateList.cpp

function-decl: Solution::rotateRight rotateRight
param-decl: int *; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < k
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int len = 1;
   2: int *p;
   3: k = len - k % len
   4: int i = 0;
   Preds (2): B4 B5
   Succs (1): B2

 [B4]
   Preds (1): B5
   Succs (1): B3

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (1): B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/buddyStrings/BuddyStrings.cpp

function-decl: Solution::buddyStrings buddyStrings
param-decl: int; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return true;
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: bRepeat (ImplicitCastExpr, LValueToRValue, _Bool)
   T: if [B3.5] && [B2.1]
   Preds (1): B3
   Succs (2): B1 B0

 [B3]
   1: _Bool bRepeat = false;
   2: _Bool map[26] = {false};
   3: int idx[2];
   4: int diffCnt = 0;
   5: diffCnt == 0
   T: [B3.5] && ...
   Preds (1): B5
   Succs (2): B2 B0

 [B4]
   1: return false;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return false;
   Preds (1): B7
   Succs (1): B0

 [B7]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (5): B1 B2 B3 B4 B6


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/h-Index/h-Index.II.cpp

function-decl: Solution::hIndex hIndex
param-decl: int &; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return n - low;
   Preds (1): B8
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B8

 [B3]
   1: low = mid + 1
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: high = mid - 1
   Preds (1): B5
   Succs (1): B2

 [B5]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return n - mid;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: int mid = low + (high - low) / 2;
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: low <= high
   T: while [B8.1]
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int n;
   2: int low = 0;
   3: int high = n - 1;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (2): B1 B6


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/h-Index/h-Index.cpp

function-decl: Solution::hIndex hIndex
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::hIndex01 hIndex01
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int h_index = 0;
   2: return h_index;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::hIndex02 hIndex02
param-decl: int &; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: return 0;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B4
   Succs (1): B5

 [B3]
   1: return n - i;
   Preds (1): B4
   Succs (1): B0

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < n
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int n;
   2: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (2): B1 B3


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/firstMissingPositive/firstMissingPositive.cpp

function-decl: firstMissingPositive_move firstMissingPositive_move
param-decl: int *; int; 

 [B18 (ENTRY)]
   Succs (1): B17

 [B1]
   1: return n + 1;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B4
   Succs (1): B5

 [B3]
   1: return i + 1;
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: i + 1 != A[i]
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < n
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int i = 0;
   Preds (1): B14
   Succs (1): B5

 [B7]
   1: i++
   Preds (3): B10 B11 B12
   Succs (1): B14

 [B8]
   Preds (1): B9
   Succs (1): B12

 [B9]
   1: num = A[i]
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: A[num - 1] != num
   T: while [B12.1] && [B11.1] && [B10.1]
   Preds (1): B11
   Succs (2): B9 B7

 [B11]
   1: num < n
   T: [B12.1] && [B11.1] && ...
   Preds (1): B12
   Succs (2): B10 B7

 [B12]
   1: num > 0
   T: [B12.1] && ...
   Preds (2): B8 B13
   Succs (2): B11 B7

 [B13]
   1: num = A[i]
   Preds (1): B14
   Succs (1): B12

 [B14]
   1: i < n
   T: for (...; [B14.1]; ...)
   Preds (2): B7 B15
   Succs (2): B13 B6

 [B15]
   1: int num;
   2: int i = 0;
   Preds (1): B17
   Succs (1): B14

 [B16]
   1: return 1;
   Preds (1): B17
   Succs (1): B0

 [B17]
   1: n <= 0
   T: if [B17.1]
   Preds (1): B18
   Succs (2): B16 B15

 [B0 (EXIT)]
   Preds (3): B1 B3 B16

function-decl: firstMissingPositive_map firstMissingPositive_map
param-decl: int *; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: int miss = 2147483647;
   2: int x;
   3: return miss;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: i++
   Preds (1): B5
   Succs (1): B5

 [B5]
   1: i < n
   T: for (...; [B5.1]; ...)
   Preds (2): B4 B6
   Succs (2): B4 B3

 [B6]
   1: int cache;
   2: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B1

function-decl: firstMissingPositive firstMissingPositive
param-decl: int *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: firstMissingPositive_map(A, n)
   2: return [B1.1];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: firstMissingPositive_move(A, n)
   2: return [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: printArray printArray
param-decl: int *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n - 1
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: Test Test
param-decl: int *; int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: printArray(a, n)
   2: firstMissingPositive(a, n)
   3: int ret = firstMissingPositive(a, n);
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a0[] = {1};
   2: Test(a0, sizeof (a0) / sizeof(int), 2)
   3: int a1[] = {1, 2, 0};
   4: Test(a1, sizeof (a1) / sizeof(int), 3)
   5: int a2[] = {3, 4, -1, 1};
   6: Test(a2, sizeof (a2) / sizeof(int), 2)
   7: int a3[] = {1000, -1};
   8: Test(a3, sizeof (a3) / sizeof(int), 1)
   9: int a4[] = {1000, 200};
  10: Test(a4, sizeof (a4) / sizeof(int), 1)
  11: int a5[] = {2, 5, 3, -1};
  12: Test(a5, sizeof (a5) / sizeof(int), 1)
  13: int a6[] = {1, 100};
  14: Test(a6, sizeof (a6) / sizeof(int), 2)
  15: int a7[] = {7, 8, 9, 11};
  16: Test(a7, sizeof (a7) / sizeof(int), 1)
  17: int a8[] = {4, 3, 2, 1};
  18: Test(a8, sizeof (a8) / sizeof(int), 5)
  19: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/happyNumber/HappyNumber.cpp

function-decl: squares squares
param-decl: int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return result;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: n /= 10
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: sq = n % 10
   2: result += (sq * sq)
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: n > 0
   T: for (; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int result = 0;
   2: int sq = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1

function-decl: isHappy isHappy
param-decl: int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: return true;
   Preds (1): B5
   Succs (1): B0

 [B2]
   Preds (1): B4
   Succs (1): B5

 [B3]
   1: return false;
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: squares(n)
   2: n = [B4.1]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: n != 1
   T: while [B5.1]
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int m;
   Preds (1): B8
   Succs (1): B5

 [B7]
   1: return true;
   Preds (1): B8
   Succs (1): B0

 [B8]
   1: n == 1
   T: if [B8.1]
   Preds (1): B9
   Succs (2): B7 B6

 [B0 (EXIT)]
   Preds (3): B1 B3 B7

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int n = 2;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/maximumProductOfWordLengths/MaximumProductOfWordLengths.cpp

function-decl: Solution::maxProduct maxProduct
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int maxLens;
   2: int result = 0;
   3: return result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/copyListWithRandomPointer/copyListWithRandomPointer.cpp

function-decl: Solution::copyRandomList copyRandomList
param-decl: int *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int *p;
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: MySolution::copyRandomList copyRandomList
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int *p;
   2: int pos = 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/differentWaysToAddParentheses/DifferentWaysToAddParentheses.cpp

function-decl: isOperator isOperator
param-decl: char; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: [B4.1] || [B3.1] || [B2.1]
   2: return ([B1.1]);
   Preds (3): B2 B3 B4
   Succs (1): B0

 [B2]
   1: ch == '*'
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: ch == '-'
   T: [B4.1] || [B3.1] || ...
   Preds (1): B4
   Succs (2): B1 B2

 [B4]
   1: ch == '+'
   T: [B4.1] || ...
   Preds (1): B5
   Succs (2): B1 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: diffWaysToCompute diffWaysToCompute
param-decl: int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int result;
   T: if <null expr>
   Preds (2): B3 B4
   Succs (2): B1 B0

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: printVector printVector
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int v;
   2: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int exp;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/addDigits/addDigits.cpp

function-decl: Solution::addDigits addDigits
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::addDigits01 addDigits01
param-decl: int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return num;
   Preds (1): B7
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B7

 [B3]
   1: num = sum
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: sum += num % 10
   2: num /= 10
   3: ... , [B4.2]
   Preds (1): B5
   Succs (1): B5

 [B5]
   1: num > 0
   T: for (...; [B5.1]; ...)
   Preds (2): B4 B6
   Succs (2): B4 B3

 [B6]
   1: int sum;
   2: sum = 0
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: num > 9
   T: while [B7.1]
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::addDigits02 addDigits02
param-decl: int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return num;
   Preds (1): B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: num = num / 10 + num % 10
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: num > 9
   T: while [B4.1]
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::addDigits03 addDigits03
param-decl: int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: [B7.1] ? ([B2.1]) : [B6.1]
   2: return [B1.1];
   Preds (2): B2 B6
   Succs (1): B0

 [B2]
   1: [B5.1] ? [B3.1] : [B4.1]
   Preds (2): B3 B4
   Succs (1): B1

 [B3]
   1: 9
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: num % 9
   Preds (1): B5
   Succs (1): B2

 [B5]
   1: (num % 9) == 0
   T: [B5.1] ? ... : ...
   Preds (1): B7
   Succs (2): B3 B4

 [B6]
   1: num (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B7
   Succs (1): B1

 [B7]
   1: num > 9
   T: [B7.1] ? ... : ...
   Preds (1): B8
   Succs (2): B5 B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::addDigits04 addDigits04
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return (num - 1) % 9 + 1;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::addDigits05 addDigits05
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return num - 9 * ((num - 1) / 9);
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/insertionSortList/insertionSortList.cpp

function-decl: ListNode::ListNode ListNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: insertionSortList insertionSortList
param-decl: struct ListNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: struct ListNode *pSorted;
   2: return pSorted;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return head;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: printList printList
param-decl: struct ListNode *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: createList createList
param-decl: int *; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return head;
   Preds (1): B6
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B6

 [B3]
   1: a[i] (CXXConstructExpr, struct ListNode)
   2: new struct ListNode([B3.1])
   3: p->next = [B3.2]
   4: p = p->next
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: a[i] (CXXConstructExpr, struct ListNode)
   2: new struct ListNode([B4.1])
   3: head = p = [B4.2]
   Preds (1): B5
   Succs (1): B2

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: i < n
   T: for (...; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: struct ListNode *head;
   2: struct ListNode *p;
   3: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: createList(a, n)
   2: struct ListNode *p = createList(a, n);
   3: printList(p)
   4: insertionSortList(p)
   5: printList([B1.4])
   6: delete [] a
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < n
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: new int [n]
   2: int *a = new int [n];
   3: int i = 0;
   Preds (2): B5 B6
   Succs (1): B3

 [B5]
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: int n = 10;
   2: argc > 1
   T: if [B6.2]
   Preds (1): B7
   Succs (2): B5 B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/isomorphicStrings/IsomorphicStrings.cpp

function-decl: Solution::isIsomorphic isIsomorphic
param-decl: int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: const int MAXCHAR = 256;
   2: char maps[256] = {0};
   3: char mapt[256] = {0};
   4: return true;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/searchInsertPosition/searchInsertPosition.cpp

function-decl: binary_search binary_search
param-decl: int *; int; int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return low;
   Preds (1): B8
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B8

 [B3]
   1: high = mid - 1
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: low = mid + 1
   Preds (1): B5
   Succs (1): B2

 [B5]
   1: key > A[mid]
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return mid;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: int mid = low + (high - low) / 2;
   2: A[mid] == key
   T: if [B7.2]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: low <= high
   T: while [B8.1]
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int low = 0;
   2: int high = n - 1;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (2): B1 B6

function-decl: searchInsert searchInsert
param-decl: int *; int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: binary_search(A, n, target)
   2: return [B1.1];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return n;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: n == 0
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {1, 3, 5, 6};
   2: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/findTheDifference/FindTheDifference.cpp

function-decl: Solution::findTheDifference findTheDifference
param-decl: int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int m;
   2: return '\x00';
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/integerReplacement/IntegerReplacement.cpp

function-decl: Solution::integerReplacement_recursion integerReplacement_recursion
param-decl: int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: this->integerReplacement(n / 2)
   2: return [B1.1] + 1;
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: n % 2 == 0
   T: if [B2.1]
   Preds (1): B4
   Succs (2): B1 B0

 [B3]
   1: return 32;
   Preds (1): B4
   Succs (1): B0

 [B4]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   1: return 0;
   Preds (1): B6
   Succs (1): B0

 [B6]
   1: n <= 1
   T: if [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B0 (EXIT)]
   Preds (4): B1 B2 B3 B5

function-decl: Solution::integerReplacement_recursionWithCache integerReplacement_recursionWithCache
param-decl: int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return result;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: this->integerReplacement(n / 2)
   2: result = [B2.1] + 1
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: n % 2 == 0
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return 32;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return 0;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: static int cache;
   2: int result;
   3: n <= 1
   T: if [B7.3]
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (3): B1 B4 B6

function-decl: Solution::integerReplacement_simple integerReplacement_simple
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int ans = 0;
   2: return ans;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::integerReplacement integerReplacement
param-decl: int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: this->integerReplacement_simple(n)
   2: return [B1.1];
   Succs (1): B0

 [B2]
   1: this->integerReplacement_recursionWithCache(n)
   2: return [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/stringToIntegerAtoi/stringToIntegerAtoi.cpp

function-decl: atoi atoi
param-decl: const char *; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: [B4.1] ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: -ret
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: ret (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: neg (ImplicitCastExpr, LValueToRValue, _Bool)
   T: [B4.1] ? ... : ...
   Preds (2): B5 B6
   Succs (2): B2 B3

 [B5]
   1: neg = (*str == '-')
   2: str++
   Preds (2): B6 B7
   Succs (1): B4

 [B6]
   1: *str == '+'
   T: if [B7.3] || [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: int ret = 0;
   2: _Bool neg = false;
   3: *str == '-'
   T: [B7.3] || ...
   Preds (1): B9
   Succs (2): B5 B6

 [B8]
   1: return 0;
   Preds (1): B9
   Succs (1): B0

 [B9]
   T: if <null expr>
   Preds (1): B10
   Succs (2): B8 B7

 [B0 (EXIT)]
   Preds (2): B1 B8

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/rotateFunction/RotateFunction.cpp

function-decl: Solution::maxRotateFunction maxRotateFunction
param-decl: int &; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return maxF;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < len
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int sum = 0;
   2: int F = 0;
   3: int maxF = F;
   4: int len;
   5: int i = 1;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/divideTwoInt/divideTwoInt.cpp

function-decl: divide divide
param-decl: int; int; 

 [B24 (ENTRY)]
   Succs (1): B23

 [B1]
   1: return (int)result * sign;
   Preds (2): B3 B4
   Succs (1): B0

 [B2]
   1: return 2147483647;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: sign > 0
   T: if [B4.1] && [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: result > 2147483647
   T: [B4.1] && ...
   Preds (1): B9
   Succs (2): B3 B1

 [B5]
   Preds (2): B6 B7
   Succs (1): B9

 [B6]
   1: i--
   Preds (1): B8
   Succs (1): B5

 [B7]
   1: dvd -= bit_num[i]
   2: result += (1 << i)
   Preds (1): B8
   Succs (1): B5

 [B8]
   1: dvd >= bit_num[i]
   T: if [B8.1]
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: dvd >= dvs
   T: while [B9.1]
   Preds (2): B5 B10
   Succs (2): B8 B4

 [B10]
   1: i--
   2: unsigned int result = 0;
   Preds (1): B13
   Succs (1): B9

 [B11]
   Preds (1): B12
   Succs (1): B13

 [B12]
   1: bit_num[++i] = d = d << 1
   Preds (1): B13
   Succs (1): B11

 [B13]
   1: d <= dvd
   T: while [B13.1]
   Preds (2): B11 B14
   Succs (2): B12 B10

 [B14]
   1: [B17.3] ? [B15.1] : [B16.1]
   2: unsigned int dvs = divisor > 0 ? divisor : -divisor;
   3: unsigned int bit_num[33];
   4: unsigned int i = 0;
   5: long long d = dvs;
   6: bit_num[i] = d
   Preds (2): B15 B16
   Succs (1): B13

 [B15]
   1: divisor (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B17
   Succs (1): B14

 [B16]
   1: -divisor
   Preds (1): B17
   Succs (1): B14

 [B17]
   1: [B20.3] ? [B18.1] : [B19.1]
   2: unsigned int dvd = dividend > 0 ? dividend : -dividend;
   3: divisor > 0
   T: [B17.3] ? ... : ...
   Preds (2): B18 B19
   Succs (2): B15 B16

 [B18]
   1: dividend (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B20
   Succs (1): B17

 [B19]
   1: -dividend
   Preds (1): B20
   Succs (1): B17

 [B20]
   1: [B23.1] ? [B21.1] : [B22.1]
   2: int sign = (float)dividend / divisor > 0 ? 1 : -1;
   3: dividend > 0
   T: [B20.3] ? ... : ...
   Preds (2): B21 B22
   Succs (2): B18 B19

 [B21]
   1: 1
   Preds (1): B23
   Succs (1): B20

 [B22]
   1: -1
   Preds (1): B23
   Succs (1): B20

 [B23]
   1: (float)dividend / divisor > 0
   T: [B23.1] ? ... : ...
   Preds (1): B24
   Succs (2): B21 B22

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/shuffleAnArray/ShuffleAnArray.cpp


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/palindromeNumber/palindromeNumber.cpp

function-decl: Solution::isPalindrome isPalindrome
param-decl: int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: this->isPalindrome2(x)
   2: return [B1.1];
   Succs (1): B0

 [B2]
   1: this->isPalindrome1(x)
   2: return [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::isPalindrome1 isPalindrome1
param-decl: int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: return true;
   Preds (1): B6
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B6

 [B3]
   1: x = (x % len) / 10
   2: len /= 100
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: return false;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: int left = x / len;
   2: int right = x % 10;
   3: left != right
   T: if [B5.3]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: x != 0
   T: while [B6.1]
   Preds (2): B2 B8
   Succs (2): B5 B1

 [B7]
   1: len *= 10
   Preds (1): B8
   Succs (1): B8

 [B8]
   1: (x / len) >= 10
   T: for (...; [B8.1]; ...)
   Preds (2): B7 B9
   Succs (2): B7 B6

 [B9]
   1: int len = 1;
   2: len = 1
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: return false;
   Preds (1): B11
   Succs (1): B0

 [B11]
   1: x < 0
   T: if [B11.1]
   Preds (1): B12
   Succs (2): B10 B9

 [B0 (EXIT)]
   Preds (3): B1 B4 B10

function-decl: Solution::isPalindrome2 isPalindrome2
param-decl: int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: [B3.1] && [B2.2]
   2: return ([B1.1]);
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: this->reverse(x)
   2: x == [B2.1]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: x >= 0
   T: [B3.1] && ...
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::reverse reverse
param-decl: int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return y;
   Preds (1): B6
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B6

 [B3]
   1: y = y * 10 + n
   2: x /= 10
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: return x - 1;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: n = x % 10
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: x != 0
   T: while [B6.1]
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: int y = 0;
   2: int n;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (2): B1 B4

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1:  (CXXConstructExpr, class Solution)
   2: class Solution s;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/maximumProductSubarray/maximumProductSubarray.cpp

function-decl: max max
param-decl: int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: [B4.1] ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: x
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: y
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: x > y
   T: [B4.1] ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: min min
param-decl: int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: [B4.1] ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: x
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: y
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: x < y
   T: [B4.1] ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: max max
param-decl: int; int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: max(y, z)
   2: max(x, [B1.1])
   3: return [B1.2];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: min min
param-decl: int; int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: min(y, z)
   2: min(x, [B1.1])
   3: return [B1.2];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: maxProduct maxProduct
param-decl: int *; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return maxProd;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: max(maxPrev * A[i], minPrev * A[i], A[i])
   2: maxHere = [B3.1]
   3: min(maxPrev * A[i], minPrev * A[i], A[i])
   4: minHere = [B3.3]
   5: max(maxHere, maxProd)
   6: maxProd = [B3.5]
   7: maxPrev = maxHere
   8: minPrev = minHere
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < n
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int maxPrev = A[0];
   2: int minPrev = A[0];
   3: int maxHere = A[0];
   4: int minHere = A[0];
   5: int maxProd = A[0];
   6: int i = 1;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int o[] = {2, 3, -2, 4};
   2: int a[] = {-4, -3};
   3: int b[] = {-1, -1};
   4: int c[] = {-1, 0, -2};
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/findMinimumInRotatedSortedArray/findMinimumInRotatedSortedArray.cpp

function-decl: findMin findMin
param-decl: int &; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   Preds (3): B2 B3 B4
   Succs (1): B8

 [B2]
   1: low = mid
   T: continue;
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: high = mid
   T: continue;
   Preds (1): B5
   Succs (1): B1

 [B5]
   T: if <null expr>
   Preds (2): B6 B7
   Succs (2): B4 B3

 [B6]
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: int mid = low + (high - low) / 2;
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: high - low > 1
   T: while [B8.1]
   Preds (2): B1 B9
   Succs (2): B7 B0

 [B9]
   1: int low = 0;
   2: int high;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B8

function-decl: rotate_array rotate_array
param-decl: int *; int; int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: step++
   Preds (2): B2 B3
   Succs (1): B8

 [B2]
   1: i++
   2: from++
   3: tmp = a[from]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int t;
   2: t = a[to]
   3: a[to] = tmp
   4: tmp = t
   5: from = to
   6: to == i
   T: if [B3.6]
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   1: to = from - pos
   Preds (1): B6
   Succs (1): B3

 [B5]
   1: to = n - pos + from
   Preds (1): B6
   Succs (1): B3

 [B6]
   1: int to;
   2: from - pos < 0
   T: if [B6.2]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: i < pos
   T: for (...; [B8.1] && [B7.1]; ...)
   Preds (1): B8
   Succs (2): B6 B0

 [B8]
   1: step < n
   T: [B8.1] && ...
   Preds (2): B1 B9
   Succs (2): B7 B0

 [B9]
   1: int tmp = a[0];
   2: int i = 0;
   3: int step = 0;
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: return;
   Preds (1): B11
   Succs (1): B0

 [B11]
   1: int i;
   2: int from = 0;
   3: pos = pos % n
   4: n <= 0
   T: if [B11.4]
   Preds (1): B12
   Succs (2): B10 B9

 [B0 (EXIT)]
   Preds (3): B7 B8 B10

function-decl: printArray printArray
param-decl: int *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: main main
param-decl: int; char **; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: delete [] a
   2: return 0;
   Preds (1): B8
   Succs (1): B0

 [B2]
   1: n++
   Preds (1): B3
   Succs (1): B8

 [B3]
   1: expectedMin = a[0]
   2: int rotate_pos;
   3: rotate_array(a, cnt, rotate_pos)
   4: printArray(a, cnt)
   Preds (1): B6
   Succs (1): B2

 [B4]
   1: i++
   Preds (1): B5
   Succs (1): B6

 [B5]
   1: a[i] = i
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: i < cnt
   T: for (...; [B6.1]; ...)
   Preds (2): B4 B7
   Succs (2): B5 B3

 [B7]
   1: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: n <= cnt
   T: for (...; [B8.1]; ...)
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int expectedMin;
   2: int actualMin;
   3: new int [cnt]
   4: int *a = new int [cnt];
   5: int n = 0;
   Preds (2): B10 B11
   Succs (1): B8

 [B10]
   Preds (1): B11
   Succs (1): B9

 [B11]
   1: int cnt = 20;
   2: argc > 1
   T: if [B11.2]
   Preds (1): B12
   Succs (2): B10 B9

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/findMinimumInRotatedSortedArray/findMinimumInRotatedSortedArray.II.cpp

function-decl: findMin findMin
param-decl: int &; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   Preds (3): B2 B3 B4
   Succs (1): B8

 [B2]
   1: low = mid
   T: continue;
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: high = mid
   T: continue;
   Preds (1): B5
   Succs (1): B1

 [B5]
   T: if <null expr>
   Preds (2): B6 B7
   Succs (2): B4 B3

 [B6]
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: int mid = low + (high - low) / 2;
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: high - low > 1
   T: while [B8.1]
   Preds (2): B1 B9
   Succs (2): B7 B0

 [B9]
   1: int low = 0;
   2: int high;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B8

function-decl: rotate_array rotate_array
param-decl: int *; int; int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: step++
   Preds (2): B2 B3
   Succs (1): B8

 [B2]
   1: i++
   2: from++
   3: tmp = a[from]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int t;
   2: t = a[to]
   3: a[to] = tmp
   4: tmp = t
   5: from = to
   6: to == i
   T: if [B3.6]
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   1: to = from - pos
   Preds (1): B6
   Succs (1): B3

 [B5]
   1: to = n - pos + from
   Preds (1): B6
   Succs (1): B3

 [B6]
   1: int to;
   2: from - pos < 0
   T: if [B6.2]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: i < pos
   T: for (...; [B8.1] && [B7.1]; ...)
   Preds (1): B8
   Succs (2): B6 B0

 [B8]
   1: step < n
   T: [B8.1] && ...
   Preds (2): B1 B9
   Succs (2): B7 B0

 [B9]
   1: int tmp = a[0];
   2: int i = 0;
   3: int step = 0;
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: return;
   Preds (1): B11
   Succs (1): B0

 [B11]
   1: int i;
   2: int from = 0;
   3: pos = pos % n
   4: n <= 0
   T: if [B11.4]
   Preds (1): B12
   Succs (2): B10 B9

 [B0 (EXIT)]
   Preds (3): B7 B8 B10

function-decl: printArray printArray
param-decl: int *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: main main
param-decl: int; char **; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: delete [] a
   2: return 0;
   Preds (1): B7
   Succs (1): B0

 [B2]
   1: n++
   Preds (1): B3
   Succs (1): B7

 [B3]
   1: expectedMin = a[0]
   2: int rotate_pos;
   3: rotate_array(a, cnt, rotate_pos)
   4: printArray(a, cnt)
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: i++
   Preds (1): B5
   Succs (1): B5

 [B5]
   1: i < cnt
   T: for (...; [B5.1]; ...)
   Preds (2): B4 B6
   Succs (2): B4 B3

 [B6]
   1: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: n <= cnt
   T: for (...; [B7.1]; ...)
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B8]
   1: int expectedMin;
   2: int actualMin;
   3: new int [cnt]
   4: int *a = new int [cnt];
   5: int n = 0;
   Preds (2): B9 B10
   Succs (1): B7

 [B9]
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: int cnt = 20;
   2: argc > 1
   T: if [B10.2]
   Preds (1): B11
   Succs (2): B9 B8

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/longestSubstringWithoutRepeatingCharacters/longestSubstringWithoutRepeatingCharacters.cpp

function-decl: lengthOfLongestSubstring1 lengthOfLongestSubstring1
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int m;
   2: int maxLen = 0;
   3: int lastRepeatPos = -1;
   4: return maxLen;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: lengthOfLongestSubstring lengthOfLongestSubstring
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: const int MAX_CHARS = 256;
   2: int m[256];
   3: int maxLen = 0;
   4: int lastRepeatPos = -1;
   5: return maxLen;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int s;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/addStrings/AddStrings.cpp

function-decl: Solution::addStrings addStrings
param-decl: int; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: carry (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: if [B2.1]
   Preds (1): B7
   Succs (2): B1 B0

 [B3]
   1: i--
   2: j--
   3: ... , [B3.2]
   Preds (1): B4
   Succs (1): B7

 [B4]
   1: carry = add / 10
   Preds (2): B5 B6
   Succs (1): B3

 [B5]
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: int add = 0;
   2: j >= 0
   T: if [B6.2]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: i >= 0
   T: for (...; [B7.1]; ...)
   Preds (2): B3 B8
   Succs (2): B6 B2

 [B8]
   1: int &longstr;
   2: int &shortstr;
   3: int longlen;
   4: int shortlen;
   5: char carry = 0;
   6: int i;
   7: int j;
   8: int result;
   9: i = longlen - 1
  10: j = shortlen - 1
  11: ... , [B8.10]
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/gameOfLife/GameOfLife.cpp

function-decl: Solution::liveCheck liveCheck
param-decl: int &; int; int; 

 [B13 (ENTRY)]
   Succs (1): B12

 [B1]
   1: i++
   Preds (2): B7 B9
   Succs (1): B11

 [B2]
   1: j++
   Preds (3): B3 B4 B5
   Succs (1): B7

 [B3]
   1: cnt++
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   T: continue;
   Preds (1): B6
   Succs (1): B2

 [B6]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: j <= c + 1
   T: for (...; [B7.1]; ...)
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B8]
   1: int j = c - 1;
   Preds (1): B10
   Succs (1): B7

 [B9]
   T: continue;
   Preds (1): B10
   Succs (1): B1

 [B10]
   T: if <null expr>
   Preds (1): B11
   Succs (2): B9 B8

 [B11]
   1: i <= r + 1
   T: for (...; [B11.1]; ...)
   Preds (2): B1 B12
   Succs (2): B10 B0

 [B12]
   1: int cnt = 0;
   2: int i = r - 1;
   Preds (1): B13
   Succs (1): B11

 [B0 (EXIT)]
   Preds (1): B11

function-decl: Solution::gameOfLife gameOfLife
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/removeInvalidParentheses/RemoveInvalidParentheses.cpp

function-decl: removeInvalidParenthesesHelper removeInvalidParenthesesHelper
param-decl: int &; int; int; int; int; int; int &; 

 [B18 (ENTRY)]
   Succs (1): B17

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: pair > 0
   T: if [B2.1]
   Preds (2): B3 B4
   Succs (2): B1 B0

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: remove_right > 0
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: ch == ')'
   T: if [B5.1]
   Preds (3): B6 B7 B8
   Succs (2): B4 B0

 [B6]
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: remove_left > 0
   T: if [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: ch == '('
   T: if [B8.1]
   Preds (2): B10 B11
   Succs (2): B7 B5

 [B9]
   1: return;
   Preds (1): B10
   Succs (1): B0

 [B10]
   1: ch != ')'
   T: if [B11.1] && [B10.1]
   Preds (1): B11
   Succs (2): B9 B8

 [B11]
   1: ch != '('
   T: [B11.1] && ...
   Preds (1): B17
   Succs (2): B10 B8

 [B12]
   1: return;
   Preds (4): B13 B14 B15 B16
   Succs (1): B0

 [B13]
   Preds (1): B14
   Succs (1): B12

 [B14]
   1: remove_right == 0
   T: if [B16.1] && [B15.1] && [B14.1]
   Preds (1): B15
   Succs (2): B13 B12

 [B15]
   1: remove_left == 0
   T: [B16.1] && [B15.1] && ...
   Preds (1): B16
   Succs (2): B14 B12

 [B16]
   1: pair == 0
   T: [B16.1] && ...
   Preds (1): B17
   Succs (2): B15 B12

 [B17]
   1: char ch;
   2: ch == '\x00'
   T: if [B17.2]
   Preds (1): B18
   Succs (2): B16 B11

 [B0 (EXIT)]
   Preds (5): B1 B2 B5 B9 B12

function-decl: removeInvalidParentheses removeInvalidParentheses
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int remove_left = 0;
   2: int remove_right = 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printVector printVector
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int s;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/rotateArray/rotateArray.cpp

function-decl: reverseArray reverseArray
param-decl: int *; int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: int temp = nums[start];
   2: nums[start++] = nums[end]
   3: nums[end--] = temp
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: start < end
   T: while [B3.1]
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: int temp;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B3

function-decl: rotate1 rotate1
param-decl: int *; int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: k %= n
   2: reverseArray(nums, n - k, n - 1)
   3: reverseArray(nums, 0, n - k - 1)
   4: reverseArray(nums, 0, n - 1)
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: k <= 0
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: rotate2 rotate2
param-decl: int *; int; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B5

 [B2]
   1: newIdx = (currIdx + k) % n
   Preds (2): B3 B4
   Succs (1): B1

 [B3]
   1: origin = ++currIdx
   2: tmp1 = nums[currIdx]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: tmp2 = nums[newIdx]
   2: nums[newIdx] = tmp1
   3: tmp1 = tmp2
   4: currIdx = newIdx
   5: origin == currIdx
   T: if [B4.5]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < n
   T: for (...; [B5.1]; ...)
   Preds (2): B1 B6
   Succs (2): B4 B0

 [B6]
   1: k %= n
   2: int currIdx = 0;
   3: int newIdx = k;
   4: int tmp1 = nums[currIdx];
   5: int tmp2;
   6: int origin = 0;
   7: int i = 0;
   Preds (1): B8
   Succs (1): B5

 [B7]
   1: return;
   Preds (1): B8
   Succs (1): B0

 [B8]
   1: k <= 0
   T: if [B8.1]
   Preds (1): B9
   Succs (2): B7 B6

 [B0 (EXIT)]
   Preds (2): B5 B7

function-decl: rotate rotate
param-decl: int *; int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: rotate2(nums, n, k)
   2: return [B1.1];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: rotate1(nums, n, k)
   2: return [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: printArray printArray
param-decl: int *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: initArray initArray
param-decl: int *; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: nums[i] = i
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: i < n
   T: for (...; [B3.1]; ...)
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: int i = 0;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B3

function-decl: main main
param-decl: int; char **; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: initArray(nums, n)
   2: rotate(nums, n, i)
   3: printArray(nums, n)
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < n
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int nums[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
   2: const int n = sizeof (nums) / sizeof(int);
   3: int i = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/implementStackUsingQueues/ImplementStackUsingQueues.cpp

function-decl: Stack::push push
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Stack::pop pop
param-decl: 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: len-- > 0
   T: while [B2.1]
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int len;
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: this->empty()
   2: ![B4.1]
   T: if [B4.2]
   Preds (1): B5
   Succs (2): B3 B0

 [B0 (EXIT)]
   Preds (2): B2 B4

function-decl: Stack::top top
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Stack::empty empty
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/splitArrayLargestSum/SplitArrayLargestSum.cpp

function-decl: Solution::splitArray splitArray
param-decl: int &; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return min;
   Preds (1): B6
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B6

 [B3]
   1: min = mid + 1
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: max = mid
   Preds (1): B5
   Succs (1): B2

 [B5]
   1: int mid = min + (max - min) / 2;
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: min < max
   T: while [B6.1]
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: int min = 0;
   2: int max = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::hasSmallerSum hasSmallerSum
param-decl: int &; int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int cnt = 1;
   2: int curSum = 0;
   3: return true;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/sudokuSolver/sudokuSolver.cpp

function-decl: initSudokuMask initSudokuMask
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return true;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: recursiveSudoKu recursiveSudoKu
param-decl: int &; int; int; 

 [B18 (ENTRY)]
   Succs (1): B17

 [B1]
   1: return false;
   Preds (1): B10
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B6
   Succs (1): B10

 [B3]
   1: row_mask[row][i] = col_mask[col][i] = area_mask[area][i] = false
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: return true;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: row_mask[row][i] = col_mask[col][i] = area_mask[area][i] = true
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   T: continue;
   Preds (3): B7 B8 B9
   Succs (1): B2

 [B7]
   1: area_mask[area][i] (ImplicitCastExpr, LValueToRValue, _Bool)
   T: if [B9.2] || [B8.1] || [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: col_mask[col][i] (ImplicitCastExpr, LValueToRValue, _Bool)
   T: [B9.2] || [B8.1] || ...
   Preds (1): B9
   Succs (2): B6 B7

 [B9]
   1: area = (row / 3) * 3 + (col / 3)
   2: row_mask[row][i] (ImplicitCastExpr, LValueToRValue, _Bool)
   T: [B9.2] || ...
   Preds (1): B10
   Succs (2): B6 B8

 [B10]
   1: i < SodukuSize
   T: for (...; [B10.1]; ...)
   Preds (2): B2 B11
   Succs (2): B9 B1

 [B11]
   1: int area;
   2: int i = 0;
   Preds (2): B12 B13
   Succs (1): B10

 [B12]
   Preds (1): B13
   Succs (1): B11

 [B13]
   T: if <null expr>
   Preds (2): B14 B15
   Succs (2): B12 B11

 [B14]
   Preds (1): B15
   Succs (1): B13

 [B15]
   1: col >= SodukuSize
   T: if [B15.1]
   Preds (1): B17
   Succs (2): B14 B13

 [B16]
   1: return true;
   Preds (1): B17
   Succs (1): B0

 [B17]
   1: row >= SodukuSize
   T: if [B17.1]
   Preds (1): B18
   Succs (2): B16 B15

 [B0 (EXIT)]
   Preds (3): B1 B4 B16

function-decl: solveSudoku solveSudoku
param-decl: int &; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: int; char **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/integerToEnglishWords/IntegerToEnglishWords.cpp

function-decl: numberLess1000ToWords numberLess1000ToWords
param-decl: int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: num % 100 > 0
   T: if [B2.1]
   Preds (1): B5
   Succs (2): B1 B0

 [B3]
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: num % 10 > 0
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B0

 [B5]
   1: num < 100
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B2

 [B6]
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: num < 20
   T: if [B7.1]
   Preds (1): B9
   Succs (2): B6 B5

 [B8]
   Preds (1): B9
   Succs (1): B0

 [B9]
   1: int result;
   2: num == 0
   T: if [B9.2]
   Preds (1): B10
   Succs (2): B8 B7

 [B0 (EXIT)]
   Preds (6): B1 B2 B3 B4 B6 B8

function-decl: numberToWords numberToWords
param-decl: int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int result;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: num /= 1000
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: num > 0
   T: for (; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int num = 123;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/setMatrixZeroes/setMatrixZeroes.cpp

function-decl: Solution::Solution Solution
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::setZeroes setZeroes
param-decl: int &; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::setZeroes1 setZeroes1
param-decl: int &; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: bCol (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: if [B2.1]
   Preds (2): B3 B4
   Succs (2): B1 B0

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: int bRow = false;
   2: int bCol = false;
   3: bRow (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: if [B4.3]
   Preds (1): B5
   Succs (2): B3 B2

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::setZeroes2 setZeroes2
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: new _Bool(/*implicit*/(_Bool)0)
   2: _Bool *row = new _Bool(/*implicit*/(_Bool)0);
   3: new _Bool(/*implicit*/(_Bool)0)
   4: _Bool *col = new _Bool(/*implicit*/(_Bool)0);
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/majorityElement/majorityElement.II.cpp

function-decl: Solution::majorityElement01 majorityElement01
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int result;
   2: int counts;
   3: int n;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::majorityElement02 majorityElement02
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int majority1 = 0;
   2: int majority2 = 0;
   3: int cnt1 = 0;
   4: int cnt2 = 0;
   5: cnt1 = cnt2 = 0
   6: int result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::majorityElement majorityElement
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/majorityElement/majorityElement.cpp

function-decl: majorityElement majorityElement
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int majority;
   2: int cnt = 0;
   3: return majority;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: split split
param-decl: const int &; char; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int ss;
   2: int item;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: split split
param-decl: const int &; char; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int elems;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int num;
   2: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int array;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/superUglyNumber/SuperUglyNumber.cpp

function-decl: Solution::nthSuperUglyNumber nthSuperUglyNumber
param-decl: int; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int len;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/partitionList/partitionList.cpp

function-decl: ListNode::ListNode ListNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: partition partition
param-decl: struct ListNode *; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: 0 (CXXConstructExpr, struct ListNode)
   2: struct ListNode fakeHead(0);
   3: fakeHead.next = head
   4: head = &fakeHead
   5: struct ListNode *pos;
   6: return head->next;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printList printList
param-decl: struct ListNode *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: createList createList
param-decl: int *; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return head;
   Preds (1): B6
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B6

 [B3]
   1: a[i] (CXXConstructExpr, struct ListNode)
   2: new struct ListNode([B3.1])
   3: p->next = [B3.2]
   4: p = p->next
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: a[i] (CXXConstructExpr, struct ListNode)
   2: new struct ListNode([B4.1])
   3: head = p = [B4.2]
   Preds (1): B5
   Succs (1): B2

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: i < n
   T: for (...; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: struct ListNode *head;
   2: struct ListNode *p;
   3: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {3, 1, 2};
   2: int x = 3;
   3: createList(a, sizeof (a) / sizeof(int))
   4: struct ListNode *p = createList(a, sizeof (a) / sizeof(int));
   5: printList(p)
   6: partition(p, x)
   7: p = [B1.6]
   8: printList(p)
   9: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/permutationSequence/permutationSequence.cpp

function-decl: getPermutation getPermutation
param-decl: int; int; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: group = group / n
   2: int idx = (k - 1) / group;
   3: n--
   4: k -= group * idx
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: n > 0
   T: while [B3.1]
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: int group = total;
   2: int ss;
   Preds (2): B5 B6
   Succs (1): B3

 [B5]
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: total < k
   T: if [B6.1]
   Preds (1): B9
   Succs (2): B5 B4

 [B7]
   1: i++
   Preds (1): B8
   Succs (1): B9

 [B8]
   1: total *= i
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: i <= n
   T: for (...; [B9.1]; ...)
   Preds (2): B7 B10
   Succs (2): B8 B6

 [B10]
   1: int num;
   2: int total = 1;
   3: int i = 1;
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (1): B3

function-decl: getPermutation_0 getPermutation_0
param-decl: int; int; 

 [B13 (ENTRY)]
   Succs (1): B12

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int ss;
   2: int i = 0;
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: i++
   Preds (1): B5
   Succs (1): B5

 [B5]
   1: i < offset
   T: for (...; [B5.1]; ...)
   Preds (2): B4 B6
   Succs (2): B4 B3

 [B6]
   1: int group = total / n;
   2: int idx = (k - 1) / group;
   3: int nn;
   4: int offset = (k - 1) % group;
   5: int i = 0;
   Preds (2): B7 B8
   Succs (1): B5

 [B7]
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: total < k
   T: if [B8.1]
   Preds (1): B11
   Succs (2): B7 B6

 [B9]
   1: i++
   Preds (1): B10
   Succs (1): B11

 [B10]
   1: total *= i
   Preds (1): B11
   Succs (1): B9

 [B11]
   1: i <= n
   T: for (...; [B11.1]; ...)
   Preds (2): B9 B12
   Succs (2): B10 B8

 [B12]
   1: int num;
   2: int total = 1;
   3: int i = 1;
   Preds (1): B13
   Succs (1): B11

 [B0 (EXIT)]
   Preds (1): B2

function-decl: getPermutation_1 getPermutation_1
param-decl: int; int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int ss;
   2: int i = 0;
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: i++
   Preds (1): B5
   Succs (1): B5

 [B5]
   1: i < k
   T: for (...; [B5.1]; ...)
   Preds (2): B4 B6
   Succs (2): B4 B3

 [B6]
   1: int i = 1;
   Preds (1): B8
   Succs (1): B5

 [B7]
   1: i++
   Preds (1): B8
   Succs (1): B8

 [B8]
   1: i <= n
   T: for (...; [B8.1]; ...)
   Preds (2): B7 B9
   Succs (2): B7 B6

 [B9]
   1: int num;
   2: int i = 1;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B2

function-decl: nextPermutation nextPermutation
param-decl: int &; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: i--
   Preds (1): B3
   Succs (1): B4

 [B2]
   1: int j;
   2: int temp;
   3: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: i > 0
   T: for (...; [B4.1]; ...)
   Preds (2): B1 B5
   Succs (2): B3 B0

 [B5]
   1: int i;
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: return;
   Preds (1): B7
   Succs (1): B0

 [B7]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (3): B2 B4 B6

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int n = 3;
   2: int k = 6;
   3: argc > 2
   T: if [B3.3]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/strStr/strStr.cpp

function-decl: strStr strStr
param-decl: char *; char *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: strStr2(haystack, needle)
   2: return [B1.1];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: strStr1(haystack, needle)
   2: return [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: strStr1 strStr1
param-decl: char *; char *; 

 [B30 (ENTRY)]
   Succs (1): B29

 [B1]
   1: haystack++
   2: ph++
   3: ... , [B1.2]
   Preds (1): B2
   Succs (1): B16

 [B2]
   1: [B5.1] ? [B3.1] : [B4.1]
   2: haystack += ([B2.1])
   Preds (2): B3 B4
   Succs (1): B1

 [B3]
   1: n - 1
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: n (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B5
   Succs (1): B2

 [B5]
   1: n > 0
   T: [B5.1] ? ... : ...
   Preds (1): B7
   Succs (2): B3 B4

 [B6]
   1: return haystack;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: !*q
   T: if [B7.1]
   Preds (3): B12 B13 B14
   Succs (2): B6 B5

 [B8]
   Preds (3): B9 B10 B11
   Succs (1): B14

 [B9]
   1: n = p - haystack
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: *p == *needle
   T: if [B11.3] && [B10.1]
   Preds (1): B11
   Succs (2): B9 B8

 [B11]
   1: p++
   2: q++
   3: n == 0
   T: [B11.3] && ...
   Preds (1): B12
   Succs (2): B10 B8

 [B12]
   1: *p == *q
   T: while [B14.1] && [B13.1] && [B12.1]
   Preds (1): B13
   Succs (2): B11 B7

 [B13]
   1: *p (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: [B14.1] && [B13.1] && ...
   Preds (1): B14
   Succs (2): B12 B7

 [B14]
   1: *q (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: [B14.1] && ...
   Preds (2): B8 B15
   Succs (2): B13 B7

 [B15]
   1: char *q = needle;
   2: char *p = haystack;
   3: int n = 0;
   Preds (1): B16
   Succs (1): B14

 [B16]
   1: *ph (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: for (...; [B16.1]; ...)
   Preds (2): B1 B17
   Succs (2): B15 B0

 [B17]
   1: ph = ph - 1
   Preds (3): B18 B19 B20
   Succs (1): B16

 [B18]
   Preds (1): B19
   Succs (1): B17

 [B19]
   1: *pn (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: if [B20.1] && [B19.1]
   Preds (1): B20
   Succs (2): B18 B17

 [B20]
   1: !*ph
   T: [B20.1] && ...
   Preds (2): B22 B23
   Succs (2): B19 B17

 [B21]
   1: ph++
   2: pn++
   3: ... , [B21.2]
   Preds (1): B22
   Succs (1): B23

 [B22]
   1: *pn (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: for (; [B23.1] && [B22.1]; ...)
   Preds (1): B23
   Succs (2): B21 B20

 [B23]
   1: *ph (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: [B23.1] && ...
   Preds (2): B21 B24
   Succs (2): B22 B20

 [B24]
   1: char *ph = haystack;
   2: char *pn = needle;
   Preds (1): B26
   Succs (1): B23

 [B25]
   1: return haystack;
   Preds (1): B26
   Succs (1): B0

 [B26]
   1: !*needle
   T: if [B26.1]
   Preds (2): B27 B28
   Succs (2): B25 B24

 [B27]
   Preds (2): B28 B29
   Succs (1): B26

 [B28]
   1: !needle
   T: if [B29.1] || [B28.1]
   Preds (1): B29
   Succs (2): B27 B26

 [B29]
   1: !haystack
   T: [B29.1] || ...
   Preds (1): B30
   Succs (2): B27 B28

 [B0 (EXIT)]
   Preds (3): B6 B16 B25

function-decl: strStr2 strStr2
param-decl: char *; char *; 

 [B24 (ENTRY)]
   Succs (1): B23

 [B1]
   1: haystack++
   2: ph++
   3: ... , [B1.2]
   Preds (1): B3
   Succs (1): B10

 [B2]
   1: return haystack;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: !*q
   T: if [B3.1]
   Preds (3): B6 B7 B8
   Succs (2): B2 B1

 [B4]
   Preds (1): B5
   Succs (1): B8

 [B5]
   1: p++
   2: q++
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: *p == *q
   T: while [B8.1] && [B7.1] && [B6.1]
   Preds (1): B7
   Succs (2): B5 B3

 [B7]
   1: *p (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: [B8.1] && [B7.1] && ...
   Preds (1): B8
   Succs (2): B6 B3

 [B8]
   1: *q (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: [B8.1] && ...
   Preds (2): B4 B9
   Succs (2): B7 B3

 [B9]
   1: char *q = needle;
   2: char *p = haystack;
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: *ph (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: for (; [B10.1]; ...)
   Preds (2): B1 B11
   Succs (2): B9 B0

 [B11]
   1: ph--
   Preds (3): B12 B13 B14
   Succs (1): B10

 [B12]
   Preds (1): B13
   Succs (1): B11

 [B13]
   1: *pn (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: if [B14.1] && [B13.1]
   Preds (1): B14
   Succs (2): B12 B11

 [B14]
   1: !*ph
   T: [B14.1] && ...
   Preds (2): B16 B17
   Succs (2): B13 B11

 [B15]
   1: ph++
   2: pn++
   3: ... , [B15.2]
   Preds (1): B16
   Succs (1): B17

 [B16]
   1: *pn (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: for (; [B17.1] && [B16.1]; ...)
   Preds (1): B17
   Succs (2): B15 B14

 [B17]
   1: *ph (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: [B17.1] && ...
   Preds (2): B15 B18
   Succs (2): B16 B14

 [B18]
   1: char *ph = haystack;
   2: char *pn = needle;
   Preds (1): B20
   Succs (1): B17

 [B19]
   1: return haystack;
   Preds (1): B20
   Succs (1): B0

 [B20]
   1: !*needle
   T: if [B20.1]
   Preds (2): B21 B22
   Succs (2): B19 B18

 [B21]
   Preds (2): B22 B23
   Succs (1): B20

 [B22]
   1: !needle
   T: if [B23.1] || [B22.1]
   Preds (1): B23
   Succs (2): B21 B20

 [B23]
   1: !haystack
   T: [B23.1] || ...
   Preds (1): B24
   Succs (2): B21 B22

 [B0 (EXIT)]
   Preds (3): B2 B10 B19

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: haystack = argv[1]
   2: needle = argv[2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: const char *haystack = "mississippi";
   2: const char *needle = "issi";
   3: haystack = "mississippi"
   4: needle = "issip"
   5: haystack = "babbbbbabb"
   6: needle = "bbab"
   7: argc > 2
   T: if [B3.7]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/wordBreak/wordBreak.cpp

function-decl: wordBreak wordBreak
param-decl: int; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int s;
   2: int d[];
   3: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/wordBreak/wordBreak.II.cpp

function-decl: wordBreak wordBreak
param-decl: int; int &; int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: wordBreak wordBreak
param-decl: int; int &; int; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int org_str;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: wordBreak_dp wordBreak_dp
param-decl: int; int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i--
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i >= 0
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: wordBreak wordBreak
param-decl: int; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printVector printVector
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int d[];
   2: int s;
   3: int d0[];
   4: int d1[];
   5: int d5[];
   6: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/largestRectangleInHistogram/largestRectangleInHistogram.cpp

function-decl: largestRectangleArea_01 largestRectangleArea_01
param-decl: int &; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: int maxArea = 0;
   2: return maxArea;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i--
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: int r = i + 1;
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i >= 0
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int i;
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: return 0;
   Preds (1): B7
   Succs (1): B0

 [B7]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (2): B1 B6

function-decl: largestRectangleArea largestRectangleArea
param-decl: int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int stack;
   2: int maxArea = 0;
   3: return maxArea;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: printArray printArray
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: test test
param-decl: int *; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a0[] = {2, 1, 3, 1};
   2: test(a0, sizeof (a0) / sizeof(int))
   3: int a1[] = {2, 1, 5, 6, 2, 3};
   4: test(a1, sizeof (a1) / sizeof(int))
   5: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/patchingArray/PatchingArray.cpp

function-decl: Solution::minPatches minPatches
param-decl: int &; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::minPatches_01 minPatches_01
param-decl: int &; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return patch_cnt;
   Preds (1): B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: int try_patch = covered + 1;
   2: patch_cnt++
   3: covered = covered + try_patch
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: covered < n
   T: while [B4.1]
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: long covered = 0;
   2: int patch_cnt = 0;
   3: int i = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::minPatches_02 minPatches_02
param-decl: int &; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return patch_cnt;
   Preds (1): B6
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B6

 [B3]
   1: covered = 2 * covered + 1
   2: patch_cnt++
   Preds (1): B5
   Succs (1): B2

 [B4]
   Preds (1): B5
   Succs (1): B2

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: covered < n
   T: while [B6.1]
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: long covered = 0;
   2: int patch_cnt = 0;
   3: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/letterCombinationsOfAPhoneNumber/letterCombinationsOfAPhoneNumber.cpp

function-decl: letterCombinations letterCombinations
param-decl: int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: char phone[10][4] = {{' ', '\x00', '\x00', '\x00'}, {'\x00', '\x00', '\x00', '\x00'}, {'a', 'b', 'c', '\x00'}, {'d', 'e', 'f', '\x00'}, {'g', 'h', 'i', '\x00'}, {'j', 'k', 'l', '\x00'}, {'m', 'n', 'o', '\x00'}, {'p', 'q', 'r', 's'}, {'t', 'u', 'v', '\x00'}, {'w', 'x', 'y', 'z'}};
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: printVector printVector
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int s;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/distributeCoinsInBinaryTree/DistributeCoinsInBinaryTree.cpp

function-decl: Solution::distributeCoins distributeCoins
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int result = 0;
   2: return result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::dfs dfs
param-decl: int *; int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int left_move;
   2: int right_move;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/longestIncreasingPathInAMatrix/LongestIncreasingPathInAMatrix.cpp

function-decl: Solution::longestIncreasingPath longestIncreasingPath
param-decl: int &; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return result;
   Preds (1): B6
   Succs (1): B0

 [B2]
   1: r++
   Preds (1): B4
   Succs (1): B6

 [B3]
   1: c++
   Preds (1): B4
   Succs (1): B4

 [B4]
   1: c < col
   T: for (...; [B4.1]; ...)
   Preds (2): B3 B5
   Succs (2): B3 B2

 [B5]
   1: int c = 0;
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: r < row
   T: for (...; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: int result = 0;
   2: int row;
   3: int col;
   4: int r = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::helper helper
param-decl: int &; int &; const int; const int; int; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (2): B3 B4
   Succs (2): B1 B0

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   Preds (1): B6
   Succs (1): B4

 [B6]
   T: if <null expr>
   Preds (2): B7 B8
   Succs (2): B5 B4

 [B7]
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: int maxPath = 0;
   2: int tmp;
   T: if <null expr>
   Preds (1): B9
   Succs (2): B7 B6

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/maxPointsOnALine/maxPointsOnALine.cpp

function-decl: Point::Point Point
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Point::Point Point
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: maxPoints maxPoints
param-decl: int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int maxnum = 0;
   2: int slopeMap;
   3: return maxnum;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: generatePoints generatePoints
param-decl: int &; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1:  (CXXConstructExpr, struct Point)
   2: struct Point p;
   3: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: printPoints printPoints
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int points;
   2: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int n = 20;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/wordLadder/wordLadder.II.cpp

function-decl: generatePath generatePath
param-decl: int; int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B0

 [B0 (EXIT)]
   Preds (2): B1 B4

function-decl: findLadders findLadders
param-decl: int; int; int &; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (2): B3 B4
   Succs (2): B1 B0

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: printLadders printLadders
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int i;
   2: int j;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int start;
   2: int end;
   3: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/wordLadder/wordLadder.cpp

function-decl: Solution::ladderLength ladderLength
param-decl: int; int; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/containsDuplicate/ContainsDuplicate.III.cpp

function-decl: Solution::containsNearbyAlmostDuplicate containsNearbyAlmostDuplicate
param-decl: int &; int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int low = 0;
   2: int window;
   3: return false;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/containsDuplicate/ContainsDuplicate.II.cpp

function-decl: Solution::containsNearbyDuplicate containsNearbyDuplicate
param-decl: int &; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int m;
   2: return false;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/containsDuplicate/ContainsDuplicate.cpp

function-decl: Solution::containsDuplicate containsDuplicate
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int m;
   2: return false;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/scrambleString/scrambleString.cpp

function-decl: isScramble_recursion isScramble_recursion
param-decl: int; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: int ss1;
   2: int ss2;
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return true;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return false;
   Preds (1): B7
   Succs (1): B0

 [B7]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (4): B1 B2 B4 B6

function-decl: isScramble_dp isScramble_dp
param-decl: int; int; 

 [B20 (ENTRY)]
   Succs (1): B19

 [B1]
   1: k++
   Preds (1): B6
   Succs (1): B8

 [B2]
   1: i++
   Preds (1): B4
   Succs (1): B6

 [B3]
   1: j++
   Preds (1): B4
   Succs (1): B4

 [B4]
   1: j < len - k + 1
   T: for (...; [B4.1]; ...)
   Preds (2): B3 B5
   Succs (2): B3 B2

 [B5]
   1: int j = 0;
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: i < len - k + 1
   T: for (...; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: k <= len
   T: for (...; [B8.1]; ...)
   Preds (2): B1 B9
   Succs (2): B7 B0

 [B9]
   1: int k = 2;
   Preds (1): B14
   Succs (1): B8

 [B10]
   1: i++
   Preds (1): B12
   Succs (1): B14

 [B11]
   1: j++
   Preds (1): B12
   Succs (1): B12

 [B12]
   1: j < len
   T: for (...; [B12.1]; ...)
   Preds (2): B11 B13
   Succs (2): B11 B10

 [B13]
   1: int j = 0;
   Preds (1): B14
   Succs (1): B12

 [B14]
   1: i < len
   T: for (...; [B14.1]; ...)
   Preds (2): B10 B15
   Succs (2): B13 B9

 [B15]
   1: const int len;
   2: int i = 0;
   Preds (1): B17
   Succs (1): B14

 [B16]
   1: return true;
   Preds (1): B17
   Succs (1): B0

 [B17]
   T: if <null expr>
   Preds (1): B19
   Succs (2): B16 B15

 [B18]
   1: return false;
   Preds (1): B19
   Succs (1): B0

 [B19]
   T: if <null expr>
   Preds (1): B20
   Succs (2): B18 B17

 [B0 (EXIT)]
   Preds (3): B8 B16 B18

function-decl: isScramble isScramble
param-decl: int; int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int s1;
   2: argc > 2
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/longestSubstringWithAtLeastKRepeatingCharacters/LongestSubstringWithAtLeastKRepeatingCharacters.cpp

function-decl: Solution::longestSubstring longestSubstring
param-decl: int; int; 

 [B20 (ENTRY)]
   Succs (1): B19

 [B1]
   1: return 0;
   Succs (1): B0

 [B2]
   1: int res = 0;
   2: return res;
   Preds (1): B10
   Succs (1): B0

 [B3]
   1: c++
   Preds (4): B4 B5 B6 B8
   Succs (1): B10

 [B4]
   1: least = c
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: count[c] < count[least]
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: least = c
   Preds (1): B7
   Succs (1): B3

 [B7]
   1: least == 0
   T: if [B7.1]
   Preds (1): B9
   Succs (2): B6 B5

 [B8]
   T: continue;
   Preds (1): B9
   Succs (1): B3

 [B9]
   1: count[c] == 0
   T: if [B9.1]
   Preds (1): B10
   Succs (2): B8 B7

 [B10]
   1: c < NO_OF_CHARS
   T: for (...; [B10.1]; ...)
   Preds (2): B3 B11
   Succs (2): B9 B2

 [B11]
   1: char least = 0;
   2: int c = 0;
   Preds (2): B13 B16
   Succs (1): B10

 [B12]
   1: i++
   Preds (2): B14 B15
   Succs (1): B16

 [B13]
   T: break;
   Preds (1): B14
   Succs (1): B11

 [B14]
   1: count[i] < k
   T: if [B15.1] && [B14.1]
   Preds (1): B15
   Succs (2): B13 B12

 [B15]
   1: count[i] != 0
   T: [B15.1] && ...
   Preds (1): B16
   Succs (2): B14 B12

 [B16]
   1: i < NO_OF_CHARS
   T: for (...; [B16.1]; ...)
   Preds (2): B12 B17
   Succs (2): B15 B11

 [B17]
   1: int count[256];
   2: int i = 0;
   3: i = 0
   Preds (1): B19
   Succs (1): B16

 [B18]
   1: return 0;
   Preds (1): B19
   Succs (1): B0

 [B19]
   T: if <null expr>
   Preds (1): B20
   Succs (2): B18 B17

 [B0 (EXIT)]
   Preds (3): B1 B2 B18

function-decl: Solution::max max
param-decl: int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: [B4.1] ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: x
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: y
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: x > y
   T: [B4.1] ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::split split
param-decl: const int &; char; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int ss;
   2: int item;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::split split
param-decl: const int &; char; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/maxAreaOfIsland/MaxAreaOfIsland.cpp

function-decl: Solution::maxAreaOfIsland maxAreaOfIsland
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int maxArea = 0;
   2: return maxArea;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::maxAreaOfIsland_DFS maxAreaOfIsland_DFS
param-decl: int &; int; int; int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: area++
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/integerBreak/IntegerBreak.cpp

function-decl: Solution::integerBreak integerBreak
param-decl: int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: result *= n
   2: return result;
   Preds (1): B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: result *= 3
   2: n -= 3
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: n > 4
   T: while [B4.1]
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int result = 1;
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: return 2;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: n == 3
   T: if [B7.1]
   Preds (1): B9
   Succs (2): B6 B5

 [B8]
   1: return 1;
   Preds (1): B9
   Succs (1): B0

 [B9]
   1: n == 2
   T: if [B9.1]
   Preds (1): B10
   Succs (2): B8 B7

 [B0 (EXIT)]
   Preds (3): B1 B6 B8


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/numberOfDigitOne/NumberOfDigitOne.cpp

function-decl: Solution::countDigitOne countDigitOne
param-decl: int; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: return numOfOne;
   Preds (1): B9
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B9

 [B3]
   1: right = right + currDigit * base
   2: base *= 10
   Preds (3): B4 B5 B7
   Succs (1): B2

 [B4]
   1: numOfOne += ((left + 1) * base)
   Preds (1): B6
   Succs (1): B3

 [B5]
   1: numOfOne += (left * base + right + 1)
   Preds (1): B6
   Succs (1): B3

 [B6]
   1: currDigit == 1
   T: if [B6.1]
   Preds (1): B8
   Succs (2): B5 B4

 [B7]
   1: numOfOne += (left * base)
   Preds (1): B8
   Succs (1): B3

 [B8]
   1: currDigit = left % 10
   2: left = left / 10
   3: currDigit == 0
   T: if [B8.3]
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: left > 0
   T: while [B9.1]
   Preds (2): B2 B10
   Succs (2): B8 B1

 [B10]
   1: long long base = 1;
   2: long long left = n;
   3: long long right = 0;
   4: long long currDigit = 0;
   5: int numOfOne = 0;
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/excelSheetColumnNumber/excelSheetColumnNumber.cpp

function-decl: base26_int2str base26_int2str
param-decl: long long; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: char ch = 'A' + (n - 1) % 26;
   2: n -= (n - 1) % 26
   3: n /= 26
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: n > 0
   T: while [B3.1]
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: int ret;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B3

function-decl: base26_str2int base26_str2int
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: long long ret = 0;
   2: return ret;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: titleToNumber titleToNumber
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int ns;
   2: argc > 2
   T: if [B2.2]
   Preds (2): B3 B4
   Succs (2): B1 B0

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: long long n = 27;
   2: argc > 1
   T: if [B4.2]
   Preds (1): B5
   Succs (2): B3 B2

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/missingNumber/MissingNumber.cpp

function-decl: Solution::missingNumber01 missingNumber01
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int result = 0;
   2: return result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::missingNumber02 missingNumber02
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int result = 0;
   2: return result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::missingNumber missingNumber
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/generateParentheses/generateParentheses.cpp

function-decl: generateParenthesis generateParenthesis
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int s;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: generator generator
param-decl: int &; int; int; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: right > left
   T: if [B3.1] && [B2.1]
   Preds (1): B3
   Succs (2): B1 B0

 [B3]
   1: right > 0
   T: [B3.1] && ...
   Preds (2): B4 B5
   Succs (2): B2 B0

 [B4]
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: left > 0
   T: if [B5.1]
   Preds (2): B7 B8
   Succs (2): B4 B3

 [B6]
   1: return;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: right == 0
   T: if [B8.1] && [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: left == 0
   T: [B8.1] && ...
   Preds (1): B9
   Succs (2): B7 B5

 [B0 (EXIT)]
   Preds (4): B1 B2 B3 B6

function-decl: printResult printResult
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int n = 3;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/LRUCache/LRUCache.cpp

function-decl: Node::Node Node
param-decl: int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->key = k
   2: this->value = v
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: DoubleLinkedList::DoubleLinkedList DoubleLinkedList
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->size = 0
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: DoubleLinkedList::~DoubleLinkedList ~DoubleLinkedList
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: DoubleLinkedList::Size Size
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return this->size;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: DoubleLinkedList::NewAtBegin NewAtBegin
param-decl: int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: key, value (CXXConstructExpr, class Node)
   2: new class Node([B1.1])
   3: class Node *n = new class Node(key, value);
   4: this->AddAtBegin(n)
   5: return [B1.4];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: DoubleLinkedList::NewAtEnd NewAtEnd
param-decl: int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: key, value (CXXConstructExpr, class Node)
   2: new class Node([B1.1])
   3: class Node *n = new class Node(key, value);
   4: this->AddAtEnd(n)
   5: return [B1.4];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: DoubleLinkedList::AddAtBegin AddAtBegin
param-decl: class Node *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: n->next = this->pHead
   2: this->pHead->prev = n
   3: this->pHead = n
   4: return n;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: this->pHead = this->pTail = n
   2: return n;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: this->size++
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: DoubleLinkedList::AddAtEnd AddAtEnd
param-decl: class Node *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: this->pTail->next = n
   2: n->prev = this->pTail
   3: this->pTail = n
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: this->pHead = this->pTail = n
   2: return n;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: this->size++
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: DoubleLinkedList::Unlink Unlink
param-decl: class Node *; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: this->size--
   Preds (3): B2 B3 B4
   Succs (1): B0

 [B2]
   1: this->pTail = this->pTail->prev
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: this->pTail == n
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: this->pHead = this->pHead->next
   Preds (1): B5
   Succs (1): B1

 [B5]
   1: this->pHead == n
   T: if [B5.1]
   Preds (2): B6 B7
   Succs (2): B4 B3

 [B6]
   1: after->prev = before
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: after (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B7.1]
   Preds (2): B8 B9
   Succs (2): B6 B5

 [B8]
   1: before->next = after
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: class Node *before = n->prev;
   2: class Node *after = n->next;
   3: before (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B9.3]
   Preds (1): B10
   Succs (2): B8 B7

 [B0 (EXIT)]
   Preds (1): B1

function-decl: DoubleLinkedList::Delete Delete
param-decl: class Node *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->Unlink(n)
   2: delete n
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: DoubleLinkedList::TakeToBegin TakeToBegin
param-decl: class Node *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->Unlink(n)
   2: this->AddAtBegin(n)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: DoubleLinkedList::GetTailNode GetTailNode
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return this->pTail;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: DoubleLinkedList::DeleteLast DeleteLast
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->Delete(this->pTail)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: DoubleLinkedList::Print Print
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: class Node *p = this->pHead;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: LRUCache::LRUCache LRUCache
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->capacity = capacity
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: LRUCache::print print
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->cacheList.Print()
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: LRUCache::get get
param-decl: int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return -1;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: LRUCache::set set
param-decl: int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: this->cacheList.GetTailNode()
   2: int key = this->cacheList.GetTailNode()->key;
   3: this->cacheList.DeleteLast()
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: this->cacheList.Size()
   2: [B2.1] > this->capacity
   T: if [B2.2]
   Preds (1): B4
   Succs (2): B1 B0

 [B3]
   1: class Node *p;
   2: p->value = value
   Preds (1): B4
   Succs (1): B0

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B0 (EXIT)]
   Preds (3): B1 B2 B3

function-decl: main main
param-decl: int; char **; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: v = i
   2: cache.set(v, v)
   3: cache.print()
   4: cache.print()
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < test_loop_times
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: capacity (CXXConstructExpr, class LRUCache)
   2: class LRUCache cache(capacity);
   3: int v;
   4: int i = 0;
   Preds (2): B6 B7
   Succs (1): B4

 [B6]
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: argc > 2
   T: if [B7.1]
   Preds (2): B8 B9
   Succs (2): B6 B5

 [B8]
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: int capacity = 5;
   2: int test_loop_times = 10;
   3: argc > 1
   T: if [B9.3]
   Preds (1): B10
   Succs (2): B8 B7

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/addBinary/addBinary.cpp

function-decl: addBinary addBinary
param-decl: int; int; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: carry (ImplicitCastExpr, LValueToRValue, _Bool)
   T: if [B2.1]
   Preds (1): B8
   Succs (2): B1 B0

 [B3]
   Preds (1): B4
   Succs (1): B9

 [B4]
   1: [B7.3] ? [B5.1] : [B6.1]
   2: int cbit = carry ? 1 : 0;
   3: carry = (abit + bbit + cbit > 1)
   4: alen--
   5: blen--
   Preds (2): B5 B6
   Succs (1): B3

 [B5]
   1: 1
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: 0
   Preds (1): B7
   Succs (1): B4

 [B7]
   1: int abit;
   2: int bbit;
   3: carry (ImplicitCastExpr, LValueToRValue, _Bool)
   T: [B7.3] ? ... : ...
   Preds (2): B8 B9
   Succs (2): B5 B6

 [B8]
   1: blen > 0
   T: while [B9.1] || [B8.1]
   Preds (1): B9
   Succs (2): B7 B2

 [B9]
   1: alen > 0
   T: [B9.1] || ...
   Preds (2): B3 B10
   Succs (2): B7 B8

 [B10]
   1: int alen;
   2: int blen;
   3: _Bool carry = false;
   4: int result;
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: int; char **; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int a;
   2: int b;
   3: argc > 2
   T: if [B2.3]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/cloneGraph/cloneGraph.cpp

function-decl: Solution::cloneGraph cloneGraph
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int *cloneNode;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/friendCircles/FriendCircles.cpp

function-decl: Solution::findCircleNum_DFS findCircleNum_DFS
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int n = 0;
   2: return n;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::mark mark
param-decl: int &; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::findCircleNum_UF findCircleNum_UF
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int n;
   2: return n;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::find find
param-decl: int &; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return i;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::join join
param-decl: int &; int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int tx;
   2: int ty;
   3: return tx != ty;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::findCircleNum findCircleNum
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/oneEditDistance/oneEditDistance.cpp

function-decl: isOneEditDistance isOneEditDistance
param-decl: int; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return len_s == 1;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: len_t == 0
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return len_t == 1;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: int len_s;
   2: int len_t;
   3: len_s == 0
   T: if [B5.3]
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (3): B1 B2 B4

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int s;
   2: argc > 2
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/powerOfTwo/PowerOfTwo.cpp

function-decl: Solution::isPowerOfTwo01 isPowerOfTwo01
param-decl: int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return cnt == 1;
   Preds (1): B6
   Succs (1): B0

 [B2]
   1: n >>= 1
   Preds (2): B4 B5
   Succs (1): B6

 [B3]
   1: return false;
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: cnt++
   2: cnt > 1
   T: if [B4.2]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: n & 1 (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B2

 [B6]
   1: n > 0
   T: for (; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: int cnt = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (2): B1 B3

function-decl: Solution::isPowerOfTwo02 isPowerOfTwo02
param-decl: int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: [B4.1] ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: false
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: (n & (n - 1)) == 0
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: n <= 0
   T: [B4.1] ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::isPowerOfTwo isPowerOfTwo
param-decl: int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: this->isPowerOfTwo01(n)
   2: return [B1.1];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: this->isPowerOfTwo02(n)
   2: return [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/dungeonGame/dungeonGame.cpp

function-decl: Solution::calculateMinimumHP calculateMinimumHP
param-decl: int &; 

 [B15 (ENTRY)]
   Succs (1): B14

 [B1]
   1: return dp[0][0];
   Preds (1): B10
   Succs (1): B0

 [B2]
   1: r--
   Preds (1): B8
   Succs (1): B10

 [B3]
   1: c--
   Preds (2): B4 B5
   Succs (1): B8

 [B4]
   1: int h1;
   2: int h2;
   Preds (2): B6 B7
   Succs (1): B3

 [B5]
   Preds (1): B6
   Succs (1): B3

 [B6]
   1: c == col - 1
   T: if [B7.1] && [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: r == row - 1
   T: [B7.1] && ...
   Preds (1): B8
   Succs (2): B6 B4

 [B8]
   1: c >= 0
   T: for (...; [B8.1]; ...)
   Preds (2): B3 B9
   Succs (2): B7 B2

 [B9]
   1: int c = col - 1;
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: r >= 0
   T: for (...; [B10.1]; ...)
   Preds (2): B2 B11
   Succs (2): B9 B1

 [B11]
   1: col (ImplicitCastExpr, LValueToRValue, int)
   2: row (ImplicitCastExpr, LValueToRValue, int)
   3: int dp[row][col];
   4: int r = row - 1;
   Preds (1): B13
   Succs (1): B10

 [B12]
   1: return 0;
   Preds (2): B13 B14
   Succs (1): B0

 [B13]
   1: col <= 0
   T: if [B14.3] || [B13.1]
   Preds (1): B14
   Succs (2): B12 B11

 [B14]
   1: int row;
   2: int col;
   3: row <= 0
   T: [B14.3] || ...
   Preds (1): B15
   Succs (2): B12 B13

 [B0 (EXIT)]
   Preds (2): B1 B12


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/detectCapital/DetectCapital.cpp

function-decl: Solution::is_lower is_lower
param-decl: char; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: [B3.1] && [B2.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: ch <= 'z'
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: ch >= 'a'
   T: [B3.1] && ...
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::is_upper is_upper
param-decl: char; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: [B3.1] && [B2.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: ch <= 'Z'
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: ch >= 'A'
   T: [B3.1] && ...
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::is_alpha is_alpha
param-decl: char; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: [B3.1] || [B2.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: this->is_upper(ch)
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: this->is_lower(ch)
   T: [B3.1] || ...
   Preds (1): B4
   Succs (2): B1 B2

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::detectCapitalUse detectCapitalUse
param-decl: int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: [B4.4] || [B3.1] && [B2.1]
   2: return [B1.1];
   Preds (3): B2 B3 B4
   Succs (1): B0

 [B2]
   1: all_upper (ImplicitCastExpr, LValueToRValue, _Bool)
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: first (ImplicitCastExpr, LValueToRValue, _Bool)
   T: [B3.1] && ...
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: _Bool all_upper = true;
   2: _Bool all_lower = true;
   3: _Bool first;
   4: all_lower (ImplicitCastExpr, LValueToRValue, _Bool)
   T: [B4.4] || ...
   Preds (1): B5
   Succs (2): B1 B3

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/kthSmallestElementInaBST/KthSmallestElementInABst.cpp

function-decl: Solution::kthSmallestHelper_recursive kthSmallestHelper_recursive
param-decl: int *; int &; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: k--
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return result;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: int result;
   2: k == 0
   T: if [B3.2]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return 0;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (3): B1 B2 B4

function-decl: Solution::kthSmallestHelper_nonRecursive kthSmallestHelper_nonRecursive
param-decl: int *; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return -1;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::kthSmallest kthSmallest
param-decl: int *; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/binaryTreePostorderTraversal/binaryTreePostorderTraversal.cpp

function-decl: TreeNode::TreeNode TreeNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: postorderTraversal postorderTraversal
param-decl: struct TreeNode *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: postorderTraversal1 postorderTraversal1
param-decl: struct TreeNode *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int v;
   2: int stack;
   3: root (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B2.3]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: postorderTraversal2 postorderTraversal2
param-decl: struct TreeNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int v;
   2: int stack;
   3: struct TreeNode *node = root;
   4: struct TreeNode *lastVisitNode;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: createTree createTree
param-decl: int *; int; 

 [B15 (ENTRY)]
   Succs (1): B14

 [B1]
   1: return tree[0];
   Preds (2): B6 B7
   Succs (1): B0

 [B2]
   1: i++
   Preds (3): B3 B4 B5
   Succs (1): B7

 [B3]
   1: tree[i]->right = tree[pos++]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: tree[i]->left = tree[pos++]
   2: pos < n
   T: if [B4.2]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: tree[i] (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B2

 [B6]
   1: pos < n
   T: for (...; [B7.1] && [B6.1]; ...)
   Preds (1): B7
   Succs (2): B5 B1

 [B7]
   1: i < n
   T: [B7.1] && ...
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B8]
   1: int pos = 1;
   2: int i = 0;
   Preds (1): B13
   Succs (1): B7

 [B9]
   1: i++
   Preds (2): B10 B11
   Succs (1): B13

 [B10]
   1: a[i] (CXXConstructExpr, struct TreeNode)
   2: new struct TreeNode([B10.1])
   3: tree[i] = [B10.2]
   Preds (1): B12
   Succs (1): B9

 [B11]
   T: continue;
   Preds (1): B12
   Succs (1): B9

 [B12]
   1: a[i] == 0
   T: if [B12.1]
   Preds (1): B13
   Succs (2): B11 B10

 [B13]
   1: i < n
   T: for (...; [B13.1]; ...)
   Preds (2): B9 B14
   Succs (2): B12 B8

 [B14]
   1: new struct TreeNode *[n]
   2: struct TreeNode **tree = new struct TreeNode *[n];
   3: int i = 0;
   Preds (1): B15
   Succs (1): B13

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printTree_post_order printTree_post_order
param-decl: struct TreeNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: printTree_post_order(root->left)
   2: printTree_post_order(root->right)
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: printArray printArray
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {1, 2, 3, 4, 5, 0, 6, 0, 0, 7, 8, 9, 0};
   2: createTree(a, sizeof (a) / sizeof(int))
   3: struct TreeNode *p = createTree(a, sizeof (a) / sizeof(int));
   4: printTree_post_order(p)
   5: int v;
   6: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/addTwoNumbers/addTwoNumbers.cpp

function-decl: Solution::addTwoNumbers addTwoNumbers
param-decl: int *; int *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: int *node;
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int x = 0;
   2: int y = 0;
   3: int carry = 0;
   4: int sum = 0;
   5: int *h;
   6: carry > 0
   T: if [B2.6]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::getValueAndMoveNext getValueAndMoveNext
param-decl: int *&; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return x;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int x = 0;
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/uglyNumber/UglyNumber.II.cpp

function-decl: Solution::min min
param-decl: int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: [B4.1] ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: a
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: b
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: a < b
   T: [B4.1] ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::min min
param-decl: int; int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->min(a, b)
   2: this->min([B1.1], c)
   3: return [B1.2];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::nthUglyNumber01 nthUglyNumber01
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int i = 0;
   2: int j = 0;
   3: int k = 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::nthUglyNumber02 nthUglyNumber02
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: static int i = 0;
   2: static int j = 0;
   3: static int k = 0;
   4: static int v;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::nthUglyNumber nthUglyNumber
param-decl: int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: this->nthUglyNumber01(n)
   2: return [B1.1];
   Succs (1): B0

 [B2]
   1: this->nthUglyNumber02(n)
   2: return [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/uglyNumber/UglyNumber.cpp

function-decl: Solution::isUgly isUgly
param-decl: int; 

 [B15 (ENTRY)]
   Succs (1): B14

 [B1]
   1: return num == 1;
   Preds (1): B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: num /= 5
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: num % 5 == 0
   T: while [B4.1]
   Preds (2): B2 B7
   Succs (2): B3 B1

 [B5]
   Preds (1): B6
   Succs (1): B7

 [B6]
   1: num /= 3
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: num % 3 == 0
   T: while [B7.1]
   Preds (2): B5 B10
   Succs (2): B6 B4

 [B8]
   Preds (1): B9
   Succs (1): B10

 [B9]
   1: num /= 2
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: num % 2 == 0
   T: while [B10.1]
   Preds (2): B8 B12
   Succs (2): B9 B7

 [B11]
   1: return true;
   Preds (1): B12
   Succs (1): B0

 [B12]
   1: num == 1
   T: if [B12.1]
   Preds (1): B14
   Succs (2): B11 B10

 [B13]
   1: return false;
   Preds (1): B14
   Succs (1): B0

 [B14]
   1: num == 0
   T: if [B14.1]
   Preds (1): B15
   Succs (2): B13 B12

 [B0 (EXIT)]
   Preds (3): B1 B11 B13


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/additiveNumber/AdditiveNumber.cpp

function-decl: Solution::isAdditiveNumber isAdditiveNumber
param-decl: int; 

 [B14 (ENTRY)]
   Succs (1): B13

 [B1]
   1: return false;
   Preds (2): B10 B12
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B6 B8
   Succs (1): B12

 [B3]
   1: j++
   Preds (1): B5
   Succs (1): B8

 [B4]
   1: return true;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: int n3;
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   T: break;
   Preds (1): B7
   Succs (1): B2

 [B7]
   1: int n2;
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: j < len
   T: for (...; [B8.1]; ...)
   Preds (2): B3 B9
   Succs (2): B7 B2

 [B9]
   1: int j = i + 1;
   Preds (1): B11
   Succs (1): B8

 [B10]
   T: break;
   Preds (1): B11
   Succs (1): B1

 [B11]
   1: int n1;
   T: if <null expr>
   Preds (1): B12
   Succs (2): B10 B9

 [B12]
   1: i < len / 2 + 1
   T: for (...; [B12.1]; ...)
   Preds (2): B2 B13
   Succs (2): B11 B1

 [B13]
   1: int len;
   2: int i = 1;
   Preds (1): B14
   Succs (1): B12

 [B0 (EXIT)]
   Preds (2): B1 B4

function-decl: Solution::isAdditiveNumberHelper isAdditiveNumberHelper
param-decl: int &; int &; int &; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return false;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: int rest;
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int cut;
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return true;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return false;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: int add;
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (3): B1 B4 B6

function-decl: Solution::StringAdd StringAdd
param-decl: int; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: i--
   2: j--
   3: ... , [B1.2]
   Preds (1): B2
   Succs (1): B5

 [B2]
   1: char ch = n % 10 + '0';
   2: carry = n / 10
   Preds (2): B3 B4
   Succs (1): B1

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: int n;
   2: j >= 0
   T: if [B4.2]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i >= 0
   T: for (...; [B5.1]; ...)
   Preds (2): B1 B6
   Succs (2): B4 B0

 [B6]
   1: int carry = 0;
   2: int result;
   3: int i;
   4: int j;
   Preds (2): B7 B8
   Succs (1): B5

 [B7]
   1: int tmp;
   Preds (1): B8
   Succs (1): B6

 [B8]
   T: if <null expr>
   Preds (1): B9
   Succs (2): B7 B6

 [B0 (EXIT)]
   Preds (1): B5


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/spiralMatrix/spiralMatrix.II.cpp

function-decl: generateMatrix generateMatrix
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: generateMatrix generateMatrix
param-decl: int; int; 

 [B22 (ENTRY)]
   Succs (1): B21

 [B1]
   1: r++
   2: c++
   3: ... , [B1.2]
   Preds (2): B3 B4
   Succs (1): B17

 [B2]
   1: i--
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: i > r
   T: for (...; [B4.1] && [B3.1]; ...)
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: col - c - 1 > c
   T: [B4.1] && ...
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int i = row - r - 2;
   Preds (2): B7 B8
   Succs (1): B4

 [B6]
   1: i--
   Preds (1): B7
   Succs (1): B8

 [B7]
   1: i >= c
   T: for (...; [B8.1] && [B7.1]; ...)
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: row - r - 1 > r
   T: [B8.1] && ...
   Preds (2): B6 B9
   Succs (2): B7 B5

 [B9]
   1: int i = col - c - 2;
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: i++
   Preds (1): B11
   Succs (1): B11

 [B11]
   1: i < row - r
   T: for (...; [B11.1]; ...)
   Preds (2): B10 B12
   Succs (2): B10 B9

 [B12]
   1: int i = r + 1;
   Preds (1): B14
   Succs (1): B11

 [B13]
   1: i++
   Preds (1): B14
   Succs (1): B14

 [B14]
   1: i < col - c
   T: for (...; [B14.1]; ...)
   Preds (2): B13 B15
   Succs (2): B13 B12

 [B15]
   1: int i = c;
   Preds (1): B16
   Succs (1): B14

 [B16]
   1: c < (col + 1) / 2
   T: for (...; [B17.1] && [B16.1]; ...)
   Preds (1): B17
   Succs (2): B15 B0

 [B17]
   1: r < (row + 1) / 2
   T: [B17.1] && ...
   Preds (2): B1 B18
   Succs (2): B16 B0

 [B18]
   1: int row = n;
   2: int col = m;
   3: int r;
   4: int c;
   5: int cnt = 1;
   6: r = 0
   7: c = 0
   8: ... , [B18.7]
   Preds (1): B20
   Succs (1): B17

 [B19]
   1: i++
   Preds (1): B20
   Succs (1): B20

 [B20]
   1: i < n
   T: for (...; [B20.1]; ...)
   Preds (2): B19 B21
   Succs (2): B19 B18

 [B21]
   1: int i = 0;
   Preds (1): B22
   Succs (1): B20

 [B0 (EXIT)]
   Preds (2): B16 B17

function-decl: printArray printArray
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printMatrix printMatrix
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: argc > 2
   T: if [B3.1]
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: int n = 3;
   2: int m = 3;
   3: argc > 1
   T: if [B5.3]
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/spiralMatrix/spiralMatrix.cpp

function-decl: spiralOrder spiralOrder
param-decl: int &; 

 [B19 (ENTRY)]
   Succs (1): B18

 [B1]
   1: r++
   2: c++
   3: ... , [B1.2]
   Preds (2): B3 B4
   Succs (1): B17

 [B2]
   1: i--
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: i > r
   T: for (...; [B4.1] && [B3.1]; ...)
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: col - c - 1 > c
   T: [B4.1] && ...
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int i = row - r - 2;
   Preds (2): B7 B8
   Succs (1): B4

 [B6]
   1: i--
   Preds (1): B7
   Succs (1): B8

 [B7]
   1: i >= c
   T: for (...; [B8.1] && [B7.1]; ...)
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: row - r - 1 > r
   T: [B8.1] && ...
   Preds (2): B6 B9
   Succs (2): B7 B5

 [B9]
   1: int i = col - c - 2;
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: i++
   Preds (1): B11
   Succs (1): B11

 [B11]
   1: i < row - r
   T: for (...; [B11.1]; ...)
   Preds (2): B10 B12
   Succs (2): B10 B9

 [B12]
   1: int i = r + 1;
   Preds (1): B14
   Succs (1): B11

 [B13]
   1: i++
   Preds (1): B14
   Succs (1): B14

 [B14]
   1: i < col - c
   T: for (...; [B14.1]; ...)
   Preds (2): B13 B15
   Succs (2): B13 B12

 [B15]
   1: int i = c;
   Preds (1): B16
   Succs (1): B14

 [B16]
   1: c < (col + 1) / 2
   T: for (...; [B17.1] && [B16.1]; ...)
   Preds (1): B17
   Succs (2): B15 B0

 [B17]
   1: r < (row + 1) / 2
   T: [B17.1] && ...
   Preds (2): B1 B18
   Succs (2): B16 B0

 [B18]
   1: int v;
   2: int row;
   3: int col;
   4: int r;
   5: int c;
   6: r = 0
   7: c = 0
   8: ... , [B18.7]
   Preds (1): B19
   Succs (1): B17

 [B0 (EXIT)]
   Preds (2): B16 B17

function-decl: printArray printArray
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printMatrix printMatrix
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: createMatrix createMatrix
param-decl: int; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: i++
   Preds (1): B3
   Succs (1): B5

 [B2]
   1: j++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: j < m
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int v;
   2: int j = 0;
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: i < n
   T: for (...; [B5.1]; ...)
   Preds (2): B1 B6
   Succs (2): B4 B0

 [B6]
   1: int cnt = 1;
   2: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B5

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int v;
   2: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int n = 3;
   2: int m = 3;
   3: argc > 2
   T: if [B3.3]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/removeNthNodeFromEndOfList/removeNthNodeFromEndOfList.cpp

function-decl: Solution::removeNthFromEnd removeNthFromEnd
param-decl: int *; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int fakeHead;
   2: int *p1;
   3: int i = 0;
   Preds (2): B4 B5
   Succs (1): B2

 [B4]
   Preds (1): B5
   Succs (1): B3

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (1): B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/romanToInteger/romanToInteger.cpp

function-decl: romanCharToInt romanCharToInt
param-decl: char; 

 [B10 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return d;
   Preds (8): B3 B4 B5 B6 B7 B8 B9 B2
   Succs (1): B0

 [B2]
   1: int d = 0;
   2: ch (ImplicitCastExpr, IntegralCast, int)
   T: switch [B2.2]
   Preds (1): B10
   Succs (8): B3 B4 B5 B6 B7 B8 B9 B1

 [B3]
  case 'M':
   1: d = 1000
   T: break;
   Preds (1): B2
   Succs (1): B1

 [B4]
  case 'D':
   1: d = 500
   T: break;
   Preds (1): B2
   Succs (1): B1

 [B5]
  case 'C':
   1: d = 100
   T: break;
   Preds (1): B2
   Succs (1): B1

 [B6]
  case 'L':
   1: d = 50
   T: break;
   Preds (1): B2
   Succs (1): B1

 [B7]
  case 'X':
   1: d = 10
   T: break;
   Preds (1): B2
   Succs (1): B1

 [B8]
  case 'V':
   1: d = 5
   T: break;
   Preds (1): B2
   Succs (1): B1

 [B9]
  case 'I':
   1: d = 1
   T: break;
   Preds (1): B2
   Succs (1): B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: romanToInt romanToInt
param-decl: int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int result;
   2: return result;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int s;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/wildcardMatching/wildcardMatching.cpp

function-decl: isMatch isMatch
param-decl: const char *; const char *; 

 [B18 (ENTRY)]
   Succs (1): B17

 [B1]
   1: return *p == '\x00';
   Preds (1): B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: p++
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: *p == '*'
   T: while [B4.1]
   Preds (2): B2 B16
   Succs (2): B3 B1

 [B5]
   Preds (3): B7 B9 B12
   Succs (1): B16

 [B6]
   1: return false;
   Preds (1): B8
   Succs (1): B0

 [B7]
   1: p = last_p
   2: s = ++last_s
   Preds (1): B8
   Succs (1): B5

 [B8]
   T: if <null expr>
   Preds (1): B10
   Succs (2): B7 B6

 [B9]
   1: s++
   2: p++
   Preds (2): B10 B11
   Succs (1): B5

 [B10]
   1: *s == *p
   T: if [B11.1] || [B10.1]
   Preds (1): B11
   Succs (2): B9 B8

 [B11]
   1: *p == '?'
   T: [B11.1] || ...
   Preds (1): B15
   Succs (2): B9 B10

 [B12]
   1: last_s = s
   2: last_p = p
   Preds (1): B14
   Succs (1): B5

 [B13]
   1: return true;
   Preds (1): B14
   Succs (1): B0

 [B14]
   1: p++
   2: *p == '\x00'
   T: if [B14.2]
   Preds (1): B15
   Succs (2): B13 B12

 [B15]
   1: *p == '*'
   T: if [B15.1]
   Preds (1): B16
   Succs (2): B14 B11

 [B16]
   1: *s != '\x00'
   T: while [B16.1]
   Preds (2): B5 B17
   Succs (2): B15 B4

 [B17]
   1: const char *last_s;
   2: const char *last_p;
   Preds (1): B18
   Succs (1): B16

 [B0 (EXIT)]
   Preds (3): B1 B6 B13

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: s = argv[1]
   2: p = argv[2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: const char *s = "aab";
   2: const char *p = "a*a*b";
   3: s = "abbb"
   4: p = "a*b"
   5: s = "abb"
   6: p = "a*bb"
   7: s = "abddbbb"
   8: p = "a*d*b"
   9: s = "abdb"
  10: p = "a**"
  11: s = "a"
  12: p = "a**"
  13: s = "*aa"
  14: p = "*a"
  15: argc > 2
   T: if [B3.15]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/sentenceScreenFitting/sentenceScreenFitting.h


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/sentenceScreenFitting/main.cpp

function-decl: main main
param-decl: int; const char **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int rows;
   2: int cols;
   3: int ret;
   4: int word;
   5: int line;
   6: int numbers;
   7:  (CXXConstructExpr, class Solution)
   8: class Solution solution;
   9: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/sentenceScreenFitting/sentenceScreenFitting.cpp

function-decl: SentenceScreenFitting SentenceScreenFitting
param-decl: char (*)[10]; int; int; int; 

 [B17 (ENTRY)]
   Succs (1): B16

 [B1]
   1: return ret;
   Preds (1): B15
   Succs (1): B0

 [B2]
   1: (i) += 1
   Preds (1): B4
   Succs (1): B15

 [B3]
   1: (s) += 1
   Preds (1): B4
   Succs (1): B4

 [B4]
   1: (s) < (k - t - 1)
   T: for (...; [B4.1]; ...)
   Preds (2): B3 B5
   Succs (2): B3 B2

 [B5]
   1: (s) = 0
   Preds (1): B13
   Succs (1): B4

 [B6]
   Preds (2): B7 B8
   Succs (1): B13

 [B7]
   1: k++
   Preds (1): B12
   Succs (1): B6

 [B8]
   1: k = 0
   2: t = 0
   3: ret++
   Preds (1): B10
   Succs (1): B6

 [B9]
   1: (s) += 1
   Preds (1): B10
   Succs (1): B10

 [B10]
   1: (s) < (k - t)
   T: for (...; [B10.1]; ...)
   Preds (2): B9 B11
   Succs (2): B9 B8

 [B11]
   1: (s) = 0
   Preds (1): B12
   Succs (1): B10

 [B12]
   1: j -= len[k] + 1
   T: if <null expr>
   Preds (1): B13
   Succs (2): B11 B7

 [B13]
   1: j - len[k] >= 0
   T: while [B13.1]
   Preds (2): B6 B14
   Succs (2): B12 B5

 [B14]
   1: j = col
   2: t = k
   Preds (1): B15
   Succs (1): B13

 [B15]
   1: (i) < (row)
   T: for (...; [B15.1]; ...)
   Preds (2): B2 B16
   Succs (2): B14 B1

 [B16]
   1: int i;
   2: int j;
   3: int t;
   4: int s;
   5: int k = 0;
   6: int ret = 0;
   7: int len[100] = {0};
   8: (i) = 0
   Preds (1): B17
   Succs (1): B15

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::wordsTyping wordsTyping
param-decl: int &; int; int; 

 [B16 (ENTRY)]
   Succs (1): B15

 [B1]
   1: return ret;
   Preds (1): B10
   Succs (1): B0

 [B2]
   1: (i) += 1
   Preds (1): B7
   Succs (1): B10

 [B3]
   Preds (2): B4 B5
   Succs (1): B7

 [B4]
   1: k++
   Preds (1): B6
   Succs (1): B3

 [B5]
   1: k = 0
   2: ret += j / jump + 1
   3: j = j % jump
   Preds (1): B6
   Succs (1): B3

 [B6]
   1: j -= len[k] + 1
   2: k + 1 > l - 1
   T: if [B6.2]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: j - len[k] >= 0
   T: while [B7.1]
   Preds (3): B3 B8 B9
   Succs (2): B6 B2

 [B8]
   1: ret += j / jump
   2: j = j % jump
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: j = cols
   2: k == 0
   T: if [B9.2]
   Preds (1): B10
   Succs (2): B8 B7

 [B10]
   1: (i) < (rows)
   T: for (...; [B10.1]; ...)
   Preds (2): B2 B11
   Succs (2): B9 B1

 [B11]
   1: jump += l
   2: (i) = 0
   Preds (1): B14
   Succs (1): B10

 [B12]
   1: (i) += 1
   Preds (1): B13
   Succs (1): B14

 [B13]
   1: jump += len[i]
   Preds (1): B14
   Succs (1): B12

 [B14]
   1: (i) < (l)
   T: for (...; [B14.1]; ...)
   Preds (2): B12 B15
   Succs (2): B13 B11

 [B15]
   1: int i;
   2: int j;
   3: int k = 0;
   4: int ret = 0;
   5: int l;
   6: int jump = 0;
   7: int len[100] = {0};
   8: (i) = 0
   Preds (1): B16
   Succs (1): B14

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/queueReconstructionByHeight/QueueReconstructionByHeight.cpp

function-decl: Solution::reconstructQueue reconstructQueue
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: [](const int &p1, const int &p2) {
} (CXXConstructExpr, class (lambda at /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/queueReconstructionByHeight/QueueReconstructionByHeight.cpp:29:21))
   2: auto comp = [](const int &p1, const int &p2) {
};
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/compareVersionNumbers/compareVersionNumbers.cpp

function-decl: Solution::split split
param-decl: const int &; char; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int ss;
   2: int item;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::split split
param-decl: const int &; char; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int elems;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::rightTrimZero rightTrimZero
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::compareVersion compareVersion
param-decl: int; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return -1;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return 1;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: int ver1;
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (3): B1 B2 B4


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/wiggleSubsequence/wiggleSubsequence.cpp

function-decl: Solution::wiggleMaxLength wiggleMaxLength
param-decl: int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return solution;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: solution = 1
   2: int bigger = 0;
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int solution = 0;
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/rangeSumQuery2D-Immutable/RangeSumQuery2dImmutable.cpp

function-decl: NumMatrix::NumMatrix NumMatrix
param-decl: int &; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: i++
   Preds (1): B3
   Succs (1): B5

 [B2]
   1: j++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: j <= this->col
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int j = 1;
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: i <= this->row
   T: for (...; [B5.1]; ...)
   Preds (2): B1 B6
   Succs (2): B4 B0

 [B6]
   1: int i = 1;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B5

function-decl: NumMatrix::sumRegion sumRegion
param-decl: int; int; int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/countPrimes/CountPrimes.cpp

function-decl: countPrimes countPrimes
param-decl: int; 

 [B14 (ENTRY)]
   Succs (1): B13

 [B1]
   1: return cnt;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   1: cnt++
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < n
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int cnt = 0;
   2: int i = 2;
   Preds (1): B12
   Succs (1): B5

 [B7]
   1: i++
   Preds (2): B9 B11
   Succs (1): B12

 [B8]
   1: j += i
   Preds (1): B9
   Succs (1): B9

 [B9]
   1: j < n
   T: for (...; [B9.1]; ...)
   Preds (2): B8 B10
   Succs (2): B8 B7

 [B10]
   1: int j = i * i;
   Preds (1): B11
   Succs (1): B9

 [B11]
   T: if <null expr>
   Preds (1): B12
   Succs (2): B10 B7

 [B12]
   1: i * i < n
   T: for (...; [B12.1]; ...)
   Preds (2): B7 B13
   Succs (2): B11 B6

 [B13]
   1: int i = 2;
   Preds (1): B14
   Succs (1): B12

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int n = 100;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/createMaximumNumber/CreateMaximumNumber.cpp

function-decl: Solution::maxNumber maxNumber
param-decl: int &; int &; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: i++
   Preds (3): B2 B3 B4
   Succs (1): B7

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int sub1;
   2: int merge;
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   T: continue;
   Preds (2): B5 B6
   Succs (1): B1

 [B5]
   1: len2 < k - i
   T: if [B6.1] || [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: len1 < i
   T: [B6.1] || ...
   Preds (1): B7
   Succs (2): B4 B5

 [B7]
   1: i <= k
   T: for (...; [B7.1]; ...)
   Preds (2): B1 B8
   Succs (2): B6 B0

 [B8]
   1: int result;
   2: int len1;
   3: int len2;
   4: int i = 0;
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (1): B7

function-decl: Solution::compareTwoArray compareTwoArray
param-decl: int &; int; int &; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: start1++
   2: start2++
   3: ... , [B1.2]
   Preds (1): B3
   Succs (1): B7

 [B2]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return true;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: start2 < n2
   T: for (; [B7.1] && [B6.1]; ...)
   Preds (1): B7
   Succs (2): B5 B0

 [B7]
   1: start1 < n1
   T: [B7.1] && ...
   Preds (2): B1 B8
   Succs (2): B6 B0

 [B8]
   1: int n1;
   2: int n2;
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (4): B2 B4 B6 B7

function-decl: Solution::mergeTwoArrays mergeTwoArrays
param-decl: int &; int &; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: pos2 < len2
   T: if [B2.1]
   Preds (2): B3 B4
   Succs (2): B1 B0

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: pos1 < len1
   T: if [B4.1]
   Preds (2): B8 B9
   Succs (2): B3 B2

 [B5]
   Preds (2): B6 B7
   Succs (1): B9

 [B6]
   Preds (1): B7
   Succs (1): B5

 [B7]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: pos2 < len2
   T: while [B9.1] && [B8.1]
   Preds (1): B9
   Succs (2): B7 B4

 [B9]
   1: pos1 < len1
   T: [B9.1] && ...
   Preds (2): B5 B10
   Succs (2): B8 B4

 [B10]
   1: int result;
   2: int len1;
   3: int len2;
   4: int pos1 = 0;
   5: int pos2 = 0;
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::findMaxSubArray findMaxSubArray
param-decl: int &; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: i++
   Preds (2): B2 B3
   Succs (1): B4

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: idx < k
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: i < len
   T: for (...; [B4.1]; ...)
   Preds (2): B1 B5
   Succs (2): B3 B0

 [B5]
   1: int len;
   2: int idx = 0;
   3: int i = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B4


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/wordPattern/WordPattern.cpp

function-decl: Solution::split split
param-decl: int; char; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int ss;
   2: int tok;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::wordPattern wordPattern
param-decl: int; int; 

 [B13 (ENTRY)]
   Succs (1): B12

 [B1]
   1: return true;
   Preds (1): B9
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B4
   Succs (1): B9

 [B3]
   1: return false;
   Preds (1): B4
   Succs (1): B0

 [B4]
   T: if <null expr>
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   Preds (1): B6
   Succs (1): B4

 [B6]
   T: if <null expr>
   Preds (2): B7 B8
   Succs (2): B5 B4

 [B7]
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: char &ch;
   2: int &s;
   T: if <null expr>
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: i < len
   T: for (...; [B9.1]; ...)
   Preds (2): B2 B10
   Succs (2): B8 B1

 [B10]
   1: int i = 0;
   Preds (1): B12
   Succs (1): B9

 [B11]
   1: return false;
   Preds (1): B12
   Succs (1): B0

 [B12]
   1: int len;
   T: if <null expr>
   Preds (1): B13
   Succs (2): B11 B10

 [B0 (EXIT)]
   Preds (3): B1 B3 B11


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/longestValidParentheses/longestValidParentheses.cpp

function-decl: longestValidParentheses longestValidParentheses
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int maxLen = 0;
   2: int lastError = -1;
   3: int stack;
   4: return maxLen;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int s;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/linkedListRandomNode/LinkedListRandomNode.cpp

function-decl: Solution::Solution Solution
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->len = 0
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::getRandom getRandom
param-decl: 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: pos > 0
   T: for (; [B2.1]; )
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int pos;
   2: int *p;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/symmetricTree/symmetricTree.cpp

function-decl: Solution::Solution Solution
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::isSymmetric isSymmetric
param-decl: int *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return true;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::isSymmetric isSymmetric
param-decl: int *; int *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::isSymmetric1 isSymmetric1
param-decl: int *; int *; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return false;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B1 B0

 [B3]
   1: return true;
   Preds (1): B4
   Succs (1): B0

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B0 (EXIT)]
   Preds (3): B1 B2 B3

function-decl: Solution::isSymmetric2 isSymmetric2
param-decl: int *; int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return true;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/binaryTreeZigzagLevelOrderTraversal/binaryTreeZigzagLevelOrderTraversal.cpp

function-decl: TreeNode::TreeNode TreeNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: zigzagLevelOrder zigzagLevelOrder
param-decl: struct TreeNode *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: zigzagLevelOrder1 zigzagLevelOrder1
param-decl: struct TreeNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int tree;
   2: int curLevelCnt = 1;
   3: int nextLevelCnt = 1;
   4: int level = 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: TreeToArray_level_order TreeToArray_level_order
param-decl: struct TreeNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int result;
   2: int q;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: zigzagLevelOrder2 zigzagLevelOrder2
param-decl: struct TreeNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int level = 0;
   2: struct TreeNode *last = root;
   3: int q;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printTree_level_order printTree_level_order
param-decl: struct TreeNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int q;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: createTree createTree
param-decl: int *; int; 

 [B15 (ENTRY)]
   Succs (1): B14

 [B1]
   1: return tree[0];
   Preds (2): B6 B7
   Succs (1): B0

 [B2]
   1: i++
   Preds (3): B3 B4 B5
   Succs (1): B7

 [B3]
   1: tree[i]->right = tree[pos++]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: tree[i]->left = tree[pos++]
   2: pos < n
   T: if [B4.2]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: tree[i] (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B2

 [B6]
   1: pos < n
   T: for (...; [B7.1] && [B6.1]; ...)
   Preds (1): B7
   Succs (2): B5 B1

 [B7]
   1: i < n
   T: [B7.1] && ...
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B8]
   1: int pos = 1;
   2: int i = 0;
   Preds (1): B13
   Succs (1): B7

 [B9]
   1: i++
   Preds (2): B10 B11
   Succs (1): B13

 [B10]
   1: a[i] (CXXConstructExpr, struct TreeNode)
   2: new struct TreeNode([B10.1])
   3: tree[i] = [B10.2]
   Preds (1): B12
   Succs (1): B9

 [B11]
   T: continue;
   Preds (1): B12
   Succs (1): B9

 [B12]
   1: a[i] == 0
   T: if [B12.1]
   Preds (1): B13
   Succs (2): B11 B10

 [B13]
   1: i < n
   T: for (...; [B13.1]; ...)
   Preds (2): B9 B14
   Succs (2): B12 B8

 [B14]
   1: new struct TreeNode *[n]
   2: struct TreeNode **tree = new struct TreeNode *[n];
   3: int i = 0;
   Preds (1): B15
   Succs (1): B13

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printMatrix printMatrix
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: struct TreeNode *p;
   2: int a[] = {3, 9, 20, 0, 0, 15, 7};
   3: createTree(a, sizeof (a) / sizeof(int))
   4: p = [B1.3]
   5: printTree_level_order(p)
   6: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/burstBalloons/BurstBalloons.cpp

function-decl: Solution::maxCoins maxCoins
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int n;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::maxCoins_DC maxCoins_DC
param-decl: int &; int &; int; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: return result;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: ++i
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < high
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int result = 0;
   2: int i = low + 1;
   Preds (1): B6
   Succs (1): B3

 [B5]
   1: return 0;
   Preds (1): B6
   Succs (1): B0

 [B6]
   1: low + 1 == high
   T: if [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B0 (EXIT)]
   Preds (2): B1 B5

function-decl: Solution::maxCoins_DP maxCoins_DP
param-decl: int &; int &; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: ++k
   Preds (1): B4
   Succs (1): B6

 [B2]
   1: low++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: int high = low + k;
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: low < n - k
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int low = 0;
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: k < n
   T: for (...; [B6.1]; ...)
   Preds (2): B1 B7
   Succs (2): B5 B0

 [B7]
   1: int n;
   2: int k = 2;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B6

function-decl: Solution::printVector printVector
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/plusOne/plusOne.cpp

function-decl: plusOne plusOne
param-decl: int &; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int carry = 1;
   2: int v;
   3: carry > 0
   T: if [B2.3]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: printVector printVector
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {9, 9, 9};
   2: int v;
   3: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/anagrams/ValidAnagram.cpp

function-decl: Solution::isAnagram01 isAnagram01
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::isAnagram02 isAnagram02
param-decl: int; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: return true;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B4
   Succs (1): B5

 [B3]
   1: return false;
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: map[i] != 0
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < sizeof (map) / sizeof (map[0])
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int map[26] = {0};
   2: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (2): B1 B3

function-decl: Solution::isAnagram isAnagram
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/anagrams/GroupAnagrams.cpp

function-decl: Solution::groupAnagrams groupAnagrams
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::groupAnagrams01 groupAnagrams01
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::anagrams anagrams
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/maximumSubArray/maximumSubArray.cpp

function-decl: max max
param-decl: int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: [B4.1] ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: x
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: y
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: x > y
   T: [B4.1] ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: maxSubArray maxSubArray
param-decl: int *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: maxSubArray2(A, n)
   2: return [B1.1];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: maxSubArray1(A, n)
   2: return [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: maxSubArray1 maxSubArray1
param-decl: int *; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: delete [] sum
   2: return m;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: max(A[i], A[i] + sum[i - 1])
   2: sum[i] = [B3.1]
   3: max(m, sum[i])
   4: m = [B3.3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < n
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: new int [n]
   2: int *sum = new int [n];
   3: sum[0] = A[0]
   4: int m = A[0];
   5: int i = 1;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1

function-decl: maxSubArray2 maxSubArray2
param-decl: int *; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: return m;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   1: sum = 0
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: sum += A[i]
   2: max(sum, m)
   3: m = [B4.2]
   4: sum < 0
   T: if [B4.4]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < n
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int m = (-2147483647 - 1);
   2: int sum = 0;
   3: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
   2: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/subsets/subsets.cpp

function-decl: subsets subsets
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: combine combine
param-decl: int &; int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: combine1 combine1
param-decl: int &; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int solution;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: getCombination getCombination
param-decl: int &; int; int; int &; int &; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: i--
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i > 0
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = n;
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: return;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: k == 0
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (2): B2 B4

function-decl: combine2 combine2
param-decl: int &; int; 

 [B22 (ENTRY)]
   Succs (1): B21

 [B1]
   Preds (1): B3
   Succs (1): B18

 [B2]
   T: break;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: !found
   T: if [B3.1]
   Preds (2): B7 B13
   Succs (2): B2 B1

 [B4]
   1: i++
   Preds (2): B5 B6
   Succs (1): B13

 [B5]
   1: ones++
   Preds (1): B6
   Succs (1): B4

 [B6]
   T: if <null expr>
   Preds (1): B12
   Succs (2): B5 B4

 [B7]
   T: break;
   Preds (1): B10
   Succs (1): B3

 [B8]
   1: j++
   Preds (1): B9
   Succs (1): B10

 [B9]
   1: ones--
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: j < i
   T: for (...; [B10.1]; ...)
   Preds (2): B8 B11
   Succs (2): B9 B7

 [B11]
   1: found = true
   2: int j = 0;
   Preds (1): B12
   Succs (1): B10

 [B12]
   T: if <null expr>
   Preds (1): B13
   Succs (2): B11 B6

 [B13]
   1: i < n - 1
   T: for (...; [B13.1]; ...)
   Preds (2): B4 B14
   Succs (2): B12 B3

 [B14]
   1: int i;
   2: _Bool found = false;
   3: int ones = 0;
   4: i = 0
   Preds (1): B16
   Succs (1): B13

 [B15]
   1: x++
   Preds (1): B16
   Succs (1): B16

 [B16]
   1: x < n
   T: for (...; [B16.1]; ...)
   Preds (2): B15 B17
   Succs (2): B15 B14

 [B17]
   1: int tmp;
   2: int x = 0;
   Preds (1): B18
   Succs (1): B16

 [B18]
   1: 1 (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: while [B18.1]
   Preds (2): B1 B20
   Succs (2): B17 NULL

 [B19]
   1: i++
   Preds (1): B20
   Succs (1): B20

 [B20]
   1: i < n
   T: for (...; [B20.1]; ...)
   Preds (2): B19 B21
   Succs (2): B19 B18

 [B21]
   1: int d;
   2: int n;
   3: int i = 0;
   Preds (1): B22
   Succs (1): B20

 [B0 (EXIT)]
   Preds (1): B2

function-decl: printResult printResult
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printArray printArray
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: i--
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i > 0
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int v;
   2: int i = n;
   Preds (2): B4 B5
   Succs (1): B2

 [B4]
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: int n = 3;
   2: argc > 1
   T: if [B5.2]
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (1): B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/subsets/subsets.II.cpp

function-decl: subsets subsets
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: combine combine
param-decl: int &; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int solution;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: getCombination getCombination
param-decl: int &; int; int; int &; int &; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: i--
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i > 0
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = n;
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: return;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: k == 0
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (2): B2 B4

function-decl: printResult printResult
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printArray printArray
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: int a[] = {1, 4, 4, 4, 4};
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i--
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i > 0
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int v;
   2: int i = n;
   Preds (2): B5 B6
   Succs (1): B3

 [B5]
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: int n = 3;
   2: argc > 1
   T: if [B6.2]
   Preds (1): B7
   Succs (2): B5 B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/intersectionOfTwoLinkedLists/intersectionOfTwoLinkedLists.cpp

function-decl: Solution::getIntersectionNode getIntersectionNode
param-decl: int *; int *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int lenA;
   2: int lenB;
   3: lenA < lenB
   T: if [B2.3]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::getListLength getListLength
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int len = 0;
   2: return len;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/constructBinaryTreeFromInorderAndPostorderTraversal/constructBinaryTreeFromInorderAndPostorderTraversal.cpp

function-decl: TreeNode::TreeNode TreeNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: buildTree buildTree
param-decl: int &; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: buildTree buildTree
param-decl: int &; int; int &; int; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: int left_n = i - in_offset;
   2: int right_n = in_offset + n - i - 1;
   3: return root;
   Preds (2): B3 B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B4
   Succs (1): B5

 [B3]
   T: break;
   Preds (1): B4
   Succs (1): B1

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < in_offset + n
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int i;
   2: i = in_offset
   Preds (1): B8
   Succs (1): B5

 [B7]
   1: return root;
   Preds (1): B8
   Succs (1): B0

 [B8]
   1: struct TreeNode *root;
   2: n == 1
   T: if [B8.2]
   Preds (1): B9
   Succs (2): B7 B6

 [B0 (EXIT)]
   Preds (2): B1 B7

function-decl: buildTree2 buildTree2
param-decl: int &; int &; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return root;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: int i;
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return root;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: int post_n;
   2: struct TreeNode *root;
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (2): B1 B6

function-decl: printTree_pre_order printTree_pre_order
param-decl: struct TreeNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: printTree_pre_order(root->left)
   2: printTree_pre_order(root->right)
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: printTree_in_order printTree_in_order
param-decl: struct TreeNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: printTree_in_order(root->left)
   2: printTree_in_order(root->right)
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: printTree_level_order printTree_level_order
param-decl: struct TreeNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int q;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int in_order[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'};
   2: int post_order[] = {'A', 'C', 'E', 'D', 'B', 'H', 'I', 'G', 'F'};
   3: struct TreeNode *tree;
   4: printTree_level_order(tree)
   5: printTree_pre_order(tree)
   6: printTree_in_order(tree)
   7: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/coinChange/coinChange.cpp

function-decl: Solution::coinChange coinChange
param-decl: int &; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return -1;
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: amount < 0
   T: if [B2.1]
   Preds (1): B4
   Succs (2): B1 B0

 [B3]
   1: return 0;
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: int result;
   2: amount == 0
   T: if [B4.2]
   Preds (1): B5
   Succs (2): B3 B2

 [B0 (EXIT)]
   Preds (3): B1 B2 B3


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/coinChange/CoinChange2.cpp

function-decl: Solution::change change
param-decl: int; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::change_recursive change_recursive
param-decl: int; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int result = 0;
   2: return result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::change_recursive_helper change_recursive_helper
param-decl: int; int &; int; int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: result++
   2: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: amount == 0
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::change_dp change_dp
param-decl: int; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/firstUniqueCharacterInAString/FirstUniqueCharacterInAString.cpp

function-decl: Solution::firstUniqChar firstUniqChar
param-decl: int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: __begin1 != __end1
   T: for (auto item : pos_map) {
    if (<null expr>) {
    }
}

   Preds (2): B2 B5
   Succs (2): B4 B0

 [B2]
   1: ++__begin1
   Preds (2): B3 B4
   Succs (1): B1

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: auto item = *__begin1;
   T: if <null expr>
   Preds (1): B1
   Succs (2): B3 B2

 [B5]
   1: int pos_map[256];
   2: int pos;
   3: auto &&__range1 = pos_map;
   4: auto __end1 = __range1 + 256L;
   5: auto __begin1 = __range1;
   Preds (1): B6
   Succs (1): B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/minimumDepthOfBinaryTree/minimumDepthOfBinaryTree.cpp

function-decl: Solution::minDepth minDepth
param-decl: int *; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int right;
   T: if <null expr>
   Preds (2): B3 B4
   Succs (2): B1 B0

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: int left;
   T: if <null expr>
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   1: return 1;
   Preds (1): B6
   Succs (1): B0

 [B6]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B5 B4

 [B7]
   1: return 0;
   Preds (1): B8
   Succs (1): B0

 [B8]
   T: if <null expr>
   Preds (1): B9
   Succs (2): B7 B6

 [B0 (EXIT)]
   Preds (4): B1 B2 B5 B7


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/palindromePartitioning/palindromePartitioning.II.cpp

function-decl: minCut minCut
param-decl: int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int min = 2147483647;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: minCut_DP minCut_DP
param-decl: int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i--
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i >= 0
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: _Bool mp;
   2: int i;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: minCutHelper minCutHelper
param-decl: int &; int; int &; 

 [B20 (ENTRY)]
   Succs (1): B19

 [B1]
   1: return min;
   Preds (2): B8 B10
   Succs (1): B0

 [B2]
   1: i--
   Preds (4): B3 B4 B5 B7
   Succs (1): B10

 [B3]
   1: min = m
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: min > m
   T: if [B4.1]
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   T: continue;
   Preds (1): B6
   Succs (1): B2

 [B6]
   1: m < 0
   T: if [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   T: if <null expr>
   Preds (1): B9
   Succs (2): B6 B2

 [B8]
   T: break;
   Preds (1): B9
   Succs (1): B1

 [B9]
   T: if <null expr>
   Preds (1): B10
   Succs (2): B8 B7

 [B10]
   1: i >= 0
   T: for (...; [B10.1]; ...)
   Preds (2): B2 B11
   Succs (2): B9 B1

 [B11]
   1: int min = 2147483647;
   2: int subs;
   3: int m;
   4: int i;
   Preds (1): B15
   Succs (1): B10

 [B12]
   1: return 0;
   Preds (2): B13 B14
   Succs (1): B0

 [B13]
   1: minSteps = steps
   Preds (1): B14
   Succs (1): B12

 [B14]
   1: minSteps > steps
   T: if [B14.1]
   Preds (1): B15
   Succs (2): B13 B12

 [B15]
   T: if <null expr>
   Preds (2): B16 B17
   Succs (2): B14 B11

 [B16]
   Preds (1): B17
   Succs (1): B15

 [B17]
   1: static int cache;
   T: if <null expr>
   Preds (1): B19
   Succs (2): B16 B15

 [B18]
   1: return -2;
   Preds (1): B19
   Succs (1): B0

 [B19]
   1: minSteps <= steps
   T: if [B19.1]
   Preds (1): B20
   Succs (2): B18 B17

 [B0 (EXIT)]
   Preds (3): B1 B12 B18

function-decl: minCutHelper minCutHelper
param-decl: int &; int; int; int &; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: i--
   Preds (2): B2 B3
   Succs (1): B4

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: i >= start
   T: for (...; [B4.1]; ...)
   Preds (2): B1 B5
   Succs (2): B3 B0

 [B5]
   1: int i;
   Preds (2): B7 B8
   Succs (1): B4

 [B6]
   1: min = steps
   2: return;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: steps < min
   T: if [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   T: if <null expr>
   Preds (1): B9
   Succs (2): B7 B5

 [B0 (EXIT)]
   Preds (2): B4 B6

function-decl: isPalindrome isPalindrome
param-decl: int &; int; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: return true;
   Preds (1): B6
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B6

 [B3]
   1: start++
   2: end--
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: return false;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: start < end
   T: while [B6.1]
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B0 (EXIT)]
   Preds (2): B1 B4

function-decl: main main
param-decl: int; char **; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int s;
   2: argc > 1
   T: if [B2.2]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/palindromePartitioning/palindromePartitioning.cpp

function-decl: isPalindrome isPalindrome
param-decl: int &; int; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: return true;
   Preds (1): B6
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B6

 [B3]
   1: start++
   2: end--
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: return false;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: start < end
   T: while [B6.1]
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B0 (EXIT)]
   Preds (2): B1 B4

function-decl: partitionHelper partitionHelper
param-decl: int &; int; int &; int &; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return;
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: partition partition
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printMatrix printMatrix
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int s;
   2: argc > 1
   T: if [B2.2]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/reverseNodesInKGroup/reverseNodesInKGroup.cpp

function-decl: ListNode::ListNode ListNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: reverseKGroup reverseKGroup
param-decl: struct ListNode *; int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: return fake.next;
   Preds (1): B8
   Succs (1): B0

 [B2]
   Preds (2): B5 B6
   Succs (1): B8

 [B3]
   1: i++
   Preds (1): B4
   Succs (1): B6

 [B4]
   1: p = p->next
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: i < k
   T: for (...; [B6.1] && [B5.1]; ...)
   Preds (1): B6
   Succs (2): B4 B2

 [B6]
   1: p (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B6.1] && ...
   Preds (2): B3 B7
   Succs (2): B5 B2

 [B7]
   1: reverseList(p->next, k)
   2: p->next = [B7.1]
   3: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: p (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: while [B8.1]
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: 0 (CXXConstructExpr, struct ListNode)
   2: struct ListNode fake(0);
   3: fake.next = head
   4: struct ListNode *p = &fake;
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: return head;
   Preds (1): B11
   Succs (1): B0

 [B11]
   1: k <= 0
   T: if [B11.1]
   Preds (1): B12
   Succs (2): B10 B9

 [B0 (EXIT)]
   Preds (2): B1 B10

function-decl: reverseList reverseList
param-decl: struct ListNode *&; int; 

 [B13 (ENTRY)]
   Succs (1): B12

 [B1]
   1: return pHead;
   Preds (1): B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: struct ListNode *q = p->next;
   2: p->next = pHead
   3: pHead = p
   4: p = q
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: p != pEnd
   T: while [B4.1]
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: struct ListNode *pHead = pEnd;
   2: struct ListNode *p = head;
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: return head;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: k > 0
   T: if [B7.1]
   Preds (2): B10 B11
   Succs (2): B6 B5

 [B8]
   Preds (1): B9
   Succs (1): B11

 [B9]
   1: pEnd = pEnd->next
   2: k--
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: k > 0
   T: while [B11.1] && [B10.1]
   Preds (1): B11
   Succs (2): B9 B7

 [B11]
   1: pEnd (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B11.1] && ...
   Preds (2): B8 B12
   Succs (2): B10 B7

 [B12]
   1: struct ListNode *pEnd = head;
   Preds (1): B13
   Succs (1): B11

 [B0 (EXIT)]
   Preds (2): B1 B6

function-decl: printList printList
param-decl: struct ListNode *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: createList createList
param-decl: int *; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return head;
   Preds (1): B6
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B6

 [B3]
   1: a[i] (CXXConstructExpr, struct ListNode)
   2: new struct ListNode([B3.1])
   3: p->next = [B3.2]
   4: p = p->next
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: a[i] (CXXConstructExpr, struct ListNode)
   2: new struct ListNode([B4.1])
   3: head = p = [B4.2]
   Preds (1): B5
   Succs (1): B2

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: i < n
   T: for (...; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: struct ListNode *head;
   2: struct ListNode *p;
   3: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: reverseKGroup(pList, k)
   2: pList = [B1.1]
   3: printList(pList)
   4: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   2: createList(a, sizeof (a) / sizeof(int))
   3: struct ListNode *pList = createList(a, sizeof (a) / sizeof(int));
   4: int k = 2;
   5: argc > 1
   T: if [B3.5]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/randomPickIndex/RandomPickIndex.cpp

function-decl: pick pick
param-decl: int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   Preds (1): B3
   Succs (1): B4

 [B2]
   1: return idx;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: int idx;
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: true
   T: while [B4.1]
   Preds (2): B1 B5
   Succs (2): B3 NULL

 [B0 (EXIT)]
   Preds (1): B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/nQueens/nQueuens.II.cpp

function-decl: totalNQueens totalNQueens
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int result = 0;
   2: return result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: solveNQueensRecursive solveNQueensRecursive
param-decl: int; int; int &; int &; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: i++
   Preds (3): B2 B3 B4
   Succs (1): B5

 [B2]
   1: result++
   T: continue;
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: currentRow + 1 == n
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B1

 [B5]
   1: i < n
   T: for (...; [B5.1]; ...)
   Preds (2): B1 B6
   Succs (2): B4 B0

 [B6]
   1: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B5

function-decl: isValid isValid
param-decl: int; int; int &; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: return true;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B4
   Succs (1): B5

 [B3]
   1: return false;
   Preds (1): B4
   Succs (1): B0

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < attemptedRow
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (2): B1 B3

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: totalNQueens(n)
   2: int result = totalNQueens(n);
   3: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int n = 8;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/nQueens/nQueuens.cpp

function-decl: solveNQueens solveNQueens
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: solveNQueensRecursive solveNQueensRecursive
param-decl: int; int; int &; int &; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: col++
   Preds (2): B2 B3
   Succs (1): B4

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: col < n
   T: for (...; [B4.1]; ...)
   Preds (2): B1 B5
   Succs (2): B3 B0

 [B5]
   1: int col = 0;
   Preds (1): B10
   Succs (1): B4

 [B6]
   1: return;
   Preds (1): B8
   Succs (1): B0

 [B7]
   1: row++
   Preds (1): B8
   Succs (1): B8

 [B8]
   1: row < n
   T: for (...; [B8.1]; ...)
   Preds (2): B7 B9
   Succs (2): B7 B6

 [B9]
   1: int row = 0;
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: currentRow == n
   T: if [B10.1]
   Preds (1): B11
   Succs (2): B9 B5

 [B0 (EXIT)]
   Preds (2): B4 B6

function-decl: isValid isValid
param-decl: int; int; int &; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: return true;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B4
   Succs (1): B5

 [B3]
   1: return false;
   Preds (1): B4
   Succs (1): B0

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < attemptedRow
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (2): B1 B3

function-decl: printMatrix printMatrix
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int n = 8;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/validParentheses/validParentheses.cpp

function-decl: isValid isValid
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int st;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int s;
   2: argc > 1
   T: if [B2.2]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/largestNumber/largestNumber.cpp

function-decl: Solution::comp comp
param-decl: int &; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::largestNumber largestNumber
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/sortArrayByParity/SortArrayByParity.II.cpp

function-decl: Solution::isEven isEven
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return x % 2 == 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::sortArrayByParityII sortArrayByParityII
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int even = 0;
   2: int odd = 1;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/sortArrayByParity/SortArrayByParity.cpp

function-decl: Solution::isEven isEven
param-decl: int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return x % 2 == 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::sortArrayByParity sortArrayByParity
param-decl: int &; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   Preds (2): B2 B3
   Succs (1): B6

 [B2]
   1: r--
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   1: l++
   Preds (1): B5
   Succs (1): B3

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: l < r
   T: while [B6.1]
   Preds (2): B1 B7
   Succs (2): B5 B0

 [B7]
   1: int l = 0;
   2: int r;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B6


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/palindromeLinkedList/PalindromeLinkedList.cpp

function-decl: Solution::findMiddle findMiddle
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int *p1;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::reverseLink reverseLink
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int *p;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::isPalindrome isPalindrome
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int *pMid;
   2: int *pRev;
   3: return true;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/readNCharactersGivenRead4/readNCharactersGivenRead4.cpp

function-decl: Solution::read read
param-decl: char *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: this->read2(buf, n)
   2: return [B1.1];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: this->read1(buf, n)
   2: return [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::read1 read1
param-decl: char *; int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return len;
   Preds (2): B7 B8
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B8

 [B3]
   1: [B6.1] ? [B4.1] : [B5.1]
   2: size = [B3.1]
   3: len += size
   4: buf += size
   Preds (2): B4 B5
   Succs (1): B2

 [B4]
   1: n - len
   Preds (1): B6
   Succs (1): B3

 [B5]
   1: size (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B6
   Succs (1): B3

 [B6]
   1: len + size > n
   T: [B6.1] ? ... : ...
   Preds (1): B7
   Succs (2): B4 B5

 [B7]
   1: read4(buf)
   2: (size = [B7.1]) > 0
   T: while [B8.1] && [B7.2]
   Preds (1): B8
   Succs (2): B6 B1

 [B8]
   1: len <= n
   T: [B8.1] && ...
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int len = 0;
   2: int size = 0;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::read2 read2
param-decl: char *; int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return len;
   Preds (2): B3 B8
   Succs (1): B0

 [B2]
   Preds (1): B4
   Succs (1): B8

 [B3]
   T: break;
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: [B7.1] ? [B5.1] : [B6.1]
   2: size = [B4.1]
   3: len += size
   4: len >= n
   T: if [B4.4]
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   1: n - len
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: _n (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B7
   Succs (1): B4

 [B7]
   1: len + _n > n
   T: [B7.1] ? ... : ...
   Preds (1): B8
   Succs (2): B5 B6

 [B8]
   1: read4(_buf)
   2: (_n = [B8.1]) > 0
   T: while [B8.2]
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: char _buf[4];
   2: int _n = 0;
   3: int len = 0;
   4: int size = 0;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/readNCharactersGivenRead4/readNCharactersGivenRead4.II.cpp

function-decl: read4 read4
param-decl: char *; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: return s;
   Preds (2): B4 B5
   Succs (1): B0

 [B2]
   1: s++
   Preds (1): B3
   Succs (1): B5

 [B3]
   1: buf[s] = *p
   2: p++
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: *p != '\x00'
   T: for (; [B5.1] && [B4.1]; ...)
   Preds (1): B5
   Succs (2): B3 B1

 [B5]
   1: s < 4
   T: [B5.1] && ...
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int s = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B1

function-decl: RingBuffer::RingBuffer RingBuffer
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->_size = 0
   2: new char [this->_capacity]
   3: this->_pbuf = [B1.2]
   4: this->_p = this->_pbuf
   5: this->_pend = this->_pbuf + this->_capacity - 1
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: RingBuffer::~RingBuffer ~RingBuffer
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: delete this->_pbuf
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: RingBuffer::read read
param-decl: char *; int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: this->_size -= s
   2: return s;
   Preds (2): B7 B8
   Succs (1): B0

 [B2]
   1: s++
   Preds (1): B3
   Succs (1): B8

 [B3]
   1: ([B6.2]) ? [B4.1] : [B5.1]
   2: this->_p = [B3.1]
   Preds (2): B4 B5
   Succs (1): B2

 [B4]
   1: this->_p + 1
   Preds (1): B6
   Succs (1): B3

 [B5]
   1: this->_pbuf (ImplicitCastExpr, LValueToRValue, char *)
   Preds (1): B6
   Succs (1): B3

 [B6]
   1: buf[s] = *this->_p
   2: this->_p < this->_pend
   T: ([B6.2]) ? ... : ...
   Preds (1): B7
   Succs (2): B4 B5

 [B7]
   1: s < this->_size
   T: for (...; [B8.1] && [B7.1]; ...)
   Preds (1): B8
   Succs (2): B6 B1

 [B8]
   1: s < n
   T: [B8.1] && ...
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int s;
   2: s = 0
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: return 0;
   Preds (1): B11
   Succs (1): B0

 [B11]
   1: this->_size == 0
   T: if [B11.1]
   Preds (1): B12
   Succs (2): B10 B9

 [B0 (EXIT)]
   Preds (2): B1 B10

function-decl: RingBuffer::write write
param-decl: char *; int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: this->_size += s
   2: return s;
   Preds (2): B7 B8
   Succs (1): B0

 [B2]
   1: s++
   Preds (1): B3
   Succs (1): B8

 [B3]
   1: ([B6.2]) ? [B4.1] : [B5.1]
   2: p = [B3.1]
   Preds (2): B4 B5
   Succs (1): B2

 [B4]
   1: p + 1
   Preds (1): B6
   Succs (1): B3

 [B5]
   1: this->_pbuf (ImplicitCastExpr, LValueToRValue, char *)
   Preds (1): B6
   Succs (1): B3

 [B6]
   1: *p = buf[s]
   2: p < this->_pend
   T: ([B6.2]) ? ... : ...
   Preds (1): B7
   Succs (2): B4 B5

 [B7]
   1: s < n
   T: for (...; [B8.1] && [B7.1]; ...)
   Preds (1): B8
   Succs (2): B6 B1

 [B8]
   1: s < this->_capacity - this->_size
   T: [B8.1] && ...
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int s;
   2: char *p = this->_p + this->_size;
   3: s = 0
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: return 0;
   Preds (1): B11
   Succs (1): B0

 [B11]
   1: this->_size >= this->_capacity
   T: if [B11.1]
   Preds (1): B12
   Succs (2): B10 B9

 [B0 (EXIT)]
   Preds (2): B1 B10

function-decl: Solution::read read
param-decl: char *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: n = n - buf_size
   2: this->read1(buf + buf_size, n)
   3: api_size = [B1.2]
   4: return buf_size + api_size;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return n;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: int buf_size = 0;
   2: int api_size = 0;
   3: this->_ring_buffer.read(buf, n)
   4: buf_size = [B3.3]
   5: buf_size == n
   T: if [B3.5]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Solution::read1 read1
param-decl: char *; int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: return len;
   Preds (2): B3 B10
   Succs (1): B0

 [B2]
   Preds (1): B4
   Succs (1): B10

 [B3]
   T: break;
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: len += size
   2: len >= n
   T: if [B4.2]
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   1: this->_ring_buffer.write(_buf + size, _n - size)
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: [B9.1] ? [B7.1] : [B8.1]
   2: size = [B6.1]
   3: len + _n > n
   T: if [B6.3]
   Preds (2): B7 B8
   Succs (2): B5 B4

 [B7]
   1: n - len
   Preds (1): B9
   Succs (1): B6

 [B8]
   1: _n (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B9
   Succs (1): B6

 [B9]
   1: len + _n > n
   T: [B9.1] ? ... : ...
   Preds (1): B10
   Succs (2): B7 B8

 [B10]
   1: read4(_buf)
   2: (_n = [B10.1]) > 0
   T: while [B10.2]
   Preds (2): B2 B11
   Succs (2): B9 B1

 [B11]
   1: char _buf[4];
   2: int _n = 0;
   3: int len = 0;
   4: int size = 0;
   Preds (1): B12
   Succs (1): B10

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B14 (ENTRY)]
   Succs (1): B13

 [B1]
   1: s.read(buf, 4)
   2: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: s.read(buf, 1)
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < 3
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: p = input
   2: s.read(buf, 4)
   3: int i = 0;
   Preds (1): B8
   Succs (1): B4

 [B6]
   1: i++
   Preds (1): B7
   Succs (1): B8

 [B7]
   1: s.read(buf, 1)
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: i < 5
   T: for (...; [B8.1]; ...)
   Preds (2): B6 B9
   Succs (2): B7 B5

 [B9]
   1: p = input
   2: s.read(buf, 1)
   3: s.read(buf, 2)
   4: p = input
   5: int i = 0;
   Preds (1): B12
   Succs (1): B8

 [B10]
   1: i++
   Preds (1): B11
   Succs (1): B12

 [B11]
   1: s.read(buf, 4)
   Preds (1): B12
   Succs (1): B10

 [B12]
   1: i < 5
   T: for (...; [B12.1]; ...)
   Preds (2): B10 B13
   Succs (2): B11 B9

 [B13]
   1:  (CXXConstructExpr, class Solution)
   2: class Solution s;
   3: const int buf_len = 10;
   4: char buf[10] = {0};
   5: p = input
   6: int i = 0;
   Preds (1): B14
   Succs (1): B12

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/reverseVowelsOfAString/reverseVowelsOfAString.cpp

function-decl: Solution::reverseVowels reverseVowels
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int vowels;
   2: int vows;
   3: int result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/sumOfTwoIntegers/SumOfTwoIntegers.cpp

function-decl: Solution::getSum getSum
param-decl: int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return x;
   Preds (1): B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: int carry = x & y;
   2: x = x ^ y
   3: y = carry << 1
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: y != 0
   T: while [B4.1]
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/candy/candy.cpp

function-decl: candy candy
param-decl: int &; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return totalCandy;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i--
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i >= 0
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int totalCandy;
   2: int i;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: generateRatings generateRatings
param-decl: int &; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: print print
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int ratings;
   2: int r[] = {5, 6, 7, 4, 1, 2, 3, 2, 1, 7};
   3: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int n = 10;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/intersectionOfTwoArrays/intersectionOfTwoArraysII.cpp

function-decl: Solution::intersect intersect
param-decl: int &; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int solution;
   2: int index = 0;
   3: _Bool finished = false;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/intersectionOfTwoArrays/intersectionOfTwoArrays.cpp

function-decl: Solution::intersection intersection
param-decl: int &; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution2::intersection intersection
param-decl: int &; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int res;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/permutations/permutations.cpp

function-decl: permute permute
param-decl: int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int pos = 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < n
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int v;
   2: int i = 0;
   Preds (2): B5 B6
   Succs (1): B3

 [B5]
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: int n = 3;
   2: argc > 1
   T: if [B6.2]
   Preds (1): B7
   Succs (2): B5 B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/permutations/permutations.II.cpp

function-decl: permute permute
param-decl: int &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int pos = 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printVector printVector
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < n
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int v;
   2: int i = 0;
   Preds (2): B5 B6
   Succs (1): B3

 [B5]
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: int n = 3;
   2: argc > 1
   T: if [B6.2]
   Preds (1): B7
   Succs (2): B5 B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/removeLinkedListElements/RemoveLinkedListElements.cpp

function-decl: Solution::removeElements removeElements
param-decl: int *; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: static int dummy;
   2: int *p;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/medianOfTwoSortedArrays/medianOfTwoSortedArrays.cpp

function-decl: binarySearch binarySearch
param-decl: int *; int; int; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: return low;
   Preds (1): B8
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B8

 [B3]
   1: high = mid - 1
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: low = mid + 1
   Preds (1): B5
   Succs (1): B2

 [B5]
   1: key > A[mid]
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return mid;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: int mid = low + (high - low) / 2;
   2: key == A[mid]
   T: if [B7.2]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: low <= high
   T: while [B8.1]
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B0 (EXIT)]
   Preds (2): B1 B6

function-decl: findMedianSortedArrayHelper findMedianSortedArrayHelper
param-decl: int *; int; int *; int; int; int; int; int; 

 [B23 (ENTRY)]
   Succs (1): B22

 [B1]
   1: findMedianSortedArrayHelper(B, n, A, m, lowB, highB, lowA, highA)
   2: return [B1.1];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: findMedianSortedArrayHelper(A, m, B, n, lowA, highA, lowB, highB)
   2: return [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: highA = mid - 1
   2: highB = pos - 1
   3: highA - lowA > highB - lowB
   T: if [B3.3]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: num > (m + n) / 2
   T: if [B4.1]
   Preds (1): B8
   Succs (2): B3 B0

 [B5]
   1: findMedianSortedArrayHelper(B, n, A, m, lowB, highB, lowA, highA)
   2: return [B5.1];
   Preds (1): B7
   Succs (1): B0

 [B6]
   1: findMedianSortedArrayHelper(A, m, B, n, lowA, highA, lowB, highB)
   2: return [B6.1];
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: lowA = mid + 1
   2: lowB = pos
   3: highA - lowA > highB - lowB
   T: if [B7.3]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: num < (m + n) / 2
   T: if [B8.1]
   Preds (1): B22
   Succs (2): B7 B4

 [B9]
   1: return (A[mid] + next) / 2.;
   Preds (4): B10 B11 B12 B14
   Succs (1): B0

 [B10]
   1: next = A[mid - 1]
   Preds (1): B11
   Succs (1): B9

 [B11]
   1: mid > 0
   T: if [B11.1]
   Preds (1): B13
   Succs (2): B10 B9

 [B12]
   1: next = B[pos - 1]
   Preds (1): B13
   Succs (1): B9

 [B13]
   1: pos > 0
   T: if [B13.1]
   Preds (2): B18 B19
   Succs (2): B12 B11

 [B14]
   1: [B17.1] ? [B15.1] : [B16.1]
   2: next = [B14.1]
   Preds (2): B15 B16
   Succs (1): B9

 [B15]
   1: A[mid - 1]
   Preds (1): B17
   Succs (1): B14

 [B16]
   1: B[pos - 1]
   Preds (1): B17
   Succs (1): B14

 [B17]
   1: A[mid - 1] > B[pos - 1]
   T: [B17.1] ? ... : ...
   Preds (1): B18
   Succs (2): B15 B16

 [B18]
   1: pos > 0
   T: if [B19.2] && [B18.1]
   Preds (1): B19
   Succs (2): B17 B13

 [B19]
   1: int next;
   2: mid > 0
   T: [B19.2] && ...
   Preds (1): B21
   Succs (2): B18 B13

 [B20]
   1: return A[mid];
   Preds (1): B21
   Succs (1): B0

 [B21]
   1: (m + n) % 2 == 1
   T: if [B21.1]
   Preds (1): B22
   Succs (2): B20 B19

 [B22]
   1: int mid = lowA + (highA - lowA) / 2;
   2: binarySearch(B, lowB, highB, A[mid])
   3: int pos = binarySearch(B, lowB, highB, A[mid]);
   4: int num = mid + pos;
   5: num == (m + n) / 2
   T: if [B22.5]
   Preds (1): B23
   Succs (2): B21 B8

 [B0 (EXIT)]
   Preds (7): B1 B2 B4 B5 B6 B9 B20

function-decl: findMedianSortedArrays findMedianSortedArrays
param-decl: int *; int; int *; int; 

 [B17 (ENTRY)]
   Succs (1): B16

 [B1]
   1: findMedianSortedArrayHelper(B, n, A, m, 0, n - 1, 0, m - 1)
   2: return [B1.1];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: findMedianSortedArrayHelper(A, m, B, n, 0, m - 1, 0, n - 1)
   2: return [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: m > n
   T: if [B3.1]
   Preds (1): B8
   Succs (2): B2 B1

 [B4]
   1: [B7.1] ? [B5.1] : [B6.1]
   2: return [B4.1];
   Preds (2): B5 B6
   Succs (1): B0

 [B5]
   1: A[m / 2] (ImplicitCastExpr, IntegralToFloating, double)
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: (A[m / 2 - 1] + A[m / 2]) / 2.
   Preds (1): B7
   Succs (1): B4

 [B7]
   1: m % 2 == 1
   T: [B7.1] ? ... : ...
   Preds (1): B8
   Succs (2): B5 B6

 [B8]
   1: n == 0
   T: if [B8.1]
   Preds (1): B13
   Succs (2): B7 B3

 [B9]
   1: [B12.1] ? [B10.1] : [B11.1]
   2: return [B9.1];
   Preds (2): B10 B11
   Succs (1): B0

 [B10]
   1: B[n / 2] (ImplicitCastExpr, IntegralToFloating, double)
   Preds (1): B12
   Succs (1): B9

 [B11]
   1: (B[n / 2 - 1] + B[n / 2]) / 2.
   Preds (1): B12
   Succs (1): B9

 [B12]
   1: n % 2 == 1
   T: [B12.1] ? ... : ...
   Preds (1): B13
   Succs (2): B10 B11

 [B13]
   1: m == 0
   T: if [B13.1]
   Preds (2): B15 B16
   Succs (2): B12 B8

 [B14]
   1: return 0.;
   Preds (1): B15
   Succs (1): B0

 [B15]
   1: n == 0
   T: if [B16.1] && [B15.1]
   Preds (1): B16
   Succs (2): B14 B13

 [B16]
   1: m == 0
   T: [B16.1] && ...
   Preds (1): B17
   Succs (2): B15 B13

 [B0 (EXIT)]
   Preds (5): B1 B2 B4 B9 B14

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int r1[] = {1};
   2: int r2[] = {2};
   3: int n1 = sizeof (r1) / sizeof (r1[0]);
   4: int n2 = sizeof (r2) / sizeof (r2[0]);
   5: int ar1[] = {1, 12, 15, 26, 38};
   6: int ar2[] = {2, 13, 17, 30, 45, 50};
   7: n1 = sizeof (ar1) / sizeof (ar1[0])
   8: n2 = sizeof (ar2) / sizeof (ar2[0])
   9: int ar11[] = {1, 12, 15, 26, 38};
  10: int ar21[] = {2, 13, 17, 30, 45};
  11: n1 = sizeof (ar11) / sizeof (ar11[0])
  12: n2 = sizeof (ar21) / sizeof (ar21[0])
  13: int a1[] = {1, 2, 5, 6, 8};
  14: int a2[] = {13, 17, 30, 45, 50};
  15: n1 = sizeof (a1) / sizeof (a1[0])
  16: n2 = sizeof (a2) / sizeof (a2[0])
  17: int a10[] = {1, 2, 5, 6, 8, 9, 10};
  18: int a20[] = {13, 17, 30, 45, 50};
  19: n1 = sizeof (a10) / sizeof (a10[0])
  20: n2 = sizeof (a20) / sizeof (a20[0])
  21: int a11[] = {1, 2, 5, 6, 8, 9};
  22: int a21[] = {13, 17, 30, 45, 50};
  23: n1 = sizeof (a11) / sizeof (a11[0])
  24: n2 = sizeof (a21) / sizeof (a21[0])
  25: int a12[] = {1, 2, 5, 6, 8};
  26: int a22[] = {11, 13, 17, 30, 45, 50};
  27: n1 = sizeof (a12) / sizeof (a12[0])
  28: n2 = sizeof (a22) / sizeof (a22[0])
  29: int b1[] = {1};
  30: int b2[] = {2, 3, 4};
  31: n1 = sizeof (b1) / sizeof (b1[0])
  32: n2 = sizeof (b2) / sizeof (b2[0])
  33: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/addToArrayFormOfInteger/AddToArrayFormOfInteger.cpp

function-decl: Solution::addToArrayForm addToArrayForm
param-decl: int &; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: carry /= 10
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: carry > 0
   T: while [B3.1]
   Preds (3): B1 B6 B7
   Succs (2): B2 B0

 [B4]
   1: i--
   Preds (1): B5
   Succs (1): B7

 [B5]
   1: int a;
   2: carry = a / 10
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: carry > 0
   T: for (...; [B7.1] && [B6.1]; ...)
   Preds (1): B7
   Succs (2): B5 B3

 [B7]
   1: i >= 0
   T: [B7.1] && ...
   Preds (2): B4 B8
   Succs (2): B6 B3

 [B8]
   1: int carry = K;
   2: int i;
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (1): B3


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/countingBits/CountingBits.cpp

function-decl: Solution::countBits countBits
param-decl: int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i <= num
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 1;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/evaluateDivision/EvaluateDivision.cpp

function-decl: Solution::dfs dfs
param-decl: int &; int &; int &; double &; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return false;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return true;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return false;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (3): B1 B2 B4

function-decl: Solution::calcEquation calcEquation
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int result;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/fizzBuzz/FizzBuzz.cpp

function-decl: Solution::fizzBuzz_old_school_way fizzBuzz_old_school_way
param-decl: int; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: i++
   Preds (4): B2 B3 B4 B6
   Succs (1): B9

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: i % 5 == 0
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   Preds (1): B5
   Succs (1): B1

 [B5]
   1: i % 3 == 0
   T: if [B5.1]
   Preds (2): B7 B8
   Succs (2): B4 B3

 [B6]
   Preds (1): B7
   Succs (1): B1

 [B7]
   1: i % 5 == 0
   T: if [B8.1] && [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: i % 3 == 0
   T: [B8.1] && ...
   Preds (1): B9
   Succs (2): B7 B5

 [B9]
   1: i <= n
   T: for (...; [B9.1]; ...)
   Preds (2): B1 B10
   Succs (2): B8 B0

 [B10]
   1: int i = 1;
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (1): B9

function-decl: Solution::FizzBuzz::FizzBuzz FizzBuzz
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::FizzBuzz::operator() operator()
param-decl: 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: this->x % 5 == 0
   T: if [B2.1]
   Preds (1): B4
   Succs (2): B1 B0

 [B3]
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: this->x % 3 == 0
   T: if [B4.1]
   Preds (2): B6 B7
   Succs (2): B3 B2

 [B5]
   Preds (1): B6
   Succs (1): B0

 [B6]
   1: this->x % 5 == 0
   T: if [B7.2] && [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: this->x++
   2: this->x % 3 == 0
   T: [B7.2] && ...
   Preds (1): B8
   Succs (2): B6 B4

 [B0 (EXIT)]
   Preds (4): B1 B2 B3 B5

function-decl: Solution::fizzBuzz_cpp_way fizzBuzz_cpp_way
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::fizzBuzz fizzBuzz
param-decl: int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/palindromePairs/PalindromePairs.cpp

function-decl: Solution::isPalindrome isPalindrome
param-decl: int &; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: return true;
   Preds (1): B5
   Succs (1): B0

 [B2]
   Preds (1): B4
   Succs (1): B5

 [B3]
   1: return false;
   Preds (1): B4
   Succs (1): B0

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: left < right
   T: while [B5.1]
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int left = 0;
   2: int right;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (2): B1 B3

function-decl: Solution::palindromePairs palindromePairs
param-decl: int &; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/integerToRoman/integerToRoman.cpp

function-decl: intToRoman intToRoman
param-decl: int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: i++
   Preds (1): B4
   Succs (1): B5

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: num -= value[i]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: num >= value[i]
   T: while [B4.1]
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: num != 0
   T: for (...; [B5.1]; ...)
   Preds (2): B1 B6
   Succs (2): B4 B0

 [B6]
   1: int symbol[];
   2: int value[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
   3: int result;
   4: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B5

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int num = 1234;
   2: argc > 0
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/rotateImage/rotateImage.cpp

function-decl: rotate rotate
param-decl: int &; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: i++
   Preds (1): B4
   Succs (1): B6

 [B2]
   1: j++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: int tmp;
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: j < high
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int low = i;
   2: int high = n - i - 1;
   3: int j = low;
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: i < n / 2
   T: for (...; [B6.1]; ...)
   Preds (2): B1 B7
   Succs (2): B5 B0

 [B7]
   1: int n;
   2: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B6

function-decl: printMatrix printMatrix
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return 0;
   Preds (1): B6
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B4
   Succs (1): B6

 [B3]
   1: j++
   Preds (1): B4
   Succs (1): B4

 [B4]
   1: j <= n
   T: for (...; [B4.1]; ...)
   Preds (2): B3 B5
   Succs (2): B3 B2

 [B5]
   1: int v;
   2: int j = 1;
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: i <= n
   T: for (...; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: int i = 1;
   Preds (2): B8 B9
   Succs (1): B6

 [B8]
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: int n = 2;
   2: argc > 1
   T: if [B9.2]
   Preds (1): B10
   Succs (2): B8 B7

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/fractionToRecurringDecimal/fractionToRecurringDecimal.cpp

function-decl: fractionToDecimal fractionToDecimal
param-decl: int; int; 

 [B18 (ENTRY)]
   Succs (1): B17

 [B1]
   1: pos++
   2: remainder = (remainder * 10) % d
   3: ... , [B1.2]
   Preds (2): B2 B3
   Succs (1): B4

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: remainder != 0
   T: for (...; [B4.1]; ...)
   Preds (2): B1 B5
   Succs (2): B3 B0

 [B5]
   1: int rec;
   2: int pos;
   Preds (2): B6 B7
   Succs (1): B4

 [B6]
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: long long remainder = n % d;
   2: long long division = n / d;
   3: int oss;
   4: remainder == 0
   T: if [B7.4]
   Preds (2): B8 B9
   Succs (2): B6 B5

 [B8]
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: sign == false
   T: if [B9.1]
   Preds (2): B10 B11
   Succs (2): B8 B7

 [B10]
   1: d = -d
   Preds (1): B11
   Succs (1): B9

 [B11]
   1: d < 0
   T: if [B11.1]
   Preds (2): B12 B13
   Succs (2): B10 B9

 [B12]
   1: n = -n
   Preds (1): B13
   Succs (1): B11

 [B13]
   1: long long n = numerator;
   2: long long d = denominator;
   3: _Bool sign = ((float)numerator / denominator >= 0);
   4: n < 0
   T: if [B13.4]
   Preds (2): B14 B15
   Succs (2): B12 B11

 [B14]
   Preds (1): B15
   Succs (1): B13

 [B15]
   1: numerator == 0
   T: if [B15.1]
   Preds (2): B16 B17
   Succs (2): B14 B13

 [B16]
   Preds (1): B17
   Succs (1): B15

 [B17]
   1: int result;
   2: denominator == 0
   T: if [B17.2]
   Preds (1): B18
   Succs (2): B16 B15

 [B0 (EXIT)]
   Preds (1): B4

function-decl: test test
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: int num;
   2: int deno;
   3: test(num, deno)
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: test(1, 2)
   2: test(10, 2)
   3: test(100, 2)
   4: test(1, 3)
   5: test(100, 3)
   6: test(1, 6)
   7: test(100, 6)
   8: test(-1, 4)
   9: test(1, -3)
  10: test(-1, -6)
  11: test(25, 99)
  12: test(1, 7)
  13: test(10, 7)
  14: test(100, 7)
  15: test(1, 17)
  16: test(1, 1024)
  17: test(-2147483648L, -1999)
  18: test(-1, -2147483648L)
  19: argc > 2
   T: if [B3.19]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/fibonacciNumber/FibonacciNumber.cpp

function-decl: Solution::fib fib
param-decl: int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return second;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: N--
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: second += first
   2: first = second - first
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: N > 0
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int first = 0;
   2: int second = 1;
   3: N -= 1
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: return N;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: N < 2
   T: if [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (2): B1 B6


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/oddEvenLinkedList/OddEvenLinkedList.cpp

function-decl: Solution::oddEvenList oddEvenList
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int *pOdd;
   2: int *p;
   3: int *pNext;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/binaryTreePreorderTraversal/binaryTreePreorderTraversal.cpp

function-decl: TreeNode::TreeNode TreeNode
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: preorderTraversal preorderTraversal
param-decl: struct TreeNode *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   T: if <null expr>
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: preorderTraversal1 preorderTraversal1
param-decl: struct TreeNode *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int v;
   2: int stack;
   3: root (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B2.3]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: preorderTraversal2 preorderTraversal2
param-decl: struct TreeNode *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int v;
   2: int stack;
   3: struct TreeNode *top = root;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: createTree createTree
param-decl: int *; int; 

 [B15 (ENTRY)]
   Succs (1): B14

 [B1]
   1: return tree[0];
   Preds (2): B6 B7
   Succs (1): B0

 [B2]
   1: i++
   Preds (3): B3 B4 B5
   Succs (1): B7

 [B3]
   1: tree[i]->right = tree[pos++]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: tree[i]->left = tree[pos++]
   2: pos < n
   T: if [B4.2]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: tree[i] (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B2

 [B6]
   1: pos < n
   T: for (...; [B7.1] && [B6.1]; ...)
   Preds (1): B7
   Succs (2): B5 B1

 [B7]
   1: i < n
   T: [B7.1] && ...
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B8]
   1: int pos = 1;
   2: int i = 0;
   Preds (1): B13
   Succs (1): B7

 [B9]
   1: i++
   Preds (2): B10 B11
   Succs (1): B13

 [B10]
   1: a[i] (CXXConstructExpr, struct TreeNode)
   2: new struct TreeNode([B10.1])
   3: tree[i] = [B10.2]
   Preds (1): B12
   Succs (1): B9

 [B11]
   T: continue;
   Preds (1): B12
   Succs (1): B9

 [B12]
   1: a[i] == 0
   T: if [B12.1]
   Preds (1): B13
   Succs (2): B11 B10

 [B13]
   1: i < n
   T: for (...; [B13.1]; ...)
   Preds (2): B9 B14
   Succs (2): B12 B8

 [B14]
   1: new struct TreeNode *[n]
   2: struct TreeNode **tree = new struct TreeNode *[n];
   3: int i = 0;
   Preds (1): B15
   Succs (1): B13

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printTree_pre_order printTree_pre_order
param-decl: struct TreeNode *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: printTree_pre_order(root->left)
   2: printTree_pre_order(root->right)
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: printArray printArray
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[] = {1, 2, 3, 4, 5, 0, 6, 0, 0, 7, 8, 9, 0};
   2: createTree(a, sizeof (a) / sizeof(int))
   3: struct TreeNode *p = createTree(a, sizeof (a) / sizeof(int));
   4: printTree_pre_order(p)
   5: int v;
   6: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/thirdMaximumNumber/ThirdMaximumNumber.cpp

function-decl: Solution::nMax nMax
param-decl: int &; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int topN;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::thirdMax thirdMax
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/decodeWays/decodeWays.cpp

function-decl: check check
param-decl: char; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: check check
param-decl: char; char; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: ([B6.1] || ([B5.1] && [B4.1])) ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: 1
   Preds (2): B4 B6
   Succs (1): B1

 [B3]
   1: 0
   Preds (2): B4 B5
   Succs (1): B1

 [B4]
   1: ch2 <= '6'
   T: ([B6.1] || ([B5.1] && [B4.1])) ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B5]
   1: ch1 == '2'
   T: [B5.1] && ...
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: ch1 == '1'
   T: [B6.1] || ...
   Preds (1): B7
   Succs (2): B2 B5

 [B0 (EXIT)]
   Preds (1): B1

function-decl: numDecodings numDecodings
param-decl: int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: new int
   2: int *dp = new int;
   3: int result;
   4: delete [] dp
   5: return result;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int s;
   2: argc > 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/leetcode/algorithms/cpp/balancedBinaryTree/balancedBinaryTree.cpp

function-decl: Solution::isBalanced isBalanced
param-decl: int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int height = 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Solution::isBalancedUtil isBalancedUtil
param-decl: int *; int &; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: [B4.5] ? [B2.1] : [B3.1]
   2: height = ([B1.1]) + 1
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: lh
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: rh
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: int lh = 0;
   2: int rh = 0;
   3: _Bool isLeft;
   4: _Bool isRight;
   5: lh > rh
   T: [B4.5] ? ... : ...
   Preds (1): B6
   Succs (2): B2 B3

 [B5]
   1: height = 0
   2: return true;
   Preds (1): B6
   Succs (1): B0

 [B6]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B5 B4

 [B0 (EXIT)]
   Preds (2): B1 B5


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Borwein's Algorithm/borwein_algorithm.cpp

function-decl: quad_convergence quad_convergence
param-decl: int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return p0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: n++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: ld sa;
   2: ld an = 0.5 * (sa + 1. / sa);
   3: ld bn = (1. + b0) * sa / (a0 + b0);
   4: ld pn = (1. + an) * p0 * bn / (1. + bn);
   5: a0 = an
   6: b0 = bn
   7: p0 = pn
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: n < T
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: ld a0;
   2: ld b0 = 0.;
   3: ld p0 = 2. + a0;
   4: int n = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/BinaryGCD/BinaryGCD.cpp

function-decl: gcd gcd
param-decl: int; int; 

 [B19 (ENTRY)]
   Succs (1): B18

 [B1]
   1: return a << powerOf2;
   Preds (1): B7
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B7

 [B3]
   1: b -= a
   Preds (1): B6
   Succs (1): B2

 [B4]
   Preds (1): B5
   Succs (1): B6

 [B5]
   1: b >>= 1
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: (b & 1) == 0
   T: while [B6.1]
   Preds (2): B4 B7
   Succs (2): B5 B3

 [B7]
   1: b != 0
   T: while [B7.1]
   Preds (2): B2 B10
   Succs (2): B6 B1

 [B8]
   Preds (1): B9
   Succs (1): B10

 [B9]
   1: a >>= 1
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: (a & 1) == 0
   T: while [B10.1]
   Preds (2): B8 B13
   Succs (2): B9 B7

 [B11]
   1: powerOf2++
   Preds (1): B12
   Succs (1): B13

 [B12]
   1: a >>= 1
   2: b >>= 1
   Preds (1): B13
   Succs (1): B11

 [B13]
   1: ((a | b) & 1) == 0
   T: for (...; [B13.1]; ...)
   Preds (2): B11 B14
   Succs (2): B12 B10

 [B14]
   1: int powerOf2;
   2: powerOf2 = 0
   Preds (1): B16
   Succs (1): B13

 [B15]
   1: return a;
   Preds (1): B16
   Succs (1): B0

 [B16]
   1: b == 0
   T: if [B16.1]
   Preds (1): B18
   Succs (2): B15 B14

 [B17]
   1: return b;
   Preds (1): B18
   Succs (1): B0

 [B18]
   1: a == 0
   T: if [B18.1]
   Preds (1): B19
   Succs (2): B17 B16

 [B0 (EXIT)]
   Preds (3): B1 B15 B17

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/PrimalityTests/isPrimeFermat.cpp

function-decl: power power
param-decl: int; unsigned int; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return res;
   Preds (1): B6
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B6

 [B3]
   1: n = n >> 1
   2: a = (a * a) % p
   Preds (2): B4 B5
   Succs (1): B2

 [B4]
   1: res = (res * a) % p
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: n & 1 (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: n > 0
   T: while [B6.1]
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: int res = 1;
   2: a = a % p
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: isPrime isPrime
param-decl: unsigned int; int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: return true;
   Preds (1): B6
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B6

 [B3]
   1: k--
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: return false;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: int a;
   2: power(a, n - 1, n)
   3: [B5.2] != 1
   T: if [B5.3]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: k > 0
   T: while [B6.1]
   Preds (2): B2 B8
   Succs (2): B5 B1

 [B7]
   1: return true;
   Preds (1): B8
   Succs (1): B0

 [B8]
   1: n <= 3
   T: if [B8.1]
   Preds (1): B10
   Succs (2): B7 B6

 [B9]
   1: return false;
   Preds (2): B10 B11
   Succs (1): B0

 [B10]
   1: n == 4
   T: if [B11.1] || [B10.1]
   Preds (1): B11
   Succs (2): B9 B8

 [B11]
   1: n <= 1
   T: [B11.1] || ...
   Preds (1): B12
   Succs (2): B9 B10

 [B0 (EXIT)]
   Preds (4): B1 B4 B7 B9


filename: /Users/yingcao/re/DataSets/Algorithms/C++/PrimalityTests/isPrimeMillerRabin.cpp

function-decl: power power
param-decl: int; unsigned int; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return res;
   Preds (1): B6
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B6

 [B3]
   1: y = y >> 1
   2: x = (x * x) % p
   Preds (2): B4 B5
   Succs (1): B2

 [B4]
   1: res = (res * x) % p
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: y & 1 (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: y > 0
   T: while [B6.1]
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: int res = 1;
   2: x = x % p
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: miillerTest miillerTest
param-decl: int; int; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: return false;
   Preds (1): B7
   Succs (1): B0

 [B2]
   Preds (1): B4
   Succs (1): B7

 [B3]
   1: return true;
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: x == n - 1
   T: if [B4.1]
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   1: return false;
   Preds (1): B6
   Succs (1): B0

 [B6]
   1: x = (x * x) % n
   2: d *= 2
   3: x == 1
   T: if [B6.3]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: d != n - 1
   T: while [B7.1]
   Preds (2): B2 B9
   Succs (2): B6 B1

 [B8]
   1: return true;
   Preds (2): B9 B10
   Succs (1): B0

 [B9]
   1: x == n - 1
   T: if [B10.4] || [B9.1]
   Preds (1): B10
   Succs (2): B8 B7

 [B10]
   1: int a;
   2: power(a, d, n)
   3: int x = power(a, d, n);
   4: x == 1
   T: [B10.4] || ...
   Preds (1): B11
   Succs (2): B8 B9

 [B0 (EXIT)]
   Preds (4): B1 B3 B5 B8

function-decl: isPrime isPrime
param-decl: int; int; 

 [B16 (ENTRY)]
   Succs (1): B15

 [B1]
   1: return true;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B4
   Succs (1): B5

 [B3]
   1: return false;
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: miillerTest(d, n)
   2: [B4.1] == false
   T: if [B4.2]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < k
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int i = 0;
   Preds (1): B9
   Succs (1): B5

 [B7]
   Preds (1): B8
   Succs (1): B9

 [B8]
   1: d /= 2
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: d % 2 == 0
   T: while [B9.1]
   Preds (2): B7 B10
   Succs (2): B8 B6

 [B10]
   1: int d = n - 1;
   Preds (1): B12
   Succs (1): B9

 [B11]
   1: return true;
   Preds (1): B12
   Succs (1): B0

 [B12]
   1: n <= 3
   T: if [B12.1]
   Preds (1): B14
   Succs (2): B11 B10

 [B13]
   1: return false;
   Preds (2): B14 B15
   Succs (1): B0

 [B14]
   1: n == 4
   T: if [B15.1] || [B14.1]
   Preds (1): B15
   Succs (2): B13 B12

 [B15]
   1: n <= 1
   T: [B15.1] || ...
   Preds (1): B16
   Succs (2): B13 B14

 [B0 (EXIT)]
   Preds (4): B1 B3 B11 B13


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Ternary Search/TernarySearch.cpp

function-decl: ternary_search ternary_search
param-decl: int; int; int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: return -1;
   Preds (1): B11
   Succs (1): B0

 [B2]
   1: ternary_search(mid1 + 1, mid2 - 1, x)
   2: return [B2.1];
   Preds (1): B4
   Succs (1): B0

 [B3]
   1: ternary_search(mid2 + 1, r, x)
   2: return [B3.1];
   Preds (1): B4
   Succs (1): B0

 [B4]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   1: ternary_search(l, mid1 - 1, x)
   2: return [B5.1];
   Preds (1): B6
   Succs (1): B0

 [B6]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B5 B4

 [B7]
   1: return mid2;
   Preds (1): B8
   Succs (1): B0

 [B8]
   T: if <null expr>
   Preds (1): B10
   Succs (2): B7 B6

 [B9]
   1: return mid1;
   Preds (1): B10
   Succs (1): B0

 [B10]
   1: int mid1 = l + (r - l) / 3;
   2: int mid2 = r - (r - l) / 3;
   T: if <null expr>
   Preds (1): B11
   Succs (2): B9 B8

 [B11]
   1: r >= l
   T: if [B11.1]
   Preds (1): B12
   Succs (2): B10 B1

 [B0 (EXIT)]
   Preds (6): B1 B2 B3 B5 B7 B9


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Topological Sort/topo_sort.cpp

function-decl: Graph::Graph Graph
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->V = V
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Graph::addEdge addEdge
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Graph::dfs_explore dfs_explore
param-decl: _Bool *; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: visited[start] = true
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Graph::dfs dfs
param-decl: 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: ++i
   Preds (2): B2 B3
   Succs (1): B4

 [B2]
   1: this->dfs_explore(visited, i)
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: !visited[i]
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: i < this->V
   T: for (...; [B4.1]; ...)
   Preds (2): B1 B5
   Succs (2): B3 B0

 [B5]
   1: int i = 0;
   Preds (1): B8
   Succs (1): B4

 [B6]
   1: i++
   Preds (1): B7
   Succs (1): B8

 [B7]
   1: visited[i] = false
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: i < this->V
   T: for (...; [B8.1]; ...)
   Preds (2): B6 B9
   Succs (2): B7 B5

 [B9]
   1: new _Bool [this->V]
   2: _Bool *visited = new _Bool [this->V];
   3: int i = 0;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B4

function-decl: Graph::topo_sort topo_sort
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->dfs()
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: 8 (CXXConstructExpr, class Graph)
   2: class Graph g(8);
   3: g.addEdge(0, 1)
   4: g.addEdge(0, 2)
   5: g.addEdge(1, 4)
   6: g.addEdge(4, 2)
   7: g.addEdge(4, 5)
   8: g.addEdge(2, 3)
   9: g.addEdge(3, 5)
  10: g.addEdge(2, 6)
  11: g.addEdge(5, 6)
  12: g.addEdge(7, 5)
  13: g.topo_sort()
  14: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Linear Search/LinearSearch.cpp

function-decl: search search
param-decl: int *; int; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: return -1;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B4
   Succs (1): B5

 [B3]
   1: return i;
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: arr[i] == x
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < n
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int i;
   2: i = 0
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (2): B1 B3


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Depth First Search/DFS(recursive).cpp

function-decl: dfs dfs
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: visited[source] = true
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: int source;
   2: dfs(source)
   3: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: int u;
   2: int v;
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < edges
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int vertices;
   2: int edges;
   3: int i = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Depth First Search/DFS(iterative).cpp

function-decl: dfs dfs
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: visited[source] = true
   2: int q;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: int source;
   2: dfs(source)
   3: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: int u;
   2: int v;
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < edges
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int vertices;
   2: int edges;
   3: int i = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/BubbleSort/Bubble_Sort.cpp

function-decl: swap swap
param-decl: int *; int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int temp = *xp;
   2: *xp = *yp
   3: *yp = temp
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: bubbleSort bubbleSort
param-decl: int *; int; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: i++
   Preds (1): B3
   Succs (1): B9

 [B2]
   T: break;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: swapped == false
   T: if [B3.1]
   Preds (1): B7
   Succs (2): B2 B1

 [B4]
   1: j++
   Preds (2): B5 B6
   Succs (1): B7

 [B5]
   1: swap(&arr[j], &arr[j + 1])
   2: swapped = true
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: arr[j] > arr[j + 1]
   T: if [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: j < n - i - 1
   T: for (...; [B7.1]; ...)
   Preds (2): B4 B8
   Succs (2): B6 B3

 [B8]
   1: swapped = false
   2: j = 0
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: i < n - 1
   T: for (...; [B9.1]; ...)
   Preds (2): B1 B10
   Succs (2): B8 B0

 [B10]
   1: int i;
   2: int j;
   3: _Bool swapped;
   4: i = 0
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (2): B2 B9

function-decl: printArray printArray
param-decl: int *; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int i;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int arr[] = {64, 34, 25, 12, 22, 11, 90};
   2: int n = sizeof (arr) / sizeof (arr[0]);
   3: bubbleSort(arr, n)
   4: printArray(arr, n)
   5: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Cycle Sort/CycleSort.cpp

function-decl: cycleSort cycleSort
param-decl: int *; int; 

 [B28 (ENTRY)]
   Succs (1): B27

 [B1]
   1: cycle_start++
   Preds (2): B13 B19
   Succs (1): B26

 [B2]
   Preds (2): B3 B4
   Succs (1): B13

 [B3]
   1: writes++
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: item != arr[pos]
   T: if [B4.1]
   Preds (1): B7
   Succs (2): B3 B2

 [B5]
   Preds (1): B6
   Succs (1): B7

 [B6]
   1: pos += 1
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: item == arr[pos]
   T: while [B7.1]
   Preds (2): B5 B11
   Succs (2): B6 B4

 [B8]
   1: i++
   Preds (2): B9 B10
   Succs (1): B11

 [B9]
   1: pos += 1
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: arr[i] < item
   T: if [B10.1]
   Preds (1): B11
   Succs (2): B9 B8

 [B11]
   1: i < n
   T: for (...; [B11.1]; ...)
   Preds (2): B8 B12
   Succs (2): B10 B7

 [B12]
   1: pos = cycle_start
   2: int i = cycle_start + 1;
   Preds (1): B13
   Succs (1): B11

 [B13]
   1: pos != cycle_start
   T: while [B13.1]
   Preds (3): B2 B14 B15
   Succs (2): B12 B1

 [B14]
   1: writes++
   Preds (1): B15
   Succs (1): B13

 [B15]
   1: pos != cycle_start
   T: if [B15.1]
   Preds (1): B18
   Succs (2): B14 B13

 [B16]
   Preds (1): B17
   Succs (1): B18

 [B17]
   1: pos += 1
   Preds (1): B18
   Succs (1): B16

 [B18]
   1: item == arr[pos]
   T: while [B18.1]
   Preds (2): B16 B20
   Succs (2): B17 B15

 [B19]
   T: continue;
   Preds (1): B20
   Succs (1): B1

 [B20]
   1: pos == cycle_start
   T: if [B20.1]
   Preds (1): B24
   Succs (2): B19 B18

 [B21]
   1: i++
   Preds (2): B22 B23
   Succs (1): B24

 [B22]
   1: pos++
   Preds (1): B23
   Succs (1): B21

 [B23]
   1: arr[i] < item
   T: if [B23.1]
   Preds (1): B24
   Succs (2): B22 B21

 [B24]
   1: i < n
   T: for (...; [B24.1]; ...)
   Preds (2): B21 B25
   Succs (2): B23 B20

 [B25]
   1: int item = arr[cycle_start];
   2: int pos = cycle_start;
   3: int i = cycle_start + 1;
   Preds (1): B26
   Succs (1): B24

 [B26]
   1: cycle_start <= n - 2
   T: for (...; [B26.1]; ...)
   Preds (2): B1 B27
   Succs (2): B25 B0

 [B27]
   1: int writes = 0;
   2: int cycle_start = 0;
   Preds (1): B28
   Succs (1): B26

 [B0 (EXIT)]
   Preds (1): B26

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int arr[] = {1, 8, 3, 9, 10, 10, 2, 4};
   2: int n = sizeof (arr) / sizeof (arr[0]);
   3: cycleSort(arr, n)
   4: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Fisher Yates Shuffle/FisherYatesShuffle.cpp

function-decl: shuffle shuffle
param-decl: int &; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: i--
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: int r;
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: i > 0
   T: for (...; [B3.1]; ...)
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: int N;
   2: int i = N - 1;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B3

function-decl: main main
param-decl: 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: k++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: k < 5
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int a;
   2: int k = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Heap Sort/HeapSort.cpp

function-decl: heapify heapify
param-decl: int *; int; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: heapify(arr, n, largest)
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: largest != i
   T: if [B2.1]
   Preds (3): B3 B4 B5
   Succs (2): B1 B0

 [B3]
   1: largest = r
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: arr[r] > arr[largest]
   T: if [B5.1] && [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: r < n
   T: [B5.1] && ...
   Preds (3): B6 B7 B8
   Succs (2): B4 B2

 [B6]
   1: largest = l
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: arr[l] > arr[largest]
   T: if [B8.4] && [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: int largest = i;
   2: int l = 2 * i + 1;
   3: int r = 2 * i + 2;
   4: l < n
   T: [B8.4] && ...
   Preds (1): B9
   Succs (2): B7 B5

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: heapSort heapSort
param-decl: int *; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: i--
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: heapify(arr, i, 0)
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: i >= 0
   T: for (...; [B3.1]; ...)
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: int i = n - 1;
   Preds (1): B7
   Succs (1): B3

 [B5]
   1: i--
   Preds (1): B6
   Succs (1): B7

 [B6]
   1: heapify(arr, n, i)
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: i >= 0
   T: for (...; [B7.1]; ...)
   Preds (2): B5 B8
   Succs (2): B6 B4

 [B8]
   1: int i = n / 2 - 1;
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (1): B3

function-decl: printArray printArray
param-decl: int *; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int arr[] = {12, 11, 13, 5, 6, 7};
   2: int n = sizeof (arr) / sizeof (arr[0]);
   3: heapSort(arr, n)
   4: printArray(arr, n)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Radix Sort/RadixSort.cpp

function-decl: radix_test::radix_test radix_test
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: radix_test::operator() operator()
param-decl: int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return !(value & (1 << this->bit));
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return value < 0;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: this->bit == 31
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: lsd_radix_sort lsd_radix_sort
param-decl: int *; int *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: ++lsb
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: lsb < 32
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int lsb = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: msd_radix_sort msd_radix_sort
param-decl: int *; int *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int *mid;
   2: msb--
   3: msd_radix_sort(first, mid, msb)
   4: msd_radix_sort(mid, last, msb)
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: msb >= 0
   T: if [B3.1] && [B2.1]
   Preds (1): B3
   Succs (2): B1 B0

 [B3]
   1: first != last
   T: [B3.1] && ...
   Preds (1): B4
   Succs (2): B2 B0

 [B0 (EXIT)]
   Preds (3): B1 B2 B3

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int data[] = {170, 45, 75, -90, -802, 24, 2, 66};
   2: lsd_radix_sort(data, data + 8)
   3: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Longest Increasing Subsequence/LIS.cpp

function-decl: LIS LIS
param-decl: int; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: int i = longest_index;
   Preds (1): B10
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B8
   Succs (1): B10

 [B3]
   1: j++
   Preds (4): B4 B5 B6 B7
   Succs (1): B8

 [B4]
   1: longest_index = i
   Preds (1): B5
   Succs (1): B3

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B5 B3

 [B7]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B3

 [B8]
   1: j < i
   T: for (...; [B8.1]; ...)
   Preds (2): B3 B9
   Succs (2): B7 B2

 [B9]
   1: int j = 0;
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: i < input_length
   T: for (...; [B10.1]; ...)
   Preds (2): B2 B11
   Succs (2): B9 B1

 [B11]
   1: int input_length;
   2: int longest_length = 1;
   3: int longest_index = 0;
   4: int output;
   5: int i = 1;
   Preds (1): B12
   Succs (1): B10

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a;
   2: int b;
   3: int c;
   4: int d;
   5: int e;
   6: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Edit distance/edit_distance_backtracking.cpp

function-decl: Alignment::insC insC
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return 4;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Alignment::delC delC
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return 4;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Alignment::modC modC
param-decl: char; char; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 3;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: fr == to
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: Alignment::Alignment Alignment
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Alignment::rec rec
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Alignment::form_array form_array
param-decl: 

 [B13 (ENTRY)]
   Succs (1): B12

 [B1]
   1: i++
   Preds (1): B3
   Succs (1): B5

 [B2]
   1: j++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: j <= this->syL
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int j = 1;
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: i <= this->sxL
   T: for (...; [B5.1]; ...)
   Preds (2): B1 B6
   Succs (2): B4 B0

 [B6]
   1: int i = 1;
   Preds (1): B8
   Succs (1): B5

 [B7]
   1: i++
   Preds (1): B8
   Succs (1): B8

 [B8]
   1: i <= this->syL
   T: for (...; [B8.1]; ...)
   Preds (2): B7 B9
   Succs (2): B7 B6

 [B9]
   1: int i = 0;
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: i++
   Preds (1): B11
   Succs (1): B11

 [B11]
   1: i <= this->sxL
   T: for (...; [B11.1]; ...)
   Preds (2): B10 B12
   Succs (2): B10 B9

 [B12]
   1: int i = 0;
   Preds (1): B13
   Succs (1): B11

 [B0 (EXIT)]
   Preds (1): B5

function-decl: Alignment::trace_back trace_back
param-decl: int; int; 

 [B20 (ENTRY)]
   Succs (1): B19

 [B1]
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: j--
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: j (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: while [B3.1]
   Preds (2): B1 B7
   Succs (2): B2 B0

 [B4]
   Preds (1): B5
   Succs (1): B6

 [B5]
   1: i--
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: i (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: while [B6.1]
   Preds (2): B4 B7
   Succs (2): B5 B0

 [B7]
   1: i != 0
   T: if [B7.1]
   Preds (1): B16
   Succs (2): B6 B3

 [B8]
   Preds (5): B9 B10 B11 B12 B14
   Succs (1): B19

 [B9]
   1: j -= 1
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: (j - 1) >= 0
   T: if [B11.1] && [B10.1]
   Preds (1): B11
   Succs (2): B9 B8

 [B11]
   1: i >= 0
   T: [B11.1] && ...
   Preds (1): B13
   Succs (2): B10 B8

 [B12]
   1: i -= 1
   Preds (1): B13
   Succs (1): B8

 [B13]
   T: if <null expr>
   Preds (1): B15
   Succs (2): B12 B11

 [B14]
   1: i--
   2: j--
   3: ... , [B14.2]
   Preds (1): B15
   Succs (1): B8

 [B15]
   T: if <null expr>
   Preds (1): B17
   Succs (2): B14 B13

 [B16]
   T: break;
   Preds (2): B17 B18
   Succs (1): B7

 [B17]
   1: j == 0
   T: if [B18.1] || [B17.1]
   Preds (1): B18
   Succs (2): B16 B15

 [B18]
   1: i == 0
   T: [B18.1] || ...
   Preds (1): B19
   Succs (2): B16 B17

 [B19]
   1: true
   T: while [B19.1]
   Preds (2): B8 B20
   Succs (2): B18 NULL

 [B0 (EXIT)]
   Preds (2): B3 B6

function-decl: Alignment::alignst alignst
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Alignment::kyc kyc
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return this->cost;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int sx;
   2: class Alignment dyn;
   3: dyn.form_array()
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/String to token/str_tok.cpp

function-decl: main main
param-decl: 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return (0);
   Preds (1): B3
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: tok != 0
   T: while [B3.1]
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: char gfg[100] = " Hacktober fest by Github";
   2: const char s[4] = "-";
   3: char *tok;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Tarjan's Offline LCA/LCA.cpp

function-decl: newNode newNode
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1:  (CXXConstructExpr, struct Node)
   2: new struct Node
   3: struct Node *node = new struct Node;
   4: node->data = data
   5: return (node);
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: makeSet makeSet
param-decl: struct subset *; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: subsets[i].color = 1
   2: subsets[i].parent = i
   3: subsets[i].rank = 0
   4: return;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (2): B3 B4
   Succs (1): B0

 [B3]
   1: i > 5
   T: if [B4.1] || [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: i < 1
   T: [B4.1] || ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: findSet findSet
param-decl: struct subset *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return subsets[i].parent;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: findSet(subsets, subsets[i].parent)
   2: subsets[i].parent = [B2.1]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: subsets[i].parent != i
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: unionSet unionSet
param-decl: struct subset *; int; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: subsets[yroot].parent = xroot
   2: (subsets[xroot].rank)++
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: subsets[yroot].parent = xroot
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: subsets[xroot].rank > subsets[yroot].rank
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: subsets[xroot].parent = yroot
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: findSet(subsets, x)
   2: int xroot = findSet(subsets, x);
   3: findSet(subsets, y)
   4: int yroot = findSet(subsets, y);
   5: subsets[xroot].rank < subsets[yroot].rank
   T: if [B5.5]
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (3): B1 B2 B4

function-decl: lcaWalk lcaWalk
param-decl: int; struct Query *; int; struct subset *; 

 [B15 (ENTRY)]
   Succs (1): B14

 [B1]
   1: return;
   Preds (1): B9
   Succs (1): B0

 [B2]
   1: i++
   Preds (5): B3 B4 B5 B6 B7
   Succs (1): B9

 [B3]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: subsets[q[i].L].color == 2
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: q[i].R == u
   T: if [B5.1]
   Preds (1): B8
   Succs (2): B4 B2

 [B6]
   Preds (1): B7
   Succs (1): B2

 [B7]
   1: subsets[q[i].R].color == 2
   T: if [B7.1]
   Preds (1): B8
   Succs (2): B6 B2

 [B8]
   1: q[i].L == u
   T: if [B8.1]
   Preds (1): B9
   Succs (2): B7 B5

 [B9]
   1: i < m
   T: for (...; [B9.1]; ...)
   Preds (2): B2 B10
   Succs (2): B8 B1

 [B10]
   1: subsets[u].color = 2
   2: int i = 0;
   Preds (1): B13
   Succs (1): B9

 [B11]
   Preds (1): B12
   Succs (1): B13

 [B12]
   1: lcaWalk(child, q, m, subsets)
   2: unionSet(subsets, u, child)
   3: findSet(subsets, u)
   4: subsets[[B12.3]].ancestor = u
   5: child = subsets[child].sibling
   Preds (1): B13
   Succs (1): B11

 [B13]
   1: child != 0
   T: while [B13.1]
   Preds (2): B11 B14
   Succs (2): B12 B10

 [B14]
   1: makeSet(subsets, u)
   2: findSet(subsets, u)
   3: subsets[[B14.2]].ancestor = u
   4: int child = subsets[u].child;
   Preds (1): B15
   Succs (1): B13

 [B0 (EXIT)]
   Preds (1): B1

function-decl: preprocess preprocess
param-decl: struct Node *; struct subset *; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: preprocess(node->right, subsets)
   Preds (4): B2 B3 B5 B6
   Succs (1): B0

 [B2]
   1: subsets[node->data].child = node->right->data
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: subsets[node->data].child = node->left->data
   Preds (1): B4
   Succs (1): B1

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B1

 [B6]
   1: subsets[node->data].child = node->left->data
   2: subsets[node->left->data].sibling = node->right->data
   Preds (1): B7
   Succs (1): B1

 [B7]
   1: preprocess(node->left, subsets)
   T: if <null expr>
   Preds (1): B9
   Succs (2): B6 B5

 [B8]
   1: return;
   Preds (1): B9
   Succs (1): B0

 [B9]
   T: if <null expr>
   Preds (1): B10
   Succs (2): B8 B7

 [B0 (EXIT)]
   Preds (2): B1 B8

function-decl: initialise initialise
param-decl: struct subset *; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: subsets[i].color = 1
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i <= 5
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int i = 1;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printLCAs printLCAs
param-decl: struct Node *; struct Query *; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1:  (CXXConstructExpr, struct subset [6])
   2: new struct subset [5 + 1]
   3: struct subset *subsets = new struct subset [5 + 1];
   4: initialise(subsets)
   5: preprocess(root, subsets)
   6: lcaWalk(root->data, q, m, subsets)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: newNode(1)
   2: struct Node *root = newNode(1);
   3: newNode(2)
   4: root->left = [B1.3]
   5: newNode(3)
   6: root->right = [B1.5]
   7: newNode(4)
   8: root->left->left = [B1.7]
   9: newNode(5)
  10: root->left->right = [B1.9]
  11: struct Query q[] = {{5, 4}, {1, 3}, {2, 3}};
  12: int m = sizeof (q) / sizeof (q[0]);
  13: printLCAs(root, q, m)
  14: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Coin Change/CoinChange.cpp

function-decl: num_coins_recursive num_coins_recursive
param-decl: int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: int best = 1.0E+6;
   2: value[x] = best
   3: ready[x] = true
   4: return best;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return value[x];
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: ready[x] (ImplicitCastExpr, LValueToRValue, _Bool)
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return 0;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: x == 0
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return 1.0E+6;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: x < 0
   T: if [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (4): B1 B2 B4 B6

function-decl: num_coins_iterative num_coins_iterative
param-decl: int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return value[x];
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: value[i] = 1.0E+6
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i <= x
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: value[0] = 0
   2: int i = 1;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1

function-decl: num_ways num_ways
param-decl: int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return countof[x];
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: countof[i] = 0
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i <= x
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: countof[0] = 1
   2: int i = 1;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i <= sum
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int c;
   2: int sum = 5;
   3: new _Bool [23]
   4: ready = [B4.3]
   5: new int [23]
   6: value = [B4.5]
   7: new int [23]
   8: countof = [B4.7]
   9: int i = 0;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/BinarySearch/BinarySearch-(iterative).cpp

function-decl: binarySearch binarySearch
param-decl: int; int; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: return -1;
   Preds (1): B8
   Succs (1): B0

 [B2]
   Preds (2): B4 B6
   Succs (1): B8

 [B3]
   1: return mid;
   Preds (1): B5
   Succs (1): B0

 [B4]
   1: high = mid - 1
   Preds (1): B5
   Succs (1): B2

 [B5]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: low = mid + 1
   Preds (1): B7
   Succs (1): B2

 [B7]
   1: int mid = low + (high - low) / 2;
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: low <= high
   T: while [B8.1]
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B0 (EXIT)]
   Preds (2): B1 B3


filename: /Users/yingcao/re/DataSets/Algorithms/C++/BinarySearch/BinarySearch.c

function-decl: main main
param-decl: 

 [B17 (ENTRY)]
   Succs (1): B16

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: printf("Not found!", sr)
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: f > lt
   T: if [B3.1]
   Preds (2): B7 B11
   Succs (2): B2 B1

 [B4]
   Preds (1): B5
   Succs (1): B11

 [B5]
   1: mid = (f + lt) / 2
   Preds (2): B6 B9
   Succs (1): B4

 [B6]
   1: lt = mid - 1
   Preds (1): B8
   Succs (1): B5

 [B7]
   1: printf("%d found at location %d.\n", sr, mid + 1)
   T: break;
   Preds (1): B8
   Succs (1): B3

 [B8]
   1: array[mid] == sr
   T: if [B8.1]
   Preds (1): B10
   Succs (2): B7 B6

 [B9]
   1: f = mid + 1
   Preds (1): B10
   Succs (1): B5

 [B10]
   1: array[mid] < sr
   T: if [B10.1]
   Preds (1): B11
   Succs (2): B9 B8

 [B11]
   1: f <= lt
   T: while [B11.1]
   Preds (2): B4 B12
   Succs (2): B10 B3

 [B12]
   1: printf("Enter value to find\n")
   2: scanf("%d", &sr)
   3: f = 0
   4: lt = n - 1
   5: mid = (f + lt) / 2
   Preds (1): B15
   Succs (1): B11

 [B13]
   1: c++
   Preds (1): B14
   Succs (1): B15

 [B14]
   1: scanf("%d", &array[c])
   Preds (1): B15
   Succs (1): B13

 [B15]
   1: c < n
   T: for (...; [B15.1]; ...)
   Preds (2): B13 B16
   Succs (2): B14 B12

 [B16]
   1: int c;
   2: int f;
   3: int lt;
   4: int mid;
   5: int n;
   6: int sr;
   7: int array[100];
   8: printf("Enter number of elements\n")
   9: scanf("%d", &n)
  10: printf("Enter %d integers\n", n)
  11: c = 0
   Preds (1): B17
   Succs (1): B15

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/BinarySearch/BinarySearch - (recursive).cpp

function-decl: binarySearch binarySearch
param-decl: int; int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return -1;
   Preds (2): B3 B4
   Succs (1): B0

 [B2]
   1: return mid;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: int mid = low + (high - low) / 2;
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: low <= high
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B1

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Xor Swap/xorswap.cpp

function-decl: xorswap xorswap
param-decl: int &; int &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: a ^= b
   2: b ^= a
   3: a ^= b
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; const char **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a = 10;
   2: int b = 5;
   3: xorswap(a, b)
   4: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Sieve of Eratosthenes/SieveofEratosthenes.cpp

function-decl: sieve sieve
param-decl: int; 

 [B13 (ENTRY)]
   Succs (1): B12

 [B1]
   1: ++i
   Preds (2): B4 B6
   Succs (1): B7

 [B2]
   1: j += i
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: isPrime[j] = false
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: j <= N
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int j = i * i;
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: isPrime[i] == true
   T: if [B6.1]
   Preds (1): B7
   Succs (2): B5 B1

 [B7]
   1: i * i <= N
   T: for (...; [B7.1]; ...)
   Preds (2): B1 B8
   Succs (2): B6 B0

 [B8]
   1: isPrime[0] = false
   2: isPrime[1] = false
   3: int i = 2;
   Preds (1): B11
   Succs (1): B7

 [B9]
   1: ++i
   Preds (1): B10
   Succs (1): B11

 [B10]
   1: isPrime[i] = true
   Preds (1): B11
   Succs (1): B9

 [B11]
   1: i <= N
   T: for (...; [B11.1]; ...)
   Preds (2): B9 B12
   Succs (2): B10 B8

 [B12]
   1: N + 1
   2: _Bool isPrime[N + 1];
   3: int i = 0;
   Preds (1): B13
   Succs (1): B11

 [B0 (EXIT)]
   Preds (1): B7


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Johnson Algorithm/Johnson Algorothm.cpp

function-decl: min min
param-decl: int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return b;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return a;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: a < b
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: int; char **; 

 [B31 (ENTRY)]
   Succs (1): B30

 [B1]
   1: return 0;
   Preds (1): B6
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B4
   Succs (1): B6

 [B3]
   1: j++
   Preds (1): B4
   Succs (1): B4

 [B4]
   1: j <= n
   T: for (...; [B4.1]; ...)
   Preds (2): B3 B5
   Succs (2): B3 B2

 [B5]
   1: j = 1
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: i <= n
   T: for (...; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: i = 1
   Preds (1): B16
   Succs (1): B6

 [B8]
   1: k++
   Preds (1): B14
   Succs (1): B16

 [B9]
   1: i++
   Preds (1): B12
   Succs (1): B14

 [B10]
   1: j++
   Preds (1): B11
   Succs (1): B12

 [B11]
   1: min(a[i][j], a[i][k] + a[k][j])
   2: a[i][j] = [B11.1]
   Preds (1): B12
   Succs (1): B10

 [B12]
   1: j <= n
   T: for (...; [B12.1]; ...)
   Preds (2): B10 B13
   Succs (2): B11 B9

 [B13]
   1: j = 1
   Preds (1): B14
   Succs (1): B12

 [B14]
   1: i <= n
   T: for (...; [B14.1]; ...)
   Preds (2): B9 B15
   Succs (2): B13 B8

 [B15]
   1: i = 1
   Preds (1): B16
   Succs (1): B14

 [B16]
   1: k <= n
   T: for (...; [B16.1]; ...)
   Preds (2): B8 B17
   Succs (2): B15 B7

 [B17]
   1: k = 1
   Preds (1): B25
   Succs (1): B16

 [B18]
   1: i++
   Preds (1): B23
   Succs (1): B25

 [B19]
   1: j++
   Preds (3): B20 B21 B22
   Succs (1): B23

 [B20]
   1: a[i][j] = 31999
   Preds (1): B21
   Succs (1): B19

 [B21]
   1: i != j
   T: if [B22.1] && [B21.1]
   Preds (1): B22
   Succs (2): B20 B19

 [B22]
   1: a[i][j] == 0
   T: [B22.1] && ...
   Preds (1): B23
   Succs (2): B21 B19

 [B23]
   1: j <= n
   T: for (...; [B23.1]; ...)
   Preds (2): B19 B24
   Succs (2): B22 B18

 [B24]
   1: j = 1
   Preds (1): B25
   Succs (1): B23

 [B25]
   1: i <= n
   T: for (...; [B25.1]; ...)
   Preds (2): B18 B26
   Succs (2): B24 B17

 [B26]
   1: i = 1
   Preds (1): B29
   Succs (1): B25

 [B27]
   1: k++
   Preds (1): B28
   Succs (1): B29

 [B28]
   1: a[i][j] = cost[i][j] = c
   Preds (1): B29
   Succs (1): B27

 [B29]
   1: k <= m
   T: for (...; [B29.1]; ...)
   Preds (2): B27 B30
   Succs (2): B28 B26

 [B30]
   1: int n;
   2: int m;
   3: k = 1
   Preds (1): B31
   Succs (1): B29

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Breadth First Search/BFS.cpp

function-decl: Graph::Graph Graph
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: this->V = V
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Graph::addEdge addEdge
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Graph::BFS BFS
param-decl: int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: int queue;
   2: visited[s] = true
   3: int i;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: visited[i] = false
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < this->V
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: new _Bool [this->V]
   2: _Bool *visited = new _Bool [this->V];
   3: int i = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: 4 (CXXConstructExpr, class Graph)
   2: class Graph g(4);
   3: g.addEdge(0, 1)
   4: g.addEdge(0, 2)
   5: g.addEdge(1, 2)
   6: g.addEdge(2, 0)
   7: g.addEdge(2, 3)
   8: g.addEdge(3, 3)
   9: g.BFS(2)
  10: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Prufer Code/PruferCode.cpp

function-decl: main main
param-decl: 

 [B23 (ENTRY)]
   Succs (1): B22

 [B1]
   1: return 0;
   Preds (1): B13
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B13

 [B3]
   1: deg[edge[x][0]]--
   2: deg[edge[x][1]]--
   Preds (1): B11
   Succs (1): B2

 [B4]
   1: j++
   Preds (3): B5 B6 B7
   Succs (1): B11

 [B5]
   1: min = edge[j][1]
   2: x = j
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: min > edge[j][1]
   T: if [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: deg[edge[j][1]] == 1
   T: if [B7.1]
   Preds (3): B8 B9 B10
   Succs (2): B6 B4

 [B8]
   1: min = edge[j][0]
   2: x = j
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: min > edge[j][0]
   T: if [B9.1]
   Preds (1): B10
   Succs (2): B8 B7

 [B10]
   1: deg[edge[j][0]] == 1
   T: if [B10.1]
   Preds (1): B11
   Succs (2): B9 B7

 [B11]
   1: j < e
   T: for (...; [B11.1]; ...)
   Preds (2): B4 B12
   Succs (2): B10 B3

 [B12]
   1: min = 10000
   2: j = 0
   Preds (1): B13
   Succs (1): B11

 [B13]
   1: i < v - 2
   T: for (...; [B13.1]; ...)
   Preds (2): B2 B14
   Succs (2): B12 B1

 [B14]
   1: i = 0
   Preds (1): B17
   Succs (1): B13

 [B15]
   1: i++
   Preds (1): B16
   Succs (1): B17

 [B16]
   1: deg[edge[i][0]]++
   2: deg[edge[i][1]]++
   Preds (1): B17
   Succs (1): B15

 [B17]
   1: i < e
   T: for (...; [B17.1]; ...)
   Preds (2): B15 B18
   Succs (2): B16 B14

 [B18]
   1: i = 0
   Preds (1): B21
   Succs (1): B17

 [B19]
   1: i++
   Preds (1): B20
   Succs (1): B21

 [B20]
   1: deg[i] = 0
   Preds (1): B21
   Succs (1): B19

 [B21]
   1: i <= v + 1
   T: for (...; [B21.1]; ...)
   Preds (2): B19 B22
   Succs (2): B20 B18

 [B22]
   1: int i;
   2: int j;
   3: int v;
   4: int e;
   5: int min;
   6: int x;
   7: e = v - 1
   8: v + 1
   9: int deg[v + 1];
  10: e (ImplicitCastExpr, LValueToRValue, int)
  11: int edge[e][2];
  12: i = 0
   Preds (1): B23
   Succs (1): B21

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Fenwick Tree/FenwickTree.cpp

function-decl: sum sum
param-decl: ll *; ll; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return s;
   Preds (1): B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: s += tree[k]
   2: k -= k & (-k)
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: k >= 1
   T: while [B4.1]
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: ll s = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1

function-decl: update update
param-decl: ll *; ll; ll; ll; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: tree[k] += new_val
   2: k += k & (-k)
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: k <= n
   T: while [B3.1]
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: ll new_val = x;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B3

function-decl: gen_tree gen_tree
param-decl: ll *; ll *; ll; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: k++
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: update(tree, arr[k], k, n)
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: k <= n
   T: for (...; [B3.1]; ...)
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: ll k = 1;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B3

function-decl: main main
param-decl: 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < n + 1
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int i = 0;
   Preds (1): B6
   Succs (1): B3

 [B5]
   1: i++
   Preds (1): B6
   Succs (1): B6

 [B6]
   1: i < n + 1
   T: for (...; [B6.1]; ...)
   Preds (2): B5 B7
   Succs (2): B5 B4

 [B7]
   1: ll n;
   2: ll i;
   3: ll j;
   4: ll x;
   5: n = 8
   6: n + 1
   7: ll arr[n + 1];
   8: n + 1
   9: ll tree[n + 1];
  10: int i = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Knuth Morris Prath/KMP.cpp

function-decl: KMPSearch KMPSearch
param-decl: char *; char *; 

 [B13 (ENTRY)]
   Succs (1): B12

 [B1]
   Preds (5): B2 B3 B5 B6 B7
   Succs (1): B11

 [B2]
   1: i = i + 1
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: j = lps[j - 1]
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: j != 0
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: pat[j] != txt[i]
   T: if [B6.1] && [B5.1]
   Preds (1): B6
   Succs (2): B4 B1

 [B6]
   1: i < N
   T: [B6.1] && ...
   Preds (1): B8
   Succs (2): B5 B1

 [B7]
   1: j = lps[j - 1]
   Preds (1): B8
   Succs (1): B1

 [B8]
   1: j == M
   T: if [B8.1]
   Preds (2): B9 B10
   Succs (2): B7 B6

 [B9]
   1: j++
   2: i++
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: pat[j] == txt[i]
   T: if [B10.1]
   Preds (1): B11
   Succs (2): B9 B8

 [B11]
   1: i < N
   T: while [B11.1]
   Preds (2): B1 B12
   Succs (2): B10 B0

 [B12]
   1: int M;
   2: int N;
   3: M (ImplicitCastExpr, LValueToRValue, int)
   4: int lps[M];
   5: computeLPSArray(pat, M, lps)
   6: int i = 0;
   7: int j = 0;
   Preds (1): B13
   Succs (1): B11

 [B0 (EXIT)]
   Preds (1): B11

function-decl: computeLPSArray computeLPSArray
param-decl: char *; int; int *; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   Preds (3): B2 B3 B5
   Succs (1): B7

 [B2]
   1: lps[i] = 0
   2: i++
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: len = lps[len - 1]
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: len != 0
   T: if [B4.1]
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   1: len++
   2: lps[i] = len
   3: i++
   Preds (1): B6
   Succs (1): B1

 [B6]
   1: pat[i] == pat[len]
   T: if [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: i < M
   T: while [B7.1]
   Preds (2): B1 B8
   Succs (2): B6 B0

 [B8]
   1: int len = 0;
   2: lps[0] = 0
   3: int i = 1;
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (1): B7

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: char *txt = "ABABDABACDABABCABAB";
   2: char *pat = "ABABCABAB";
   3: KMPSearch(pat, txt)
   4: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Bubble Sort/bubble_sort.cpp

function-decl: swap swap
param-decl: int *; int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int temp = *a;
   2: *a = *b
   3: *b = temp
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: bubbleSort bubbleSort
param-decl: int *; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: i++
   Preds (1): B5
   Succs (1): B7

 [B2]
   1: j++
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   1: swap(&arr[j], &arr[j + 1])
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: arr[j] > arr[j + 1]
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: j < n - i - 1
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: j = 0
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: i < n - 1
   T: for (...; [B7.1]; ...)
   Preds (2): B1 B8
   Succs (2): B6 B0

 [B8]
   1: int i;
   2: int j;
   3: i = 0
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (1): B7

function-decl: printArray printArray
param-decl: int *; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int i;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: bubbleSort(arr, n)
   2: printArray(arr, n)
   3: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < n
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int arr[100];
   2: int n;
   3: int i = 0;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Insertion Sort/insertion_sort.cpp

function-decl: swap swap
param-decl: int *; int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int t = *a;
   2: *a = *b
   3: *b = t
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: insertion_sort insertion_sort
param-decl: int *; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: i++
   Preds (2): B4 B5
   Succs (1): B7

 [B2]
   Preds (1): B3
   Succs (1): B5

 [B3]
   1: j--
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: a[j - 1] > a[j]
   T: while [B5.1] && [B4.1]
   Preds (1): B5
   Succs (2): B3 B1

 [B5]
   1: j > 0
   T: [B5.1] && ...
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int j = i;
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: i < n
   T: for (...; [B7.1]; ...)
   Preds (2): B1 B8
   Succs (2): B6 B0

 [B8]
   1: int i = 1;
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (1): B7

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int n;
   2: new int [n]
   3: int *a = new int [n];
   4: insertion_sort(a, n)
   5: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Doomsday/doomsday.cpp

function-decl: dayOfWeek dayOfWeek
param-decl: int; int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: ([B4.2]) ? [B2.1] : [B3.1]
   2: y -= [B1.1]
   3: return (y + y / 4 - y / 100 + y / 400 + t[m - 1] + d) % 7;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: 1
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: 0
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};
   2: m < 3
   T: ([B4.2]) ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: int year;
   2: int month;
   3: int day;
   4: int days[7];
   5: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return -1;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: argc != 4
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Merge Sort/MergeSort.cpp

function-decl: Merge Merge
param-decl: int *; int; int; int; 

 [B18 (ENTRY)]
   Succs (1): B17

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: a[i] = temp[i - low]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: i <= high
   T: for (...; [B3.1]; ...)
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: i = low
   Preds (1): B7
   Succs (1): B3

 [B5]
   Preds (1): B6
   Succs (1): B7

 [B6]
   1: temp[k] = a[j]
   2: k++
   3: j++
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: j <= high
   T: while [B7.1]
   Preds (2): B5 B10
   Succs (2): B6 B4

 [B8]
   Preds (1): B9
   Succs (1): B10

 [B9]
   1: temp[k] = a[i]
   2: k++
   3: i++
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: i <= mid
   T: while [B10.1]
   Preds (3): B8 B15 B16
   Succs (2): B9 B7

 [B11]
   Preds (2): B12 B13
   Succs (1): B16

 [B12]
   1: temp[k] = a[j]
   2: k++
   3: j++
   Preds (1): B14
   Succs (1): B11

 [B13]
   1: temp[k] = a[i]
   2: k++
   3: i++
   Preds (1): B14
   Succs (1): B11

 [B14]
   1: a[i] < a[j]
   T: if [B14.1]
   Preds (1): B15
   Succs (2): B13 B12

 [B15]
   1: j <= high
   T: while [B16.1] && [B15.1]
   Preds (1): B16
   Succs (2): B14 B10

 [B16]
   1: i <= mid
   T: [B16.1] && ...
   Preds (2): B11 B17
   Succs (2): B15 B10

 [B17]
   1: int i;
   2: int j;
   3: int k;
   4: high - low + 1
   5: int temp[high - low + 1];
   6: i = low
   7: k = 0
   8: j = mid + 1
   Preds (1): B18
   Succs (1): B16

 [B0 (EXIT)]
   Preds (1): B3

function-decl: MergeSort MergeSort
param-decl: int *; int; int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: mid = (low + high) / 2
   2: MergeSort(a, low, mid)
   3: MergeSort(a, mid + 1, high)
   4: Merge(a, low, high, mid)
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int mid;
   2: low < high
   T: if [B2.2]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: MergeSort(arr, 0, n - 1)
   2: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < n
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int n;
   2: int i;
   3: n (ImplicitCastExpr, LValueToRValue, int)
   4: int arr[n];
   5: i = 0
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Conjugate Gradient/conjugate_gradient.cpp

function-decl: conjugate_gradient conjugate_gradient
param-decl: const int &; const int &; int; 

 [B13 (ENTRY)]
   Succs (1): B12

 [B1]
   Preds (1): B2
   Succs (1): B11

 [B2]
   1: t++
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: i++
   Preds (1): B4
   Succs (1): B4

 [B4]
   1: i < N
   T: for (...; [B4.1]; ...)
   Preds (2): B3 B5
   Succs (2): B3 B2

 [B5]
   1: double beta = rntrn / rtr;
   2: int i = 0;
   Preds (1): B7
   Succs (1): B4

 [B6]
   T: break;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: double rntrn = 0.;
   2: rntrn < 1.0E-10
   T: if [B7.2]
   Preds (1): B9
   Succs (2): B6 B5

 [B8]
   1: i++
   Preds (1): B9
   Succs (1): B9

 [B9]
   1: i < N
   T: for (...; [B9.1]; ...)
   Preds (2): B8 B10
   Succs (2): B8 B7

 [B10]
   1: double rtr = 0.;
   2: double ptAp = 0.;
   3: double alpha = rtr / (ptAp + 1.0E-10);
   4: int i = 0;
   Preds (1): B11
   Succs (1): B9

 [B11]
   1: t < T
   T: while [B11.1]
   Preds (2): B1 B12
   Succs (2): B10 B0

 [B12]
   1: int N;
   2: int t = 0;
   Preds (1): B13
   Succs (1): B11

 [B0 (EXIT)]
   Preds (2): B6 B11

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int x;
   2: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Quick Sort/QuickSort.cpp

function-decl: quicksort quicksort
param-decl: int *; int; int; 

 [B15 (ENTRY)]
   Succs (1): B14

 [B1]
   1: temp = num[pivot]
   2: num[pivot] = num[j]
   3: num[j] = temp
   4: quicksort(num, first, j - 1)
   5: quicksort(num, j + 1, last)
   Preds (1): B12
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B12

 [B3]
   1: temp = num[i]
   2: num[i] = num[j]
   3: num[j] = temp
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < j
   T: if [B4.1]
   Preds (1): B7
   Succs (2): B3 B2

 [B5]
   Preds (1): B6
   Succs (1): B7

 [B6]
   1: j--
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: num[j] > num[pivot]
   T: while [B7.1]
   Preds (3): B5 B10 B11
   Succs (2): B6 B4

 [B8]
   Preds (1): B9
   Succs (1): B11

 [B9]
   1: i++
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: i < last
   T: while [B11.1] && [B10.1]
   Preds (1): B11
   Succs (2): B9 B7

 [B11]
   1: num[i] <= num[pivot]
   T: [B11.1] && ...
   Preds (2): B8 B12
   Succs (2): B10 B7

 [B12]
   1: i < j
   T: while [B12.1]
   Preds (2): B2 B13
   Succs (2): B11 B1

 [B13]
   1: pivot = first
   2: i = first
   3: j = last
   Preds (1): B14
   Succs (1): B12

 [B14]
   1: int i;
   2: int j;
   3: int pivot;
   4: int temp;
   5: first < last
   T: if [B14.5]
   Preds (1): B15
   Succs (2): B13 B0

 [B0 (EXIT)]
   Preds (2): B1 B14

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int i;
   2: int count;
   3: int num[21];
   4: quicksort(num, 0, count - 1)
   5: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Heavy Light Decomposition/HeavyLightDecomposition.cpp

function-decl: DFS DFS
param-decl: int; int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: T[root].parent = parent
   2: T[root].depth = depth
   3: T[root].subTreeSize = 1
   4: return T[root].subTreeSize;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: HLD HLD
param-decl: int; int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: T[root].chainTop = chainTop
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: LCA LCA
param-decl: int; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: return v;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return u;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: T[u].depth < T[v].depth
   T: if [B3.1]
   Preds (1): B8
   Succs (2): B2 B1

 [B4]
   Preds (2): B5 B6
   Succs (1): B8

 [B5]
   1: u = T[T[u].chainTop].parent
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: v = T[T[v].chainTop].parent
   Preds (1): B7
   Succs (1): B4

 [B7]
   1: T[T[u].chainTop].depth < T[T[v].chainTop].depth
   T: if [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: T[u].chainTop != T[v].chainTop
   T: while [B8.1]
   Preds (2): B4 B9
   Succs (2): B7 B3

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: n = 7
   2: DFS(1, 1, 0)
   3: HLD(1, 1, 1)
   4: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/VEGAS Algorithm/vegas_algorithm.cpp

function-decl: vegas_algorithm vegas_algorithm
param-decl: const int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: unsigned int seed;
   2: double s_g = 0.;
   3: double I = 0.;
   4: return I;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Fast Fourier Transform/FFT.cpp

function-decl: fft fft
param-decl: CArray &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: CArray even;
   2: CArray odd;
   3: fft(even)
   4: fft(odd)
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: const int N;
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   Preds (1): B3
   Succs (1): B9

 [B2]
   1: ++i
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < n
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: CArray data;
   2: fft(data)
   3: int i = 0;
   Preds (1): B7
   Succs (1): B3

 [B5]
   1: ++i
   Preds (1): B6
   Succs (1): B7

 [B6]
   1: double real;
   2: double imag;
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: i < n
   T: for (...; [B7.1]; ...)
   Preds (2): B5 B8
   Succs (2): B6 B4

 [B8]
   1: int n;
   2: n (ImplicitCastExpr, LValueToRValue, int)
   3: int test[n];
   4: int i = 0;
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: t-- (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: while [B9.1]
   Preds (2): B1 B10
   Succs (2): B8 B0

 [B10]
   1: int t;
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (1): B9


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Segment Tree/SegTreeSum.cpp

function-decl: getMid getMid
param-decl: int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return (a + b) / 2;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: getSum getSum
param-decl: int *; int; int; int; int; int; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: getMid(ss, se)
   2: int mid = getMid(ss, se);
   3: getSum(st, ss, mid, qs, qe, 2 * si + 1)
   4: getSum(st, mid + 1, se, qs, qe, 2 * si + 2)
   5: return [B1.3] + [B1.4];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 0;
   Preds (2): B3 B4
   Succs (1): B0

 [B3]
   1: qe < ss
   T: if [B4.1] || [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: qs > se
   T: [B4.1] || ...
   Preds (2): B6 B7
   Succs (2): B2 B3

 [B5]
   1: return st[si];
   Preds (1): B6
   Succs (1): B0

 [B6]
   1: qe >= se
   T: if [B7.1] && [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: qs <= ss
   T: [B7.1] && ...
   Preds (1): B8
   Succs (2): B6 B4

 [B0 (EXIT)]
   Preds (3): B1 B2 B5

function-decl: updateValueUtil updateValueUtil
param-decl: int *; int; int; int; int; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: getMid(ss, se)
   2: int mid = getMid(ss, se);
   3: updateValueUtil(st, ss, mid, ind, diff, 2 * si + 1)
   4: updateValueUtil(st, mid + 1, se, ind, diff, 2 * si + 2)
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: st[si] = st[si] + diff
   2: se != ss
   T: if [B2.2]
   Preds (1): B4
   Succs (2): B1 B0

 [B3]
   1: return;
   Preds (2): B4 B5
   Succs (1): B0

 [B4]
   1: ind < ss
   T: if [B5.1] || [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: ind > se
   T: [B5.1] || ...
   Preds (1): B6
   Succs (2): B3 B4

 [B0 (EXIT)]
   Preds (3): B1 B2 B3

function-decl: updateValue updateValue
param-decl: int *; int *; int; int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int diff = num - arr[ind];
   2: arr[ind] = num
   3: updateValueUtil(st, 0, n - 1, ind, diff, 0)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: constructUtil constructUtil
param-decl: int *; int; int; int *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: getMid(ss, se)
   2: int mid = getMid(ss, se);
   3: constructUtil(arr, ss, mid, st, 2 * si + 1)
   4: constructUtil(arr, mid + 1, se, st, 2 * si + 2)
   5: st[si] = [B1.3] + [B1.4]
   6: return st[si];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: st[si] = arr[ss]
   2: return arr[ss];
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: ss == se
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: construct construct
param-decl: int *; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int x;
   2: int max_size;
   3: new int [max_size]
   4: int *st = new int [max_size];
   5: constructUtil(arr, 0, n - 1, st, 0)
   6: return st;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int n;
   2: n (ImplicitCastExpr, LValueToRValue, int)
   3: int a[n];
   4: construct(a, n)
   5: int *st = construct(a, n);
   6: updateValue(a, st, n, 2, 10)
   7: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Counting Sort/CountingSort.cpp

function-decl: counting_sort counting_sort
param-decl: int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: print print
param-decl: int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int test_vec;
   2: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Greatest Common Divisor/GreatestCommonDivisior.cpp

function-decl: gcd gcd
param-decl: int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: gcd(b, (a % b))
   2: return [B1.1];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return a;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: b == 0
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a;
   2: int b;
   3: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Floyds Algorithm/Floyd'sAlgorithm.cpp

function-decl: push push
param-decl: struct Node **; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: struct Node *new_node;
   2: new_node->data = new_data
   3: new_node->next = (*head_ref)
   4: (*head_ref) = new_node
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: detectloop detectloop
param-decl: struct Node *; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: return 0;
   Preds (3): B5 B6 B7
   Succs (1): B0

 [B2]
   Preds (1): B4
   Succs (1): B7

 [B3]
   1: return 1;
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: slow_p = slow_p->next
   2: fast_p = fast_p->next->next
   3: slow_p == fast_p
   T: if [B4.3]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: fast_p->next (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: while [B7.1] && [B6.1] && [B5.1]
   Preds (1): B6
   Succs (2): B4 B1

 [B6]
   1: fast_p (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B7.1] && [B6.1] && ...
   Preds (1): B7
   Succs (2): B5 B1

 [B7]
   1: slow_p (ImplicitCastExpr, PointerToBoolean, _Bool)
   T: [B7.1] && ...
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B8]
   1: struct Node *slow_p = list;
   2: struct Node *fast_p = list;
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (2): B1 B3

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: struct Node *head;
   2: push(&head, 5)
   3: push(&head, 10)
   4: push(&head, 15)
   5: push(&head, 20)
   6: head->next->next->next->next = head
   7: detectloop(head)
   8: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Kadane's/kadanes_without_STL.cpp

function-decl: main main
param-decl: 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < n
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int a[] = {-2, -3, 4, -1, -2, 1, 5, -3};
   2: int n = sizeof (a) / sizeof (a[0]);
   3: int max_so_far = a[0];
   4: int max_ending_here = a[0];
   5: int i = 0;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Kadane's/Kadanes.cpp

function-decl: main main
param-decl: 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int v;
   2: int n;
   3: int mini;
   4: int maxval = mini;
   5: int curval = mini;
   6: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Dijkstra's/dijkstra_list.cc

function-decl: dijkstra dijkstra
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: dijShortPath dijShortPath
param-decl: int; int &; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: int path;
   2: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < e
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int e;
   2: int sorg;
   3: int dest;
   4: int u;
   5: int v;
   6: int w;
   7: int i = 0;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Dijkstra's/Dijkstras.cpp

function-decl: minDistance minDistance
param-decl: int *; _Bool *; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return min_index;
   Preds (1): B6
   Succs (1): B0

 [B2]
   1: v++
   Preds (3): B3 B4 B5
   Succs (1): B6

 [B3]
   1: min = dist[v]
   2: min_index = v
   3: ... , [B3.2]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: dist[v] <= min
   T: if [B5.1] && [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: sptSet[v] == false
   T: [B5.1] && ...
   Preds (1): B6
   Succs (2): B4 B2

 [B6]
   1: v < 9
   T: for (...; [B6.1]; ...)
   Preds (2): B2 B7
   Succs (2): B5 B1

 [B7]
   1: int min = 2147483647;
   2: int min_index;
   3: int v = 0;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printSolution printSolution
param-decl: int *; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: dijkstra dijkstra
param-decl: int (*)[9]; int; 

 [B17 (ENTRY)]
   Succs (1): B16

 [B1]
   1: printSolution(dist, 9)
   Preds (1): B11
   Succs (1): B0

 [B2]
   1: count++
   Preds (1): B9
   Succs (1): B11

 [B3]
   1: v++
   Preds (5): B4 B5 B6 B7 B8
   Succs (1): B9

 [B4]
   1: dist[v] = dist[u] + graph[u][v]
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: dist[u] + graph[u][v] < dist[v]
   T: if [B8.1] && [B7.1] && [B6.1] && [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: dist[u] != 2147483647
   T: [B8.1] && [B7.1] && [B6.1] && ...
   Preds (1): B7
   Succs (2): B5 B3

 [B7]
   1: graph[u][v] (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: [B8.1] && [B7.1] && ...
   Preds (1): B8
   Succs (2): B6 B3

 [B8]
   1: !sptSet[v]
   T: [B8.1] && ...
   Preds (1): B9
   Succs (2): B7 B3

 [B9]
   1: v < 9
   T: for (...; [B9.1]; ...)
   Preds (2): B3 B10
   Succs (2): B8 B2

 [B10]
   1: minDistance(dist, sptSet)
   2: int u = minDistance(dist, sptSet);
   3: sptSet[u] = true
   4: int v = 0;
   Preds (1): B11
   Succs (1): B9

 [B11]
   1: count < 9 - 1
   T: for (...; [B11.1]; ...)
   Preds (2): B2 B12
   Succs (2): B10 B1

 [B12]
   1: dist[src] = 0
   2: int count = 0;
   Preds (1): B15
   Succs (1): B11

 [B13]
   1: i++
   Preds (1): B14
   Succs (1): B15

 [B14]
   1: dist[i] = 2147483647
   2: sptSet[i] = false
   3: ... , [B14.2]
   Preds (1): B15
   Succs (1): B13

 [B15]
   1: i < 9
   T: for (...; [B15.1]; ...)
   Preds (2): B13 B16
   Succs (2): B14 B12

 [B16]
   1: int dist[9];
   2: _Bool sptSet[9];
   3: int i = 0;
   Preds (1): B17
   Succs (1): B15

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int graph[9][9] = {{0, 4, 0, 0, 0, 0, 0, 8, 0}, {4, 0, 8, 0, 0, 0, 0, 11, 0}, {0, 8, 0, 7, 0, 4, 0, 0, 2}, {0, 0, 7, 0, 9, 14, 0, 0, 0}, {0, 0, 0, 9, 0, 10, 0, 0, 0}, {0, 0, 4, 14, 10, 0, 2, 0, 0}, {0, 0, 0, 0, 0, 2, 0, 1, 6}, {8, 11, 0, 0, 0, 0, 1, 0, 7}, {0, 0, 2, 0, 0, 0, 6, 7, 0}};
   2: dijkstra(graph, 0)
   3: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Fibonacci/fibonacci.cpp

function-decl: main main
param-decl: 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: temp = num1 + num2
   2: num1 = num2
   3: num2 = temp
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i <= v
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: i
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Fibonacci/FibonacciFast.cpp

function-decl: Fibo Fibo
param-decl: ll; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: ll x = n / 2;
   2: Fibo(x)
   3: ll ans1 = Fibo(x);
   4: Fibo(x - 1)
   5: ll ans2 = Fibo(x - 1);
   6: Fibo(x + 1)
   7: ll ans3 = Fibo(x + 1);
   8: ll ans = ans1 * (ans2 + ans3);
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: ll x = (n + 1) / 2;
   2: Fibo(x)
   3: ll ans1 = Fibo(x);
   4: ans1 = (ans1 * ans1)
   5: Fibo(x - 1)
   6: ll ans2 = Fibo(x - 1);
   7: ans2 = (ans2 * ans2)
   8: ll ans = (ans1 + ans2);
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: n & 1 (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: if [B3.1]
   Preds (2): B4 B5
   Succs (2): B2 B1

 [B4]
   Preds (1): B5
   Succs (1): B3

 [B5]
   T: if <null expr>
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return 0;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: n == 0
   T: if [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (3): B1 B2 B6

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: ll n;
   2: Fibo(n)
   3: ll ans = Fibo(n);
   4: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Fibonacci/fibonacci_for_big_numbers.cpp

function-decl: main main
param-decl: 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i <= n
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int n;
   2: int v;
   3: int i = 2;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Cocktail Sort/CocktailSort.cpp

function-decl: CocktailSort CocktailSort
param-decl: int *; int; 

 [B17 (ENTRY)]
   Succs (1): B16

 [B1]
   Preds (1): B2
   Succs (1): B15

 [B2]
   1: ++start
   Preds (1): B6
   Succs (1): B1

 [B3]
   1: --i
   Preds (2): B4 B5
   Succs (1): B6

 [B4]
   1: swapped = true
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: a[i] > a[i + 1]
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: i >= start
   T: for (...; [B6.1]; ...)
   Preds (2): B3 B7
   Succs (2): B5 B2

 [B7]
   1: swapped = false
   2: --end
   3: int i = end - 1;
   Preds (1): B9
   Succs (1): B6

 [B8]
   T: break;
   Preds (1): B9
   Succs (1): B0

 [B9]
   1: !swapped
   T: if [B9.1]
   Preds (1): B13
   Succs (2): B8 B7

 [B10]
   1: ++i
   Preds (2): B11 B12
   Succs (1): B13

 [B11]
   1: swapped = true
   Preds (1): B12
   Succs (1): B10

 [B12]
   1: a[i] > a[i + 1]
   T: if [B12.1]
   Preds (1): B13
   Succs (2): B11 B10

 [B13]
   1: i < end
   T: for (...; [B13.1]; ...)
   Preds (2): B10 B14
   Succs (2): B12 B9

 [B14]
   1: swapped = false
   2: int i = start;
   Preds (1): B15
   Succs (1): B13

 [B15]
   1: swapped (ImplicitCastExpr, LValueToRValue, _Bool)
   T: while [B15.1]
   Preds (2): B1 B16
   Succs (2): B14 B0

 [B16]
   1: _Bool swapped = true;
   2: int start = 0;
   3: int end = n - 1;
   Preds (1): B17
   Succs (1): B15

 [B0 (EXIT)]
   Preds (2): B8 B15

function-decl: printArray printArray
param-decl: int *; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int arr[] = {5, 1, 4, 2, 8, 0, 2};
   2: int n = sizeof (arr) / sizeof (arr[0]);
   3: CocktailSort(arr, n)
   4: printArray(arr, n)
   5: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Longest Common Subsequence/LCS.cpp

function-decl: lcs lcs
param-decl: char *; char *; int; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: lcs(X, Y, m, n - 1)
   2: lcs(X, Y, m - 1, n)
   3: max([B1.1], [B1.2])
   4: return [B1.3];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: lcs(X, Y, m - 1, n - 1)
   2: return 1 + [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: X[m - 1] == Y[n - 1]
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return 0;
   Preds (2): B5 B6
   Succs (1): B0

 [B5]
   1: n == 0
   T: if [B6.1] || [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: m == 0
   T: [B6.1] || ...
   Preds (1): B7
   Succs (2): B4 B5

 [B0 (EXIT)]
   Preds (3): B1 B2 B4

function-decl: max max
param-decl: int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: ([B4.1]) ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: a
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: b
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: a > b
   T: ([B4.1]) ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: char X[] = "AGGTAB";
   2: char Y[] = "GXTXAYB";
   3: int m;
   4: int n;
   5: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/BellmanFord/BellmanFord.cpp

function-decl: bellman bellman
param-decl: int; const int *; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: int j = 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: int j = 0;
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i <= N - 1
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int i = 1;
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: i++
   Preds (1): B7
   Succs (1): B7

 [B7]
   1: i < N
   T: for (...; [B7.1]; ...)
   Preds (2): B6 B8
   Succs (2): B6 B5

 [B8]
   1: int i = 1;
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (1): B1

function-decl: Print Print
param-decl: int; const int *; int *; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: int x;
   2: int y;
   3: int cost;
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: M-- (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: while [B4.1]
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/FloodFill/flood fill.cpp

function-decl: floodFillUtil floodFillUtil
param-decl: int (*)[8]; int; int; int; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: screen[x][y] = newC
   2: floodFillUtil(screen, x + 1, y, prevC, newC)
   3: floodFillUtil(screen, x - 1, y, prevC, newC)
   4: floodFillUtil(screen, x, y + 1, prevC, newC)
   5: floodFillUtil(screen, x, y - 1, prevC, newC)
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: screen[x][y] != prevC
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return;
   Preds (4): B5 B6 B7 B8
   Succs (1): B0

 [B5]
   1: y >= 8
   T: if [B8.1] || [B7.1] || [B6.1] || [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: y < 0
   T: [B8.1] || [B7.1] || [B6.1] || ...
   Preds (1): B7
   Succs (2): B4 B5

 [B7]
   1: x >= 8
   T: [B8.1] || [B7.1] || ...
   Preds (1): B8
   Succs (2): B4 B6

 [B8]
   1: x < 0
   T: [B8.1] || ...
   Preds (1): B9
   Succs (2): B4 B7

 [B0 (EXIT)]
   Preds (3): B1 B2 B4

function-decl: floodFill floodFill
param-decl: int (*)[8]; int; int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int prevC = screen[x][y];
   2: floodFillUtil(screen, x, y, prevC, newC)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < 8
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int screen[8][8] = {{1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 0, 0}, {1, 0, 0, 1, 1, 0, 1, 1}, {1, 2, 2, 2, 2, 0, 1, 0}, {1, 1, 1, 2, 2, 0, 1, 0}, {1, 1, 1, 2, 2, 2, 2, 0}, {1, 1, 1, 1, 1, 2, 1, 1}, {1, 1, 1, 1, 1, 2, 2, 1}};
   2: int x = 4;
   3: int y = 4;
   4: int newC = 3;
   5: floodFill(screen, x, y, newC)
   6: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Sequence Alignment /seqalignlinearSpace.cpp

function-decl: insC insC
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return 4;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: delC delC
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: return 4;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: modC modC
param-decl: char; char; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return 3;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return 0;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: fr == to
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: rever rever
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int k;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: minimize minimize
param-decl: int; int; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: return xmid;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   1: xmid = i
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i <= le
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int sum;
   2: int xmid = 0;
   3: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B1

function-decl: stringOne stringOne
param-decl: int; int; 

 [B26 (ENTRY)]
   Succs (1): B25

 [B1]
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: j--
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: j (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: while [B3.1]
   Preds (2): B1 B7
   Succs (2): B2 B0

 [B4]
   Preds (1): B5
   Succs (1): B6

 [B5]
   1: i--
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: i (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: while [B6.1]
   Preds (2): B4 B7
   Succs (2): B5 B0

 [B7]
   1: i != 0
   T: if [B7.1]
   Preds (1): B15
   Succs (2): B6 B3

 [B8]
   Preds (4): B9 B10 B11 B13
   Succs (1): B18

 [B9]
   1: j -= 1
   Preds (1): B10
   Succs (1): B8

 [B10]
   T: if <null expr>
   Preds (1): B12
   Succs (2): B9 B8

 [B11]
   1: i -= 1
   Preds (1): B12
   Succs (1): B8

 [B12]
   T: if <null expr>
   Preds (1): B14
   Succs (2): B11 B10

 [B13]
   1: i--
   2: j--
   Preds (1): B14
   Succs (1): B8

 [B14]
   T: if <null expr>
   Preds (1): B16
   Succs (2): B13 B12

 [B15]
   T: break;
   Preds (2): B16 B17
   Succs (1): B7

 [B16]
   1: j == 0
   T: if [B17.1] || [B16.1]
   Preds (1): B17
   Succs (2): B15 B14

 [B17]
   1: i == 0
   T: [B17.1] || ...
   Preds (1): B18
   Succs (2): B15 B16

 [B18]
   1: true
   T: while [B18.1]
   Preds (2): B8 B19
   Succs (2): B17 NULL

 [B19]
   1: int i = m;
   2: int j = n;
   Preds (1): B24
   Succs (1): B18

 [B20]
   1: i++
   Preds (1): B22
   Succs (1): B24

 [B21]
   1: j++
   Preds (1): B22
   Succs (1): B22

 [B22]
   1: j <= n
   T: for (...; [B22.1]; ...)
   Preds (2): B21 B23
   Succs (2): B21 B20

 [B23]
   1: int j;
   2: j = 1
   Preds (1): B24
   Succs (1): B22

 [B24]
   1: i <= m
   T: for (...; [B24.1]; ...)
   Preds (2): B20 B25
   Succs (2): B23 B19

 [B25]
   1: int sa;
   2: int m;
   3: int n;
   4: int i = 1;
   Preds (1): B26
   Succs (1): B24

 [B0 (EXIT)]
   Preds (2): B3 B6

function-decl: SpaceEfficientAlignment SpaceEfficientAlignment
param-decl: int; int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i <= m
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 0;
   Preds (1): B8
   Succs (1): B2

 [B4]
   1: j++
   Preds (1): B6
   Succs (1): B8

 [B5]
   1: i++
   Preds (1): B6
   Succs (1): B6

 [B6]
   1: i <= m
   T: for (...; [B6.1]; ...)
   Preds (2): B5 B7
   Succs (2): B5 B4

 [B7]
   1: int i = 1;
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: j <= n
   T: for (...; [B8.1]; ...)
   Preds (2): B4 B9
   Succs (2): B7 B3

 [B9]
   1: int m;
   2: int n;
   3: int j = 1;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B2

function-decl: GainAlignment GainAlignment
param-decl: int; int; 

 [B15 (ENTRY)]
   Succs (1): B14

 [B1]
   1: int ymid = l2 / 2;
   2: int ScoreL;
   3: int ScoreR;
   4: int xmid;
   Preds (1): B3
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B0

 [B3]
   1: l2 == 1
   T: if [B4.1] || [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: l1 == 1
   T: [B4.1] || ...
   Preds (1): B9
   Succs (2): B2 B3

 [B5]
   1: i++
   Preds (1): B6
   Succs (1): B7

 [B6]
   1: delC()
   2: cost += [B6.1]
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: i < l1
   T: for (...; [B7.1]; ...)
   Preds (2): B5 B8
   Succs (2): B6 B0

 [B8]
   1: int i = 0;
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: l2 == 0
   T: if [B9.1]
   Preds (1): B14
   Succs (2): B8 B4

 [B10]
   1: i++
   Preds (1): B11
   Succs (1): B12

 [B11]
   1: insC()
   2: cost += [B11.1]
   Preds (1): B12
   Succs (1): B10

 [B12]
   1: i < l2
   T: for (...; [B12.1]; ...)
   Preds (2): B10 B13
   Succs (2): B11 B0

 [B13]
   1: int i = 0;
   Preds (1): B14
   Succs (1): B12

 [B14]
   1: int te1;
   2: int l1;
   3: int l2;
   4: l1 == 0
   T: if [B14.4]
   Preds (1): B15
   Succs (2): B13 B9

 [B0 (EXIT)]
   Preds (4): B1 B2 B7 B12

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int s1;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Bellman Ford/bellmanford.cpp

function-decl: createGraph createGraph
param-decl: int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: struct Graph *graph;
   2: graph->V = V
   3: graph->E = E
   4: return graph;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: FinalSolution FinalSolution
param-decl: int *; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: ++i
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B0 (EXIT)]
   Preds (1): B2

function-decl: BellmanFord BellmanFord
param-decl: struct Graph *; int; 

 [B18 (ENTRY)]
   Succs (1): B17

 [B1]
   1: FinalSolution(StoreDistance, V)
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: int u = graph->edge[i].source;
   2: int v = graph->edge[i].destination;
   3: int weight = graph->edge[i].weight;
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < E
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int i = 0;
   Preds (1): B12
   Succs (1): B4

 [B6]
   1: i++
   Preds (1): B10
   Succs (1): B12

 [B7]
   1: j++
   Preds (2): B8 B9
   Succs (1): B10

 [B8]
   1: StoreDistance[v] = StoreDistance[u] + weight
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: int u = graph->edge[j].source;
   2: int v = graph->edge[j].destination;
   3: int weight = graph->edge[j].weight;
   4: StoreDistance[u] + weight < StoreDistance[v]
   T: if [B9.4]
   Preds (1): B10
   Succs (2): B8 B7

 [B10]
   1: j < E
   T: for (...; [B10.1]; ...)
   Preds (2): B7 B11
   Succs (2): B9 B6

 [B11]
   1: int j = 0;
   Preds (1): B12
   Succs (1): B10

 [B12]
   1: i <= V - 1
   T: for (...; [B12.1]; ...)
   Preds (2): B6 B13
   Succs (2): B11 B5

 [B13]
   1: StoreDistance[source] = 0
   2: int i = 1;
   Preds (1): B16
   Succs (1): B12

 [B14]
   1: i++
   Preds (1): B15
   Succs (1): B16

 [B15]
   1: StoreDistance[i] = 2147483647
   Preds (1): B16
   Succs (1): B14

 [B16]
   1: i < V
   T: for (...; [B16.1]; ...)
   Preds (2): B14 B17
   Succs (2): B15 B13

 [B17]
   1: int V = graph->V;
   2: int E = graph->E;
   3: V (ImplicitCastExpr, LValueToRValue, int)
   4: int StoreDistance[V];
   5: int i = 0;
   Preds (1): B18
   Succs (1): B16

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: BellmanFord(graph, S)
   2: return 0;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < E
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: int V;
   2: int E;
   3: int S;
   4: createGraph(V, E)
   5: struct Graph *graph = createGraph(V, E);
   6: int i = 0;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/AStar Search/a_star.cpp

function-decl: isValid isValid
param-decl: int; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: ([B5.1]) && ([B4.1]) && ([B3.1]) && ([B2.1])
   2: return [B1.1];
   Preds (4): B2 B3 B4 B5
   Succs (1): B0

 [B2]
   1: col < 10
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: col >= 0
   T: ([B5.1]) && ([B4.1]) && ([B3.1]) && ...
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: row < 9
   T: ([B5.1]) && ([B4.1]) && ...
   Preds (1): B5
   Succs (2): B3 B1

 [B5]
   1: row >= 0
   T: ([B5.1]) && ...
   Preds (1): B6
   Succs (2): B4 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: isUnBlocked isUnBlocked
param-decl: int (*)[10]; int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return (false);
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return (true);
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: grid[row][col] == 1
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: isDestination isDestination
param-decl: int; int; Pair; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return (false);
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return (true);
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: calculateHValue calculateHValue
param-decl: int; int; Pair; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: tracePath tracePath
param-decl: struct cell (*)[10]; Pair; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: return;
   Preds (1): B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B6

 [B3]
   1: int temp_row = cellDetails[row][col].parent_i;
   2: int temp_col = cellDetails[row][col].parent_j;
   3: row = temp_row
   4: col = temp_col
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: [B6.1] && [B5.1]
   2: !([B4.1])
   T: while [B4.2]
   Preds (2): B5 B6
   Succs (2): B3 B1

 [B5]
   1: cellDetails[row][col].parent_j == col
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: cellDetails[row][col].parent_i == row
   T: [B6.1] && ...
   Preds (2): B2 B7
   Succs (2): B5 B4

 [B7]
   1: int row;
   2: int col;
   3: int Path;
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1

function-decl: aStarSearch aStarSearch
param-decl: int (*)[10]; Pair; Pair; 

 [B17 (ENTRY)]
   Succs (1): B16

 [B1]
   1: cellDetails[i][j].f = 0.
   2: cellDetails[i][j].g = 0.
   3: cellDetails[i][j].h = 0.
   4: cellDetails[i][j].parent_i = i
   5: cellDetails[i][j].parent_j = j
   6: int openList;
   7: _Bool foundDest = false;
   8: return;
   Preds (1): B7
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B5
   Succs (1): B7

 [B3]
   1: j++
   Preds (1): B4
   Succs (1): B5

 [B4]
   1: cellDetails[i][j].parent_i = -1
   2: cellDetails[i][j].parent_j = -1
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: j < 10
   T: for (...; [B5.1]; ...)
   Preds (2): B3 B6
   Succs (2): B4 B2

 [B6]
   1: j = 0
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: i < 9
   T: for (...; [B7.1]; ...)
   Preds (2): B2 B8
   Succs (2): B6 B1

 [B8]
   1: _Bool closedList[9][10];
   2:  (CXXConstructExpr, struct cell [9][10])
   3: struct cell cellDetails[9][10];
   4: int i;
   5: int j;
   6: i = 0
   Preds (1): B10
   Succs (1): B7

 [B9]
   1: return;
   Preds (1): B10
   Succs (1): B0

 [B10]
   T: if <null expr>
   Preds (1): B12
   Succs (2): B9 B8

 [B11]
   1: return;
   Preds (1): B12
   Succs (1): B0

 [B12]
   T: if <null expr>
   Preds (1): B14
   Succs (2): B11 B10

 [B13]
   1: return;
   Preds (1): B14
   Succs (1): B0

 [B14]
   T: if <null expr>
   Preds (1): B16
   Succs (2): B13 B12

 [B15]
   1: return;
   Preds (1): B16
   Succs (1): B0

 [B16]
   T: if <null expr>
   Preds (1): B17
   Succs (2): B15 B14

 [B0 (EXIT)]
   Preds (5): B1 B9 B11 B13 B15

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int grid[9][10] = {{1, 0, 1, 1, 1, 1, 0, 1, 1, 1}, {1, 1, 1, 0, 1, 1, 1, 0, 1, 1}, {1, 1, 1, 0, 1, 1, 0, 1, 0, 1}, {0, 0, 1, 0, 1, 0, 0, 0, 0, 1}, {1, 1, 1, 0, 1, 1, 1, 0, 1, 0}, {1, 0, 1, 1, 1, 1, 0, 1, 0, 0}, {1, 0, 0, 0, 0, 1, 0, 0, 0, 1}, {1, 0, 1, 1, 1, 1, 0, 1, 1, 1}, {1, 1, 1, 0, 0, 0, 1, 0, 0, 1}};
   2: Pair src;
   3: Pair dest;
   4: aStarSearch(grid, src, dest)
   5: return (0);
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Shell Sort/ShellSort.cpp

function-decl: shellSort shellSort
param-decl: int *; int; 

 [B14 (ENTRY)]
   Succs (1): B13

 [B1]
   1: return 0;
   Preds (1): B12
   Succs (1): B0

 [B2]
   1: gap /= 2
   Preds (1): B10
   Succs (1): B12

 [B3]
   1: i += 1
   Preds (1): B4
   Succs (1): B10

 [B4]
   1: arr[j] = temp
   Preds (2): B7 B8
   Succs (1): B3

 [B5]
   1: j -= gap
   Preds (1): B6
   Succs (1): B8

 [B6]
   1: arr[j] = arr[j - gap]
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: arr[j - gap] > temp
   T: for (...; [B8.1] && [B7.1]; ...)
   Preds (1): B8
   Succs (2): B6 B4

 [B8]
   1: j >= gap
   T: [B8.1] && ...
   Preds (2): B5 B9
   Succs (2): B7 B4

 [B9]
   1: int temp = arr[i];
   2: int j;
   3: j = i
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: i < n
   T: for (...; [B10.1]; ...)
   Preds (2): B3 B11
   Succs (2): B9 B2

 [B11]
   1: int i = gap;
   Preds (1): B12
   Succs (1): B10

 [B12]
   1: gap > 0
   T: for (...; [B12.1]; ...)
   Preds (2): B2 B13
   Succs (2): B11 B1

 [B13]
   1: int gap = n / 2;
   Preds (1): B14
   Succs (1): B12

 [B0 (EXIT)]
   Preds (1): B1

function-decl: printArray printArray
param-decl: int *; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int arr[] = {12, 34, 54, 2, 3};
   2: int i;
   3: int n = sizeof (arr) / sizeof (arr[0]);
   4: printArray(arr, n)
   5: shellSort(arr, n)
   6: printArray(arr, n)
   7: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Inverse Fast Fourier Transform/Inverse_FFT.cpp

function-decl: fft fft
param-decl: CArray &; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: CArray even;
   2: CArray odd;
   3: fft(even)
   4: fft(odd)
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: const int N;
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: ifft ifft
param-decl: CArray &; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: fft(x)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   Preds (1): B3
   Succs (1): B9

 [B2]
   1: ++i
   Preds (1): B3
   Succs (1): B3

 [B3]
   1: i < n
   T: for (...; [B3.1]; ...)
   Preds (2): B2 B4
   Succs (2): B2 B1

 [B4]
   1: CArray data;
   2: ifft(data)
   3: int i = 0;
   Preds (1): B7
   Succs (1): B3

 [B5]
   1: ++i
   Preds (1): B6
   Succs (1): B7

 [B6]
   1: double real;
   2: double imag;
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: i < n
   T: for (...; [B7.1]; ...)
   Preds (2): B5 B8
   Succs (2): B6 B4

 [B8]
   1: int n;
   2: n (ImplicitCastExpr, LValueToRValue, int)
   3: int test[n];
   4: int i = 0;
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: t-- (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: while [B9.1]
   Preds (2): B1 B10
   Succs (2): B8 B0

 [B10]
   1: int t;
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (1): B9


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Modified Binary Search/lower_bound.cpp

function-decl: lower_bound lower_bound
param-decl: int; int; int; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: return result;
   Preds (1): B9
   Succs (1): B0

 [B2]
   Preds (4): B3 B4 B5 B7
   Succs (1): B9

 [B3]
   1: high = mid - 1
   Preds (1): B4
   Succs (1): B2

 [B4]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   1: low = mid + 1
   Preds (1): B6
   Succs (1): B2

 [B6]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B5 B4

 [B7]
   1: result = mid
   2: high = mid - 1
   Preds (1): B8
   Succs (1): B2

 [B8]
   1: int mid = (low + high) / 2;
   T: if <null expr>
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: low <= high
   T: while [B9.1]
   Preds (2): B2 B10
   Succs (2): B8 B1

 [B10]
   1: int result = -1;
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int n;
   2: int x;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Modified Binary Search/upper_bound.cpp

function-decl: upper_bound upper_bound
param-decl: int; int; int; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: return result;
   Preds (1): B9
   Succs (1): B0

 [B2]
   Preds (4): B3 B4 B5 B7
   Succs (1): B9

 [B3]
   1: high = mid - 1
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: a[mid] > key
   T: if [B4.1]
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   1: low = mid + 1
   Preds (1): B6
   Succs (1): B2

 [B6]
   1: a[mid] < key
   T: if [B6.1]
   Preds (1): B8
   Succs (2): B5 B4

 [B7]
   1: result = mid
   2: low = mid + 1
   Preds (1): B8
   Succs (1): B2

 [B8]
   1: int mid = (low + high) / 2;
   2: a[mid] == key
   T: if [B8.2]
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: low <= high
   T: while [B9.1]
   Preds (2): B2 B10
   Succs (2): B8 B1

 [B10]
   1: int result = -1;
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int n;
   2: int x;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Counting Inversions/inversions_counter.cpp

function-decl: mergeSort mergeSort
param-decl: int *; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int *temp;
   2: _mergeSort(arr, temp, 0, array_size - 1)
   3: return [B1.2];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: _mergeSort _mergeSort
param-decl: int *; int *; int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return inv_count;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: mid = (right + left) / 2
   2: _mergeSort(arr, temp, left, mid)
   3: inv_count = [B2.2]
   4: _mergeSort(arr, temp, mid + 1, right)
   5: inv_count += [B2.4]
   6: merge(arr, temp, left, mid + 1, right)
   7: inv_count += [B2.6]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: int mid;
   2: int inv_count = 0;
   3: right > left
   T: if [B3.3]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: merge merge
param-decl: int *; int *; int; int; int; 

 [B19 (ENTRY)]
   Succs (1): B18

 [B1]
   1: return inv_count;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: arr[i] = temp[i]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i <= right
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: i = left
   Preds (1): B8
   Succs (1): B4

 [B6]
   Preds (1): B7
   Succs (1): B8

 [B7]
   1: temp[k++] = arr[j++]
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: j <= right
   T: while [B8.1]
   Preds (2): B6 B11
   Succs (2): B7 B5

 [B9]
   Preds (1): B10
   Succs (1): B11

 [B10]
   1: temp[k++] = arr[i++]
   Preds (1): B11
   Succs (1): B9

 [B11]
   1: i <= mid - 1
   T: while [B11.1]
   Preds (3): B9 B16 B17
   Succs (2): B10 B8

 [B12]
   Preds (2): B13 B14
   Succs (1): B17

 [B13]
   1: temp[k++] = arr[j++]
   2: inv_count = inv_count + (mid - i)
   Preds (1): B15
   Succs (1): B12

 [B14]
   1: temp[k++] = arr[i++]
   Preds (1): B15
   Succs (1): B12

 [B15]
   1: arr[i] <= arr[j]
   T: if [B15.1]
   Preds (1): B16
   Succs (2): B14 B13

 [B16]
   1: j <= right
   T: while ([B17.1]) && ([B16.1])
   Preds (1): B17
   Succs (2): B15 B11

 [B17]
   1: i <= mid - 1
   T: ([B17.1]) && ...
   Preds (2): B12 B18
   Succs (2): B16 B11

 [B18]
   1: int i;
   2: int j;
   3: int k;
   4: int inv_count = 0;
   5: i = left
   6: j = mid
   7: k = left
   Preds (1): B19
   Succs (1): B17

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int arr[] = {1, 20, 6, 4, 5};
   2: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Longest Bitonic Subsequence/LongestBitonicSubsequence.cpp

function-decl: binsearch binsearch
param-decl: ll; 

 [B16 (ENTRY)]
   Succs (1): B15

 [B1]
   1: ll sm = mid;
   2: ll big = mid + 1;
   3: tail[big] = x
   4: return big;
   Preds (3): B4 B7 B10
   Succs (1): B0

 [B2]
   Preds (2): B3 B6
   Succs (1): B10

 [B3]
   1: beg = mid
   Preds (1): B5
   Succs (1): B2

 [B4]
   T: break;
   Preds (1): B5
   Succs (1): B1

 [B5]
   1: beg == mid
   T: if [B5.1]
   Preds (1): B9
   Succs (2): B4 B3

 [B6]
   1: end = mid
   Preds (1): B8
   Succs (1): B2

 [B7]
   T: break;
   Preds (1): B8
   Succs (1): B1

 [B8]
   1: end == mid
   T: if [B8.1]
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: mid = beg + (end - beg) / 2
   2: tail[mid] >= x
   T: if [B9.2]
   Preds (1): B10
   Succs (2): B8 B5

 [B10]
   1: beg < end
   T: while [B10.1]
   Preds (2): B2 B11
   Succs (2): B9 B1

 [B11]
   1: ll mid;
   2: ll beg = 0;
   3: ll end = length - 1;
   Preds (1): B13
   Succs (1): B10

 [B12]
   1: tail[length] = x
   2: return length++;
   Preds (1): B13
   Succs (1): B0

 [B13]
   1: x > tail[length - 1]
   T: if [B13.1]
   Preds (1): B15
   Succs (2): B12 B11

 [B14]
   1: tail[0] = x
   2: return 0;
   Preds (1): B15
   Succs (1): B0

 [B15]
   1: ll x = arr[index];
   2: x <= tail[0]
   T: if [B15.2]
   Preds (1): B16
   Succs (2): B14 B13

 [B0 (EXIT)]
   Preds (3): B1 B12 B14

function-decl: main main
param-decl: 

 [B29 (ENTRY)]
   Succs (1): B28

 [B1]
   1: return 0;
   Preds (1): B14
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B6 B13
   Succs (1): B14

 [B3]
   Preds (2): B4 B5
   Succs (1): B6

 [B4]
   1: len_right--
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: rightseq[++j] == len_right
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: len_right >= 0
   T: while [B6.1]
   Preds (2): B3 B7
   Succs (2): B5 B2

 [B7]
   1: len_right = rightseq[i] - 1
   2: j = i
   Preds (1): B11
   Succs (1): B6

 [B8]
   Preds (2): B9 B10
   Succs (1): B11

 [B9]
   1: len_left--
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: leftseq[--j] == len_left
   T: if [B10.1]
   Preds (1): B11
   Succs (2): B9 B8

 [B11]
   1: len_left >= 0
   T: while [B11.1]
   Preds (2): B8 B12
   Succs (2): B10 B7

 [B12]
   1: len_left = leftseq[i] - 1
   2: j = i
   Preds (1): B13
   Succs (1): B11

 [B13]
   1: totalseq[i] == maximum
   T: if [B13.1]
   Preds (1): B14
   Succs (2): B12 B2

 [B14]
   1: i < n
   T: for (...; [B14.1]; ...)
   Preds (2): B2 B15
   Succs (2): B13 B1

 [B15]
   1: ll len_left = 0;
   2: ll len_right = 0;
   3: ll j;
   4: int s;
   5: ll i = 0;
   Preds (1): B19
   Succs (1): B14

 [B16]
   1: i++
   Preds (2): B17 B18
   Succs (1): B19

 [B17]
   1: maximum = totalseq[i]
   Preds (1): B18
   Succs (1): B16

 [B18]
   1: totalseq[i] = leftseq[i] + rightseq[i]
   2: totalseq[i] > maximum
   T: if [B18.2]
   Preds (1): B19
   Succs (2): B17 B16

 [B19]
   1: i < n
   T: for (...; [B19.1]; ...)
   Preds (2): B16 B20
   Succs (2): B18 B15

 [B20]
   1: ll i = 0;
   Preds (1): B23
   Succs (1): B19

 [B21]
   1: i--
   Preds (1): B22
   Succs (1): B23

 [B22]
   1: binsearch(i)
   2: rightseq[i] = [B22.1]
   Preds (1): B23
   Succs (1): B21

 [B23]
   1: i > 0
   T: for (...; [B23.1]; ...)
   Preds (2): B21 B24
   Succs (2): B22 B20

 [B24]
   1: length = 1
   2: rightseq[0] = rightseq[n - 1] = 0
   3: tail[0] = arr[n - 1]
   4: ll i = n - 2;
   Preds (1): B27
   Succs (1): B23

 [B25]
   1: i++
   Preds (1): B26
   Succs (1): B27

 [B26]
   1: binsearch(i)
   2: leftseq[i] = [B26.1]
   Preds (1): B27
   Succs (1): B25

 [B27]
   1: i < n - 1
   T: for (...; [B27.1]; ...)
   Preds (2): B25 B28
   Succs (2): B26 B24

 [B28]
   1: new ll [n]
   2: arr = [B28.1]
   3: new ll [n]
   4: leftseq = [B28.3]
   5: new ll [n]
   6: rightseq = [B28.5]
   7: new ll [n]
   8: totalseq = [B28.7]
   9: new ll [n]
  10: tail = [B28.9]
  11: length = 1
  12: leftseq[0] = leftseq[n - 1] = 0
  13: tail[0] = arr[0]
  14: ll i = 1;
   Preds (1): B29
   Succs (1): B27

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Bitap Algorithm/Bitap.cpp

function-decl: bitap_search bitap_search
param-decl: int; int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return -1;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: ++i
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: pattern_mask[i] = ~0
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i <= 255
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int i = 0;
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: return -1;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: m > 63
   T: if [B7.1]
   Preds (1): B9
   Succs (2): B6 B5

 [B8]
   1: return -1;
   Preds (1): B9
   Succs (1): B0

 [B9]
   1: int m;
   2: long pattern_mask[256];
   3: long R = ~1;
   4: m == 0
   T: if [B9.4]
   Preds (1): B10
   Succs (2): B8 B7

 [B0 (EXIT)]
   Preds (3): B1 B6 B8

function-decl: findPattern findPattern
param-decl: int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int pos;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: int; char **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int text;
   2: int pattern;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Longest Path/LongestPath.cpp

function-decl: bfs bfs
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int q;
   2: int last = source;
   3: return last;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: longest_path longest_path
param-decl: int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: bfs(1)
   2: int source = bfs(1);
   3: bfs(source)
   4: return dist[[B1.3]];
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: longest_path(nodes, edges)
   2: int ans = longest_path(nodes, edges);
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: int u;
   2: int v;
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < edges
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int nodes;
   2: int edges;
   3: int i = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C++/Selection Sort/Selection-sort.cpp

function-decl: selection selection
param-decl: int; int *; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: i++
   Preds (2): B2 B3
   Succs (1): B9

 [B2]
   1: temp = a[i]
   2: a[i] = a[min]
   3: a[min] = temp
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: i != min
   T: if [B3.1]
   Preds (1): B7
   Succs (2): B2 B1

 [B4]
   1: k++
   Preds (2): B5 B6
   Succs (1): B7

 [B5]
   1: min = k
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: a[min] > a[k]
   T: if [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: k < n
   T: for (...; [B7.1]; ...)
   Preds (2): B4 B8
   Succs (2): B6 B3

 [B8]
   1: min = i
   2: k = i + 1
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: i < n - 1
   T: for (...; [B9.1]; ...)
   Preds (2): B1 B10
   Succs (2): B8 B0

 [B10]
   1: int k;
   2: int i;
   3: int temp;
   4: int min;
   5: i = 0
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (1): B9

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a[20];
   2: int i;
   3: int j;
   4: int k;
   5: int n;
   6: int temp;
   7: int min;
   8: selection(n, a)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Extended Euclidean Algorithm/extended_euclid.cpp

function-decl: Extended_Euclid Extended_Euclid
param-decl: int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: Extended_Euclid(B, A % B)
   2: int temp = x;
   3: x = y
   4: y = temp - (A / B) * y
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: d = A
   2: x = 1
   3: y = 0
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: B == 0
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int m;
   2: int n;
   3: Extended_Euclid(m, n)
   4: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Longest-Common-Subsequence/LCSv2.c

function-decl: max max
param-decl: int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: ([B4.1]) ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: p (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: q (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: p > q
   T: ([B4.1]) ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: lcs lcs
param-decl: char *; char *; int; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: lcs(a, b, m, n - 1)
   2: lcs(a, b, m - 1, n)
   3: max([B1.1], [B1.2])
   4: return [B1.3];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: lcs(a, b, m - 1, n - 1)
   2: return 1 + [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: a[m - 1] == b[n - 1]
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return 0;
   Preds (2): B5 B6
   Succs (1): B0

 [B5]
   1: n == 0
   T: if [B6.1] || [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: m == 0
   T: [B6.1] || ...
   Preds (1): B7
   Succs (2): B4 B5

 [B0 (EXIT)]
   Preds (3): B1 B2 B4


filename: /Users/yingcao/re/DataSets/Algorithms/C/Longest-Common-Subsequence/LCS.c

function-decl: lcs lcs
param-decl: char *; char *; int; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: lcs(X, Y, m, n - 1)
   2: lcs(X, Y, m - 1, n)
   3: max([B1.1], [B1.2])
   4: return [B1.3];
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: lcs(X, Y, m - 1, n - 1)
   2: return 1 + [B2.1];
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: X[m - 1] == Y[n - 1]
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return 0;
   Preds (2): B5 B6
   Succs (1): B0

 [B5]
   1: n == 0
   T: if [B6.1] || [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: m == 0
   T: [B6.1] || ...
   Preds (1): B7
   Succs (2): B4 B5

 [B0 (EXIT)]
   Preds (3): B1 B2 B4

function-decl: max max
param-decl: int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: ([B4.1]) ? [B2.1] : [B3.1]
   2: return [B1.1];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: a (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: b (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: a > b
   T: ([B4.1]) ? ... : ...
   Preds (1): B5
   Succs (2): B2 B3

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: char X[] = "AGGTAB";
   2: char Y[] = "GXTXAYB";
   3: strlen(X)
   4: int m = strlen(X);
   5: strlen(Y)
   6: int n = strlen(Y);
   7: lcs(X, Y, m, n)
   8: printf("Length of LCS is %dn", [B1.7])
   9: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Ternary Search/ternary.c

function-decl: Ternary_search Ternary_search
param-decl: int *; int; int; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: return -1;
   Preds (2): B3 B6
   Succs (1): B0

 [B2]
   1: return mid2;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return mid1;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: int mid1 = low + (high - low) / 3;
   2: int mid2 = high - (high - low) / 3;
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: high >= low
   T: if [B6.1]
   Preds (1): B7
   Succs (2): B5 B1

 [B0 (EXIT)]
   Preds (3): B1 B2 B4


filename: /Users/yingcao/re/DataSets/Algorithms/C/Linear Search/LinearSearch.c

function-decl: LinearSearch LinearSearch
param-decl: int *; int; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: return -1;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B4
   Succs (1): B5

 [B3]
   1: return i;
   Preds (1): B4
   Succs (1): B0

 [B4]
   1: array[i] == key
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < len
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: i = 0
   Preds (1): B8
   Succs (1): B5

 [B7]
   1: return -1;
   Preds (1): B8
   Succs (1): B0

 [B8]
   1: int i;
   T: if <null expr>
   Preds (1): B9
   Succs (2): B7 B6

 [B0 (EXIT)]
   Preds (3): B1 B3 B7


filename: /Users/yingcao/re/DataSets/Algorithms/C/Depth First Search/DFS(recursive).c

function-decl: dfs dfs
param-decl: int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: i++
   Preds (3): B2 B3 B4
   Succs (1): B5

 [B2]
   1: dfs(i)
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: !isvisited[i]
   T: if [B4.1] && [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: graphmat[source][i] (ImplicitCastExpr, IntegralCast, int)
   T: [B4.1] && ...
   Preds (1): B5
   Succs (2): B3 B1

 [B5]
   1: i < 1000
   T: for (...; [B5.1]; ...)
   Preds (2): B1 B6
   Succs (2): B4 B0

 [B6]
   1: isvisited[source] = 1
   2: int i = 0;
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B5

function-decl: main main
param-decl: 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: int source;
   2: scanf("%d", &source)
   3: dfs(source)
   4: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: int from;
   2: int to;
   3: scanf("%d %d", &from, &to)
   4: graphmat[from][to] = 1
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < edges
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int vertices;
   2: int edges;
   3: scanf("%d %d", &vertices, &edges)
   4: int i = 0;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Floyd'sAlgorithm/Floyd's_Algo.c

function-decl: min min
param-decl: int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return b;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return a;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: a < b
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: 

 [B37 (ENTRY)]
   Succs (1): B36

 [B1]
   1: printf("\nThe start time is:\t%g", st)
   2: printf("\nThe end time is:\t%g", et)
   3: printf("\nThe time taken is:\t%g", tt)
   Preds (1): B9
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B9

 [B3]
   1: printf("\n")
   Preds (1): B7
   Succs (1): B2

 [B4]
   1: j++
   Preds (2): B5 B6
   Succs (1): B7

 [B5]
   1: printf("%d->%d=%d\t", i, j, a[i][j])
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: i != j
   T: if [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: j <= n
   T: for (...; [B7.1]; ...)
   Preds (2): B4 B8
   Succs (2): B6 B3

 [B8]
   1: j = 1
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: i <= n
   T: for (...; [B9.1]; ...)
   Preds (2): B2 B10
   Succs (2): B8 B1

 [B10]
   1: printf("\nThe paths from each node is:")
   2: i = 1
   Preds (1): B17
   Succs (1): B9

 [B11]
   1: i++
   Preds (1): B12
   Succs (1): B17

 [B12]
   1: printf("\n")
   Preds (1): B15
   Succs (1): B11

 [B13]
   1: j++
   Preds (1): B14
   Succs (1): B15

 [B14]
   1: printf("%d\t", a[i][j])
   Preds (1): B15
   Succs (1): B13

 [B15]
   1: j <= n
   T: for (...; [B15.1]; ...)
   Preds (2): B13 B16
   Succs (2): B14 B12

 [B16]
   1: j = 1
   Preds (1): B17
   Succs (1): B15

 [B17]
   1: i <= n
   T: for (...; [B17.1]; ...)
   Preds (2): B11 B18
   Succs (2): B16 B10

 [B18]
   1: omp_get_wtime()
   2: et = [B18.1]
   3: tt = et - st
   4: printf("\nThe shortest path matrix is")
   5: i = 1
   Preds (1): B27
   Succs (1): B17

 [B19]
   1: k++
   Preds (1): B25
   Succs (1): B27

 [B20]
   1: i++
   Preds (1): B23
   Succs (1): B25

 [B21]
   1: j++
   Preds (1): B22
   Succs (1): B23

 [B22]
   1: min(a[i][j], a[i][k] + a[k][j])
   2: a[i][j] = [B22.1]
   Preds (1): B23
   Succs (1): B21

 [B23]
   1: j <= n
   T: for (...; [B23.1]; ...)
   Preds (2): B21 B24
   Succs (2): B22 B20

 [B24]
   1: j = 1
   Preds (1): B25
   Succs (1): B23

 [B25]
   1: i <= n
   T: for (...; [B25.1]; ...)
   Preds (2): B20 B26
   Succs (2): B24 B19

 [B26]
   1: i = 1
   Preds (1): B27
   Succs (1): B25

 [B27]
   1: k <= n
   T: for (...; [B27.1]; ...)
   Preds (2): B19 B28
   Succs (2): B26 B18

 [B28]
   1: omp_get_wtime()
   2: st = [B28.1]
   3: k = 1
   Preds (1): B35
   Succs (1): B27

 [B29]
   1: i++
   Preds (1): B33
   Succs (1): B35

 [B30]
   1: j++
   Preds (2): B31 B32
   Succs (1): B33

 [B31]
   1: a[i][j] = 999
   Preds (1): B32
   Succs (1): B30

 [B32]
   1: scanf("%d", &a[i][j])
   2: a[i][j] == 0
   T: if [B32.2]
   Preds (1): B33
   Succs (2): B31 B30

 [B33]
   1: j <= n
   T: for (...; [B33.1]; ...)
   Preds (2): B30 B34
   Succs (2): B32 B29

 [B34]
   1: j = 1
   Preds (1): B35
   Succs (1): B33

 [B35]
   1: i <= n
   T: for (...; [B35.1]; ...)
   Preds (2): B29 B36
   Succs (2): B34 B28

 [B36]
   1: int a[10][10];
   2: int n;
   3: int i;
   4: int j;
   5: int k;
   6: double st;
   7: double et;
   8: double tt;
   9: printf("\nEnter the number of nodes")
  10: scanf("%d", &n)
  11: printf("\nEnter the cost matrix")
  12: i = 1
   Preds (1): B37
   Succs (1): B35

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Leaky-Bucket/LeakyBucket.cpp

function-decl: main main
param-decl: 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return 0;
   Preds (1): B8
   Succs (1): B0

 [B2]
   1: i++
   Preds (3): B3 B4 B6
   Succs (1): B8

 [B3]
   1: cbs -= outr
   Preds (1): B5
   Succs (1): B2

 [B4]
   Preds (1): B5
   Succs (1): B2

 [B5]
   1: cbs < outr
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: cbs = bs
   Preds (1): B7
   Succs (1): B2

 [B7]
   1: cbs += ip
   2: cbs > (bs + outr)
   T: if [B7.2]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: i < 200
   T: for (...; [B8.1]; ...)
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int bs;
   2: int outr;
   3: int ip;
   4: int cbs = 0;
   5: int i;
   6: i = 0
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Heap Sort/heap.c

function-decl: hp_create hp_create
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: calloc(1, sizeof(heap_ctrl_t))
   2: heap_ctrl_t *h = (heap_ctrl_t *)calloc(1, sizeof(heap_ctrl_t));
   3: return h;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: hp_destroy hp_destroy
param-decl: heap_ctrl_t **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: free((*heap)->array)
   2: memset(*heap, 0, sizeof(heap_ctrl_t))
   3: free(*heap)
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: hp_insert hp_insert
param-decl: heap_ctrl_t *; int32_t; 

 [B14 (ENTRY)]
   Succs (1): B13

 [B1]
   1: ++heap->next
   Preds (1): B8
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B8

 [B3]
   1: heap->array[leaf] = heap->array[parent]
   2: heap->array[parent] = datas
   3: leaf = parent
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: heap->array[parent]->data <= data
   T: if [B4.1]
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   1: parent = (parent - 1) / 2
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: parent = (parent - 2) / 2
   Preds (1): B7
   Succs (1): B4

 [B7]
   1: parent % 2 == 0
   T: if [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: parent != 0
   T: while [B8.1]
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int32_t parent;
   2: int32_t leaf;
   3: calloc(1, sizeof(data_t))
   4: data_t *datas = (data_t *)calloc(1, sizeof(data_t));
   5: datas->data = data
   6: heap->array[heap->next] = datas
   7: parent = heap->next
   8: leaf = heap->next
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: return -2;
   Preds (1): B11
   Succs (1): B0

 [B11]
   T: if <null expr>
   Preds (1): B13
   Succs (2): B10 B9

 [B12]
   1: return -1;
   Preds (1): B13
   Succs (1): B0

 [B13]
   T: if <null expr>
   Preds (1): B14
   Succs (2): B12 B11

 [B0 (EXIT)]
   Preds (3): B1 B10 B12

function-decl: hp_remove hp_remove
param-decl: heap_ctrl_t *; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: --heap->next
   2: heap->array[0] = heap->array[heap->next]
   3: hp_heapfy(heap)
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: free(heap->array[0])
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return -3;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: heap->next == 0
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return -1;
   Preds (1): B7
   Succs (1): B0

 [B7]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (3): B1 B4 B6

function-decl: hp_heapfy hp_heapfy
param-decl: heap_ctrl_t *; 

 [B17 (ENTRY)]
   Succs (1): B16

 [B1]
   Preds (3): B3 B5 B8
   Succs (1): B13

 [B2]
   T: break;
   Preds (1): B4
   Succs (1): B0

 [B3]
   Preds (1): B4
   Succs (1): B1

 [B4]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   Preds (1): B6
   Succs (1): B1

 [B6]
   T: if <null expr>
   Preds (1): B12
   Succs (2): B5 B4

 [B7]
   T: break;
   Preds (1): B9
   Succs (1): B0

 [B8]
   Preds (1): B9
   Succs (1): B1

 [B9]
   T: if <null expr>
   Preds (1): B11
   Succs (2): B8 B7

 [B10]
   T: break;
   Preds (1): B11
   Succs (1): B0

 [B11]
   T: if <null expr>
   Preds (1): B12
   Succs (2): B10 B9

 [B12]
   T: if <null expr>
   Preds (1): B13
   Succs (2): B11 B6

 [B13]
   1: 1
   T: while [B13.1]
   Preds (2): B1 B14
   Succs (2): B12 NULL

 [B14]
   1: int32_t parent = 0;
   Preds (1): B16
   Succs (1): B13

 [B15]
   1: return -1;
   Preds (1): B16
   Succs (1): B0

 [B16]
   T: if <null expr>
   Preds (1): B17
   Succs (2): B15 B14

 [B0 (EXIT)]
   Preds (4): B2 B7 B10 B15

function-decl: hp_swap hp_swap
param-decl: data_t **; data_t **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: data_t *tmp;
   2: tmp = *a
   3: *a = *b
   4: *b = tmp
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: hp_sort hp_sort
param-decl: heap_ctrl_t *; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: free(sorted)
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: ++i
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: heap->array[i] = sorted[i]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < (int32_t)heap->next
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: i = 0
   Preds (1): B8
   Succs (1): B4

 [B6]
   1: --i
   Preds (1): B7
   Succs (1): B8

 [B7]
   1: sorted[i] = heap->array[0]
   2: heap->array[0] = heap->array[i]
   3: hp_heapfy(heap)
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: i >= 0
   T: for (...; [B8.1]; ...)
   Preds (2): B6 B9
   Succs (2): B7 B5

 [B9]
   1: data_t **sorted;
   2: int32_t i;
   3: i = (heap->next - 1)
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: return -1;
   Preds (1): B11
   Succs (1): B0

 [B11]
   T: if <null expr>
   Preds (1): B12
   Succs (2): B10 B9

 [B0 (EXIT)]
   Preds (2): B1 B10

function-decl: hp_get_head hp_get_head
param-decl: heap_ctrl_t *; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return heap->array[0]->data;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return -3;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: heap->next == 0
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return -1;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (3): B1 B2 B4

function-decl: hp_print hp_print
param-decl: heap_ctrl_t *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: printf("[")
   2: printf("]\n")
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/Algorithms/C/Heap Sort/main.c

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: heap_ctrl_t *h;
   2: hp_insert(h, 88)
   3: hp_insert(h, 85)
   4: hp_insert(h, 83)
   5: hp_insert(h, 72)
   6: hp_insert(h, 73)
   7: hp_insert(h, 42)
   8: hp_insert(h, 57)
   9: hp_insert(h, 6)
  10: hp_insert(h, 48)
  11: hp_insert(h, 60)
  12: hp_print(h)
  13: hp_sort(h)
  14: hp_print(h)
  15: hp_remove(h)
  16: hp_print(h)
  17: hp_remove(h)
  18: hp_print(h)
  19: hp_remove(h)
  20: hp_print(h)
  21: hp_remove(h)
  22: hp_print(h)
  23: hp_remove(h)
  24: hp_print(h)
  25: hp_remove(h)
  26: hp_print(h)
  27: hp_remove(h)
  28: hp_print(h)
  29: hp_destroy(&h)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Heap Sort/heap.h


filename: /Users/yingcao/re/DataSets/Algorithms/C/Radix Sort/RadixSort.c

function-decl: largest largest
param-decl: int *; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: return large;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   1: large = a[i]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: large < a[i]
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < n
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int large = a[0];
   2: int i;
   3: i = 1
   Preds (1): B7
   Succs (1): B5

 [B0 (EXIT)]
   Preds (1): B1

function-decl: RadixSort RadixSort
param-decl: int *; int; 

 [B28 (ENTRY)]
   Succs (1): B27

 [B1]
   1: pass++
   Preds (1): B2
   Succs (1): B22

 [B2]
   1: printf("\n")
   Preds (1): B5
   Succs (1): B1

 [B3]
   1: i++
   Preds (1): B4
   Succs (1): B5

 [B4]
   1: printf("%d  ", a[i])
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: i < n
   T: for (...; [B5.1]; ...)
   Preds (2): B3 B6
   Succs (2): B4 B2

 [B6]
   1: divisor *= 10
   2: i = 0
   Preds (1): B12
   Succs (1): B5

 [B7]
   1: k++
   Preds (1): B10
   Succs (1): B12

 [B8]
   1: j++
   Preds (1): B9
   Succs (1): B10

 [B9]
   1: a[i] = bucket[k][j]
   2: i++
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: j < bucket_count[k]
   T: for (...; [B10.1]; ...)
   Preds (2): B8 B11
   Succs (2): B9 B7

 [B11]
   1: j = 0
   Preds (1): B12
   Succs (1): B10

 [B12]
   1: k < 10
   T: for (...; [B12.1]; ...)
   Preds (2): B7 B13
   Succs (2): B11 B6

 [B13]
   1: i = 0
   2: k = 0
   Preds (1): B16
   Succs (1): B12

 [B14]
   1: i++
   Preds (1): B15
   Succs (1): B16

 [B15]
   1: remainder = (a[i] / divisor) % 10
   2: bucket[remainder][bucket_count[remainder]] = a[i]
   3: bucket_count[remainder] += 1
   Preds (1): B16
   Succs (1): B14

 [B16]
   1: i < n
   T: for (...; [B16.1]; ...)
   Preds (2): B14 B17
   Succs (2): B15 B13

 [B17]
   1: i = 0
   Preds (1): B20
   Succs (1): B16

 [B18]
   1: i++
   Preds (1): B19
   Succs (1): B20

 [B19]
   1: bucket_count[i] = 0
   Preds (1): B20
   Succs (1): B18

 [B20]
   1: i < 10
   T: for (...; [B20.1]; ...)
   Preds (2): B18 B21
   Succs (2): B19 B17

 [B21]
   1: i = 0
   Preds (1): B22
   Succs (1): B20

 [B22]
   1: pass < NOP
   T: for (...; [B22.1]; ...)
   Preds (2): B1 B23
   Succs (2): B21 B0

 [B23]
   1: pass = 0
   Preds (1): B26
   Succs (1): B22

 [B24]
   Preds (1): B25
   Succs (1): B26

 [B25]
   1: NOP++
   2: large /= 10
   Preds (1): B26
   Succs (1): B24

 [B26]
   1: large > 0
   T: while [B26.1]
   Preds (2): B24 B27
   Succs (2): B25 B23

 [B27]
   1: int bucket[10][10];
   2: int bucket_count[10];
   3: int i;
   4: int j;
   5: int k;
   6: int remainder;
   7: int NOP = 0;
   8: int divisor = 1;
   9: int large;
  10: int pass;
  11: largest(a, n)
  12: large = [B27.11]
  13: printf("The large element %d\n", large)
   Preds (1): B28
   Succs (1): B26

 [B0 (EXIT)]
   Preds (1): B22

function-decl: main main
param-decl: 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: printf("\n")
   2: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: printf("%d  ", a[i])
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < n
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: RadixSort(a, n)
   2: printf("The sorted elements are ::  ")
   3: i = 0
   Preds (1): B8
   Succs (1): B4

 [B6]
   1: i++
   Preds (1): B7
   Succs (1): B8

 [B7]
   1: scanf("%d", &a[i])
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: i < n
   T: for (...; [B8.1]; ...)
   Preds (2): B6 B9
   Succs (2): B7 B5

 [B9]
   1: int i;
   2: int n;
   3: int a[10];
   4: printf("Enter the number of elements :: ")
   5: scanf("%d", &n)
   6: printf("Enter the elements :: ")
   7: i = 0
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Hamming Distance/HammingDistance.c

function-decl: HammingDistance HammingDistance
param-decl: char *; char *; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   1: return dist;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   1: dist++
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: str1[i] != str2[i]
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i < LEN
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: i = 0
   Preds (1): B8
   Succs (1): B5

 [B7]
   1: return -1;
   Preds (1): B8
   Succs (1): B0

 [B8]
   1: strlen(str2)
   2: LEN != [B8.1]
   T: if [B8.2]
   Preds (1): B10
   Succs (2): B7 B6

 [B9]
   1: return -1;
   Preds (1): B10
   Succs (1): B0

 [B10]
   1: int i;
   2: int dist = 0;
   3: strlen(str1)
   4: int LEN = strlen(str1);
   T: if <null expr>
   Preds (1): B11
   Succs (2): B9 B8

 [B0 (EXIT)]
   Preds (3): B1 B7 B9

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: char *seq1 = "110110";
   2: char *seq2 = "111110";
   3: char *seq3 = "110000";
   4: HammingDistance(seq1, seq1)
   5: printf("Test1 distance=%d\n", [B1.4])
   6: HammingDistance(seq1, seq2)
   7: printf("Test2 distance=%d\n", [B1.6])
   8: HammingDistance(seq1, seq3)
   9: printf("Test3 distance=%d\n", [B1.8])
  10: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/knapsack/Knapsack.c

function-decl: max max
param-decl: int; int; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: return j;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return i;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: i > j
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: knap knap
param-decl: int; int; 

 [B7 (ENTRY)]
   Succs (1): B6

 [B1]
   1: return k[i][j];
   Preds (2): B2 B6
   Succs (1): B0

 [B2]
   1: k[i][j] = value
   Preds (2): B3 B4
   Succs (1): B1

 [B3]
   1: knap(i - 1, j)
   2: knap(i - 1, j - w[i])
   3: max([B3.1], p[i] + [B3.2])
   4: value = [B3.3]
   Preds (1): B5
   Succs (1): B2

 [B4]
   1: knap(i - 1, j)
   2: value = [B4.1]
   Preds (1): B5
   Succs (1): B2

 [B5]
   1: j - w[i] < 0
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: int value;
   2: k[i][j] < 0
   T: if [B6.2]
   Preds (1): B7
   Succs (2): B5 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B32 (ENTRY)]
   Succs (1): B31

 [B1]
   1: printf("\nThe profit is=%d", profit)
   2: getch()
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   1: printf("\nItem=%d\t weight=%d\t profit=%d", i, w[i], p[i])
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: x[i] == 1
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i <= n
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: printf("\nThe items selected are")
   2: i = 1
   Preds (2): B11 B12
   Succs (1): B5

 [B7]
   Preds (2): B8 B9
   Succs (1): B12

 [B8]
   1: x[i] = 1
   2: j = j - w[i]
   3: i--
   Preds (1): B10
   Succs (1): B7

 [B9]
   1: i--
   Preds (1): B10
   Succs (1): B7

 [B10]
   1: k[i][j] == k[i - 1][j]
   T: if [B10.1]
   Preds (1): B11
   Succs (2): B9 B8

 [B11]
   1: j != 0
   T: while ([B12.1]) && ([B11.1])
   Preds (1): B12
   Succs (2): B10 B6

 [B12]
   1: i != 0
   T: ([B12.1]) && ...
   Preds (2): B7 B13
   Succs (2): B11 B6

 [B13]
   1: knap(n, m)
   2: profit = [B13.1]
   3: i = n
   4: j = m
   Preds (1): B22
   Succs (1): B12

 [B14]
   1: i++
   Preds (1): B20
   Succs (1): B22

 [B15]
   1: j++
   Preds (2): B16 B17
   Succs (1): B20

 [B16]
   1: k[i][j] = -1
   Preds (1): B18
   Succs (1): B15

 [B17]
   1: k[i][j] = 0
   Preds (2): B18 B19
   Succs (1): B15

 [B18]
   1: j == 0
   T: if ([B19.1]) || ([B18.1])
   Preds (1): B19
   Succs (2): B17 B16

 [B19]
   1: i == 0
   T: ([B19.1]) || ...
   Preds (1): B20
   Succs (2): B17 B18

 [B20]
   1: j < m + 1
   T: for (...; [B20.1]; ...)
   Preds (2): B15 B21
   Succs (2): B19 B14

 [B21]
   1: j = 0
   Preds (1): B22
   Succs (1): B20

 [B22]
   1: i < n + 1
   T: for (...; [B22.1]; ...)
   Preds (2): B14 B23
   Succs (2): B21 B13

 [B23]
   1: i = 0
   Preds (1): B26
   Succs (1): B22

 [B24]
   1: i++
   Preds (1): B25
   Succs (1): B26

 [B25]
   1: scanf("%d", &p[i])
   Preds (1): B26
   Succs (1): B24

 [B26]
   1: i <= n
   T: for (...; [B26.1]; ...)
   Preds (2): B24 B27
   Succs (2): B25 B23

 [B27]
   1: printf("\nEnter the profits for the elements")
   2: i = 1
   Preds (1): B30
   Succs (1): B26

 [B28]
   1: i++
   Preds (1): B29
   Succs (1): B30

 [B29]
   1: scanf("%d", &w[i])
   Preds (1): B30
   Succs (1): B28

 [B30]
   1: i <= n
   T: for (...; [B30.1]; ...)
   Preds (2): B28 B31
   Succs (2): B29 B27

 [B31]
   1: clrscr()
   2: printf("Enter the number of elements")
   3: scanf("%d", &n)
   4: printf("\nEnter the maximun capacity of the knapsack")
   5: scanf("%d", &m)
   6: printf("\nEnter the wieghts of the elements")
   7: i = 1
   Preds (1): B32
   Succs (1): B30

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/BinarySearch/BinarySearch.c

function-decl: main main
param-decl: 

 [B13 (ENTRY)]
   Succs (1): B12

 [B1]
   1: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: printf("Not found! %d is not present in the list.\n", search)
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: first > last
   T: if [B3.1]
   Preds (2): B7 B11
   Succs (2): B2 B1

 [B4]
   Preds (1): B5
   Succs (1): B11

 [B5]
   1: mid = (first + last) / 2
   Preds (2): B6 B9
   Succs (1): B4

 [B6]
   1: last = mid - 1
   Preds (1): B8
   Succs (1): B5

 [B7]
   1: printf("%d found at location %d.\n", search, mid + 1)
   T: break;
   Preds (1): B8
   Succs (1): B3

 [B8]
   1: array[mid] == search
   T: if [B8.1]
   Preds (1): B10
   Succs (2): B7 B6

 [B9]
   1: first = mid + 1
   Preds (1): B10
   Succs (1): B5

 [B10]
   1: array[mid] < search
   T: if [B10.1]
   Preds (1): B11
   Succs (2): B9 B8

 [B11]
   1: first <= last
   T: while [B11.1]
   Preds (2): B4 B12
   Succs (2): B10 B3

 [B12]
   1: int first;
   2: int last;
   3: int n = 10;
   4: int array[10];
   5: int mid;
   6: int search;
   7: int array[10];
   8: scanf("%d", &search)
   9: first = 0
  10: last = n - 1
  11: mid = (first + last) / 2
   Preds (1): B13
   Succs (1): B11

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Union Find/union_find.c

function-decl: initialize initialize
param-decl: int *; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: Arr[i] = i
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: i <= n
   T: for (...; [B3.1]; ...)
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: int i = 1;
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B3

function-decl: root root
param-decl: int *; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: return i;
   Preds (1): B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: i = Arr[i]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: Arr[i] != i
   T: while [B4.1]
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B0 (EXIT)]
   Preds (1): B1

function-decl: union_find union_find
param-decl: int; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/swap/swap.c

function-decl: swap swap
param-decl: int *; int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int temp = *a;
   2: *a = *b
   3: *b = temp
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a;
   2: int b;
   3: printf("Enter first number-\n")
   4: scanf("%d", &a)
   5: printf("Enter second number-\n")
   6: scanf("%d", &b)
   7: swap(&a, &b)
   8: printf("First number after swapping- %d\n", a)
   9: printf("Second number after swapping- %d\n", b)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Xor Swap/XorSwap.c

function-decl: xorSwap xorSwap
param-decl: int *; int *; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: *x ^= *y
   2: *y ^= *x
   3: *x ^= *y
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: x != y
   T: if [B2.1]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a;
   2: int b;
   3: a = 10
   4: b = 45
   5: printf("Values before Swap\n a=%d,b=%d\n", a, b)
   6: xorSwap(&a, &b)
   7: printf("Values after Swap\n a=%d,b=%d\n", a, b)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Bubble Sort/bubblesort.c

function-decl: main main
param-decl: 

 [B18 (ENTRY)]
   Succs (1): B17

 [B1]
   1: printf("\n")
   2: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: printf("%d ", A[i])
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < n
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: printf("Array after sorting\n")
   2: i = 0
   Preds (1): B12
   Succs (1): B4

 [B6]
   1: i++
   Preds (1): B10
   Succs (1): B12

 [B7]
   1: j--
   Preds (2): B8 B9
   Succs (1): B10

 [B8]
   1: temp = A[j]
   2: A[i] = A[i - 1]
   3: A[i - 1] = temp
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: A[j] < A[j - 1]
   T: if [B9.1]
   Preds (1): B10
   Succs (2): B8 B7

 [B10]
   1: j > i
   T: for (...; [B10.1]; ...)
   Preds (2): B7 B11
   Succs (2): B9 B6

 [B11]
   1: j = n
   Preds (1): B12
   Succs (1): B10

 [B12]
   1: i < n
   T: for (...; [B12.1]; ...)
   Preds (2): B6 B13
   Succs (2): B11 B5

 [B13]
   1: printf("\n")
   2: i = 0
   Preds (1): B16
   Succs (1): B12

 [B14]
   1: i++
   Preds (1): B15
   Succs (1): B16

 [B15]
   1: rand()
   2: A[i] = [B15.1] % 1000
   3: printf("%d ", A[i])
   Preds (1): B16
   Succs (1): B14

 [B16]
   1: i < n
   T: for (...; [B16.1]; ...)
   Preds (2): B14 B17
   Succs (2): B15 B13

 [B17]
   1: int n;
   2: int i;
   3: int j;
   4: int temp;
   5: printf("Enter number of elements in array\n")
   6: scanf("%d", &n)
   7: n (ImplicitCastExpr, LValueToRValue, int)
   8: int A[n];
   9: printf("Array before sorting\n")
  10: i = 0
   Preds (1): B18
   Succs (1): B16

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Insertion Sort/InsertionSort.c

function-decl: Sort_Array Sort_Array
param-decl: int *; int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B8

 [B2]
   1: arr[j + 1] = key
   Preds (2): B5 B6
   Succs (1): B1

 [B3]
   Preds (1): B4
   Succs (1): B6

 [B4]
   1: arr[j + 1] = arr[j]
   2: j--
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: arr[j] > key
   T: while [B6.1] && [B5.1]
   Preds (1): B6
   Succs (2): B4 B2

 [B6]
   1: j >= 0
   T: [B6.1] && ...
   Preds (2): B3 B7
   Succs (2): B5 B2

 [B7]
   1: key = arr[i]
   2: j = i - 1
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: i < size
   T: for (...; [B8.1]; ...)
   Preds (2): B1 B9
   Succs (2): B7 B0

 [B9]
   1: int i;
   2: int key;
   3: int j;
   4: i = 1
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B8

function-decl: main main
param-decl: 

 [B14 (ENTRY)]
   Succs (1): B13

 [B1]
   1: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: printf("%d ", array[i])
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < size
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: Sort_Array(array, size)
   2: printf("\nsorted array -> ")
   3: i = 0
   Preds (1): B8
   Succs (1): B4

 [B6]
   1: i++
   Preds (1): B7
   Succs (1): B8

 [B7]
   1: printf("%d ", array[i])
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: i < size
   T: for (...; [B8.1]; ...)
   Preds (2): B6 B9
   Succs (2): B7 B5

 [B9]
   1: printf("\noriginal array -> ")
   2: i = 0
   Preds (1): B12
   Succs (1): B8

 [B10]
   1: i++
   Preds (1): B11
   Succs (1): B12

 [B11]
   1: scanf("%d", &array[i])
   Preds (1): B12
   Succs (1): B10

 [B12]
   1: i < size
   T: for (...; [B12.1]; ...)
   Preds (2): B10 B13
   Succs (2): B11 B9

 [B13]
   1: int size;
   2: int i;
   3: printf("enter the size of array ")
   4: scanf("%d", &size)
   5: size (ImplicitCastExpr, LValueToRValue, int)
   6: int array[size];
   7: printf("\nenter values in the array\n")
   8: i = 0
   Preds (1): B14
   Succs (1): B12

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Merge Sort/mergesort.c

function-decl: main main
param-decl: 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: printf("\nCount is %d", count)
   2: getch()
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: printf("%d", arr[i])
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < n
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: merge_sort(arr, 0, n - 1)
   2: i = 0
   Preds (1): B8
   Succs (1): B4

 [B6]
   1: i++
   Preds (1): B7
   Succs (1): B8

 [B7]
   1: scanf("%d", &arr[i])
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: i < n
   T: for (...; [B8.1]; ...)
   Preds (2): B6 B9
   Succs (2): B7 B5

 [B9]
   1: int n;
   2: int i;
   3: clrscr()
   4: printf("Enter the total number of elements to be sorted\n")
   5: scanf("%d", &n)
   6: printf("Enter the elements\n")
   7: i = 0
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B1

function-decl: merge merge
param-decl: int *; int; int; int; 

 [B20 (ENTRY)]
   Succs (1): B19

 [B1]
   1: k++
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: arr[k] = temp[k]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: k < index
   T: for (...; [B3.1]; ...)
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: k = beg
   Preds (2): B7 B10
   Succs (1): B3

 [B5]
   Preds (1): B6
   Succs (1): B7

 [B6]
   1: temp[index] = arr[i]
   2: i++
   3: index++
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: i <= mid
   T: while [B7.1]
   Preds (2): B5 B11
   Succs (2): B6 B4

 [B8]
   Preds (1): B9
   Succs (1): B10

 [B9]
   1: temp[index] = arr[j]
   2: j++
   3: index++
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: j <= end
   T: while [B10.1]
   Preds (2): B8 B11
   Succs (2): B9 B4

 [B11]
   1: i > mid
   T: if [B11.1]
   Preds (2): B17 B18
   Succs (2): B10 B7

 [B12]
   Preds (1): B13
   Succs (1): B18

 [B13]
   1: index++
   Preds (2): B14 B15
   Succs (1): B12

 [B14]
   1: temp[index] = arr[j]
   2: j++
   Preds (1): B16
   Succs (1): B13

 [B15]
   1: temp[index] = arr[i]
   2: i++
   Preds (1): B16
   Succs (1): B13

 [B16]
   1: arr[i] < arr[j]
   T: if [B16.1]
   Preds (1): B17
   Succs (2): B15 B14

 [B17]
   1: j <= end
   T: while ([B18.1]) && ([B17.1])
   Preds (1): B18
   Succs (2): B16 B11

 [B18]
   1: i <= mid
   T: ([B18.1]) && ...
   Preds (2): B12 B19
   Succs (2): B17 B11

 [B19]
   1: int k;
   2: int i = beg;
   3: int j = mid + 1;
   4: int index = beg;
   5: int temp[100];
   Preds (1): B20
   Succs (1): B18

 [B0 (EXIT)]
   Preds (1): B3

function-decl: merge_sort merge_sort
param-decl: int *; int; int; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: count++
   2: mid = (beg + end) / 2
   3: merge_sort(arr, beg, mid)
   4: merge_sort(arr, mid + 1, end)
   5: merge(arr, beg, mid, end)
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: int mid;
   2: beg < end
   T: if [B2.2]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/Algorithms/C/Quick Sort/QuickSort.c

function-decl: quicksort quicksort
param-decl: int *; int; int; 

 [B15 (ENTRY)]
   Succs (1): B14

 [B1]
   1: temp = number[pivot]
   2: number[pivot] = number[j]
   3: number[j] = temp
   4: quicksort(number, first, j - 1)
   5: quicksort(number, j + 1, last)
   Preds (1): B12
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B12

 [B3]
   1: temp = number[i]
   2: number[i] = number[j]
   3: number[j] = temp
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < j
   T: if [B4.1]
   Preds (1): B7
   Succs (2): B3 B2

 [B5]
   Preds (1): B6
   Succs (1): B7

 [B6]
   1: j--
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: number[j] > number[pivot]
   T: while [B7.1]
   Preds (3): B5 B10 B11
   Succs (2): B6 B4

 [B8]
   Preds (1): B9
   Succs (1): B11

 [B9]
   1: i++
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: i < last
   T: while [B11.1] && [B10.1]
   Preds (1): B11
   Succs (2): B9 B7

 [B11]
   1: number[i] <= number[pivot]
   T: [B11.1] && ...
   Preds (2): B8 B12
   Succs (2): B10 B7

 [B12]
   1: i < j
   T: while [B12.1]
   Preds (2): B2 B13
   Succs (2): B11 B1

 [B13]
   1: pivot = first
   2: i = first
   3: j = last
   Preds (1): B14
   Succs (1): B12

 [B14]
   1: int i;
   2: int j;
   3: int pivot;
   4: int temp;
   5: first < last
   T: if [B14.5]
   Preds (1): B15
   Succs (2): B13 B0

 [B0 (EXIT)]
   Preds (2): B1 B14

function-decl: main main
param-decl: 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: printf(" %d", number[i])
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < count
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: quicksort(number, 0, count - 1)
   2: printf("Order of Sorted elements: ")
   3: i = 0
   Preds (1): B8
   Succs (1): B4

 [B6]
   1: i++
   Preds (1): B7
   Succs (1): B8

 [B7]
   1: scanf("%d", &number[i])
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: i < count
   T: for (...; [B8.1]; ...)
   Preds (2): B6 B9
   Succs (2): B7 B5

 [B9]
   1: int i;
   2: int count;
   3: int number[25];
   4: printf("How many elements are u going to enter?: ")
   5: scanf("%d", &count)
   6: printf("Enter %d elements: ", count)
   7: i = 0
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Quick Sort/QuickSortV2.c

function-decl: quicksort quicksort
param-decl: int *; int; int; 

 [B15 (ENTRY)]
   Succs (1): B14

 [B1]
   1: temp = number[pivot]
   2: number[pivot] = number[j]
   3: number[j] = temp
   4: quicksort(number, first, j - 1)
   5: quicksort(number, j + 1, last)
   Preds (1): B12
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B12

 [B3]
   1: temp = number[i]
   2: number[i] = number[j]
   3: number[j] = temp
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < j
   T: if [B4.1]
   Preds (1): B7
   Succs (2): B3 B2

 [B5]
   Preds (1): B6
   Succs (1): B7

 [B6]
   1: j--
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: number[j] > number[pivot]
   T: while [B7.1]
   Preds (3): B5 B10 B11
   Succs (2): B6 B4

 [B8]
   Preds (1): B9
   Succs (1): B11

 [B9]
   1: i++
   Preds (1): B10
   Succs (1): B8

 [B10]
   1: i < last
   T: while [B11.1] && [B10.1]
   Preds (1): B11
   Succs (2): B9 B7

 [B11]
   1: number[i] <= number[pivot]
   T: [B11.1] && ...
   Preds (2): B8 B12
   Succs (2): B10 B7

 [B12]
   1: i < j
   T: while [B12.1]
   Preds (2): B2 B13
   Succs (2): B11 B1

 [B13]
   1: pivot = first
   2: i = first
   3: j = last
   Preds (1): B14
   Succs (1): B12

 [B14]
   1: int i;
   2: int j;
   3: int pivot;
   4: int temp;
   5: first < last
   T: if [B14.5]
   Preds (1): B15
   Succs (2): B13 B0

 [B0 (EXIT)]
   Preds (2): B1 B14

function-decl: main main
param-decl: 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: printf(" %d", number[i])
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < count
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: quicksort(number, 0, count - 1)
   2: printf("Order of Sorted elements: ")
   3: i = 0
   Preds (1): B8
   Succs (1): B4

 [B6]
   1: i++
   Preds (1): B7
   Succs (1): B8

 [B7]
   1: scanf("%d", &number[i])
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: i < count
   T: for (...; [B8.1]; ...)
   Preds (2): B6 B9
   Succs (2): B7 B5

 [B9]
   1: int i;
   2: int count;
   3: int number[25];
   4: printf("How many elements are u going to enter?: ")
   5: scanf("%d", &count)
   6: printf("Enter %d elements: ", count)
   7: i = 0
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Fast Fourier Transform/fft_c.c

function-decl: _fft _fft
param-decl: int *; int *; int; int; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: i += 2 * step
   Preds (1): B2
   Succs (1): B2

 [B2]
   1: i < n
   T: for (...; [B2.1]; ...)
   Preds (2): B1 B3
   Succs (2): B1 B0

 [B3]
   1: int i = 0;
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: step < n
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B0

 [B0 (EXIT)]
   Preds (2): B2 B4

function-decl: fft fft
param-decl: int *; int; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: show show
param-decl: const char *; int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: printf("%s", s)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: atan2(1, 1)
   2: PI = [B1.1] * 4
   3: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Greatest Common Divisor/EuclideanGCD.c

function-decl: gcd gcd
param-decl: int; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return a;
   Preds (1): B4
   Succs (1): B0

 [B2]
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: temp = a % b
   2: a = b
   3: b = temp
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: b != 0
   T: while [B4.1]
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int temp;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int a;
   2: int b;
   3: scanf("%d %d", &a, &b)
   4: gcd(a, b)
   5: printf("%d\n", [B1.4])
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Kadane's/kadanes.c

function-decl: main main
param-decl: 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: printf("Max sum is %d\n", globalMax)
   2: return 0;
   Preds (1): B8
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B8

 [B3]
   1: currentMax = 0
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: [B7.2] ? [B5.1] : [B6.1]
   2: globalMax = [B4.1]
   3: currentMax < 0
   T: if [B4.3]
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   1: currentMax (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: globalMax (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B7
   Succs (1): B4

 [B7]
   1: currentMax += v[i]
   2: globalMax < currentMax
   T: [B7.2] ? ... : ...
   Preds (1): B8
   Succs (2): B5 B6

 [B8]
   1: i < size
   T: for (...; [B8.1]; ...)
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int v[] = {-2, -3, 4, -1, -2, 1, 5, -3};
   2: int currentMax = 0;
   3: int globalMax = (-2147483647 - 1);
   4: int size = sizeof (v) / sizeof (v[0]);
   5: int i = 0;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Segmented-Sieve/segmented_sieve.cpp

function-decl: simpleSieve simpleSieve
param-decl: int; int &; 

 [B14 (ENTRY)]
   Succs (1): B13

 [B1]
   1: p++
   Preds (2): B2 B3
   Succs (1): B4

 [B2]
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: mark[p] == true
   T: if [B3.1]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: p < limit
   T: for (...; [B4.1]; ...)
   Preds (2): B1 B5
   Succs (2): B3 B0

 [B5]
   1: int p = 2;
   Preds (1): B12
   Succs (1): B4

 [B6]
   1: p++
   Preds (2): B9 B11
   Succs (1): B12

 [B7]
   1: i += p
   Preds (1): B8
   Succs (1): B9

 [B8]
   1: mark[i] = false
   Preds (1): B9
   Succs (1): B7

 [B9]
   1: i < limit
   T: for (...; [B9.1]; ...)
   Preds (2): B7 B10
   Succs (2): B8 B6

 [B10]
   1: int i = p * 2;
   Preds (1): B11
   Succs (1): B9

 [B11]
   1: mark[p] == true
   T: if [B11.1]
   Preds (1): B12
   Succs (2): B10 B6

 [B12]
   1: p * p < limit
   T: for (...; [B12.1]; ...)
   Preds (2): B6 B13
   Succs (2): B11 B5

 [B13]
   1: limit + 1
   2: _Bool mark[limit + 1];
   3: int p = 2;
   Preds (1): B14
   Succs (1): B12

 [B0 (EXIT)]
   Preds (1): B4

function-decl: segmentedSieve segmentedSieve
param-decl: int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   Preds (2): B2 B3
   Succs (1): B4

 [B2]
   1: high = n
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: limit + 1
   2: _Bool mark[limit + 1];
   3: low = low + limit
   4: high = high + limit
   5: high >= n
   T: if [B3.5]
   Preds (1): B4
   Succs (2): B2 B1

 [B4]
   1: low < n
   T: while [B4.1]
   Preds (2): B1 B5
   Succs (2): B3 B0

 [B5]
   1: int limit;
   2: int prime;
   3: int low = limit;
   4: int high = 2 * limit;
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B4

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int n = 100;
   2: segmentedSieve(n)
   3: return 0;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Fibonacci/fibonacci.c

function-decl: main main
param-decl: 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: printf("%d, ", num1)
   2: temp = num1 + num2
   3: num1 = num2
   4: num2 = temp
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i <= v
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int i;
   2: int v;
   3: int num1 = 0;
   4: int num2 = 1;
   5: int temp;
   6: scanf("%d", &v)
   7: printf("Fibonacci numbers:")
   8: i = 0
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/Connected Component Labeling/component_label.cpp

function-decl: dfs dfs
param-decl: int; int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: vis[s] = true
   2: label[s] = subgraph_no
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: return 0;
   Preds (1): B5
   Succs (1): B0

 [B2]
   1: i++
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   1: dfs(i, sub)
   2: sub++
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: !vis[i]
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: i <= n
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: int i = 1;
   Preds (1): B8
   Succs (1): B5

 [B7]
   Preds (1): B8
   Succs (1): B8

 [B8]
   1: m-- (ImplicitCastExpr, IntegralToBoolean, _Bool)
   T: while [B8.1]
   Preds (2): B7 B9
   Succs (2): B7 B6

 [B9]
   1: int n;
   2: int m;
   3: int a;
   4: int b;
   5: int sub = 1;
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/HeapSort/V1/HeapSort.c

function-decl: down_adjust down_adjust
param-decl: int *; int; 

 [B11 (ENTRY)]
   Succs (1): B10

 [B1]
   Preds (2): B2 B3
   Succs (1): B9

 [B2]
   1: temp = heap[i]
   2: heap[i] = heap[j]
   3: heap[j] = temp
   4: i = j
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: flag = 0
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: heap[i] > heap[j]
   T: if [B4.1]
   Preds (3): B5 B6 B7
   Succs (2): B3 B2

 [B5]
   1: j = j + 1
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: heap[j + 1] > heap[j]
   T: if [B7.2] && [B6.1]
   Preds (1): B7
   Succs (2): B5 B4

 [B7]
   1: j = 2 * i
   2: j + 1 <= n
   T: [B7.2] && ...
   Preds (1): B8
   Succs (2): B6 B4

 [B8]
   1: flag == 1
   T: while [B9.1] && [B8.1]
   Preds (1): B9
   Succs (2): B7 B0

 [B9]
   1: 2 * i <= n
   T: [B9.1] && ...
   Preds (2): B1 B10
   Succs (2): B8 B0

 [B10]
   1: int j;
   2: int temp;
   3: int n;
   4: int flag = 1;
   5: n = heap[0]
   Preds (1): B11
   Succs (1): B9

 [B0 (EXIT)]
   Preds (2): B8 B9

function-decl: create create
param-decl: int *; 

 [B5 (ENTRY)]
   Succs (1): B4

 [B1]
   1: i--
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: down_adjust(heap, i)
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: i >= 1
   T: for (...; [B3.1]; ...)
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: int i;
   2: int n;
   3: n = heap[0]
   4: i = n / 2
   Preds (1): B5
   Succs (1): B3

 [B0 (EXIT)]
   Preds (1): B3

function-decl: main main
param-decl: 

 [B13 (ENTRY)]
   Succs (1): B12

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B3

 [B2]
   1: printf("%d ", heap[i])
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: i <= n
   T: for (...; [B3.1]; ...)
   Preds (2): B1 B4
   Succs (2): B2 B0

 [B4]
   1: printf("\nArray after sorting:\n")
   2: i = 1
   Preds (1): B7
   Succs (1): B3

 [B5]
   Preds (1): B6
   Succs (1): B7

 [B6]
   1: last = heap[0]
   2: temp = heap[1]
   3: heap[1] = heap[last]
   4: heap[last] = temp
   5: heap[0]--
   6: down_adjust(heap, 1)
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: heap[0] > 1
   T: while [B7.1]
   Preds (2): B5 B8
   Succs (2): B6 B4

 [B8]
   1: heap[0] = n
   2: create(heap)
   Preds (1): B11
   Succs (1): B7

 [B9]
   1: i++
   Preds (1): B10
   Succs (1): B11

 [B10]
   1: scanf("%d", &heap[i])
   Preds (1): B11
   Succs (1): B9

 [B11]
   1: i <= n
   T: for (...; [B11.1]; ...)
   Preds (2): B9 B12
   Succs (2): B10 B8

 [B12]
   1: int heap[30];
   2: int n;
   3: int i;
   4: int last;
   5: int temp;
   6: printf("Enter no. of elements:")
   7: scanf("%d", &n)
   8: printf("\nEnter elements:")
   9: i = 1
   Preds (1): B13
   Succs (1): B11

 [B0 (EXIT)]
   Preds (1): B3


filename: /Users/yingcao/re/DataSets/Algorithms/C/HeapSort/V2/heap.c

function-decl: hp_create hp_create
param-decl: int; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: calloc(1, sizeof(heap_ctrl_t))
   2: heap_ctrl_t *h = (heap_ctrl_t *)calloc(1, sizeof(heap_ctrl_t));
   3: return h;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: hp_destroy hp_destroy
param-decl: heap_ctrl_t **; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: free((*heap)->array)
   2: memset(*heap, 0, sizeof(heap_ctrl_t))
   3: free(*heap)
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: hp_insert hp_insert
param-decl: heap_ctrl_t *; int32_t; 

 [B14 (ENTRY)]
   Succs (1): B13

 [B1]
   1: ++heap->next
   Preds (1): B8
   Succs (1): B0

 [B2]
   Preds (2): B3 B4
   Succs (1): B8

 [B3]
   1: heap->array[leaf] = heap->array[parent]
   2: heap->array[parent] = datas
   3: leaf = parent
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: heap->array[parent]->data <= data
   T: if [B4.1]
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   1: parent = (parent - 1) / 2
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: parent = (parent - 2) / 2
   Preds (1): B7
   Succs (1): B4

 [B7]
   1: parent % 2 == 0
   T: if [B7.1]
   Preds (1): B8
   Succs (2): B6 B5

 [B8]
   1: parent != 0
   T: while [B8.1]
   Preds (2): B2 B9
   Succs (2): B7 B1

 [B9]
   1: int32_t parent;
   2: int32_t leaf;
   3: calloc(1, sizeof(data_t))
   4: data_t *datas = (data_t *)calloc(1, sizeof(data_t));
   5: datas->data = data
   6: heap->array[heap->next] = datas
   7: parent = heap->next
   8: leaf = heap->next
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: return -2;
   Preds (1): B11
   Succs (1): B0

 [B11]
   T: if <null expr>
   Preds (1): B13
   Succs (2): B10 B9

 [B12]
   1: return -1;
   Preds (1): B13
   Succs (1): B0

 [B13]
   T: if <null expr>
   Preds (1): B14
   Succs (2): B12 B11

 [B0 (EXIT)]
   Preds (3): B1 B10 B12

function-decl: hp_remove hp_remove
param-decl: heap_ctrl_t *; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: --heap->next
   2: heap->array[0] = heap->array[heap->next]
   3: hp_heapfy(heap)
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: free(heap->array[0])
   Preds (1): B3
   Succs (1): B1

 [B3]
   T: if <null expr>
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return -3;
   Preds (1): B5
   Succs (1): B0

 [B5]
   1: heap->next == 0
   T: if [B5.1]
   Preds (1): B7
   Succs (2): B4 B3

 [B6]
   1: return -1;
   Preds (1): B7
   Succs (1): B0

 [B7]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (3): B1 B4 B6

function-decl: hp_heapfy hp_heapfy
param-decl: heap_ctrl_t *; 

 [B17 (ENTRY)]
   Succs (1): B16

 [B1]
   Preds (3): B3 B5 B8
   Succs (1): B13

 [B2]
   T: break;
   Preds (1): B4
   Succs (1): B0

 [B3]
   Preds (1): B4
   Succs (1): B1

 [B4]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B3 B2

 [B5]
   Preds (1): B6
   Succs (1): B1

 [B6]
   T: if <null expr>
   Preds (1): B12
   Succs (2): B5 B4

 [B7]
   T: break;
   Preds (1): B9
   Succs (1): B0

 [B8]
   Preds (1): B9
   Succs (1): B1

 [B9]
   T: if <null expr>
   Preds (1): B11
   Succs (2): B8 B7

 [B10]
   T: break;
   Preds (1): B11
   Succs (1): B0

 [B11]
   T: if <null expr>
   Preds (1): B12
   Succs (2): B10 B9

 [B12]
   T: if <null expr>
   Preds (1): B13
   Succs (2): B11 B6

 [B13]
   1: 1
   T: while [B13.1]
   Preds (2): B1 B14
   Succs (2): B12 NULL

 [B14]
   1: int32_t parent = 0;
   Preds (1): B16
   Succs (1): B13

 [B15]
   1: return -1;
   Preds (1): B16
   Succs (1): B0

 [B16]
   T: if <null expr>
   Preds (1): B17
   Succs (2): B15 B14

 [B0 (EXIT)]
   Preds (4): B2 B7 B10 B15

function-decl: hp_swap hp_swap
param-decl: data_t **; data_t **; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: data_t *tmp;
   2: tmp = *a
   3: *a = *b
   4: *b = tmp
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: hp_sort hp_sort
param-decl: heap_ctrl_t *; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: free(sorted)
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: ++i
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: heap->array[i] = sorted[i]
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < (int32_t)heap->next
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: i = 0
   Preds (1): B8
   Succs (1): B4

 [B6]
   1: --i
   Preds (1): B7
   Succs (1): B8

 [B7]
   1: sorted[i] = heap->array[0]
   2: heap->array[0] = heap->array[i]
   3: hp_heapfy(heap)
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: i >= 0
   T: for (...; [B8.1]; ...)
   Preds (2): B6 B9
   Succs (2): B7 B5

 [B9]
   1: data_t **sorted;
   2: int32_t i;
   3: i = (heap->next - 1)
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: return -1;
   Preds (1): B11
   Succs (1): B0

 [B11]
   T: if <null expr>
   Preds (1): B12
   Succs (2): B10 B9

 [B0 (EXIT)]
   Preds (2): B1 B10

function-decl: hp_get_head hp_get_head
param-decl: heap_ctrl_t *; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: return heap->array[0]->data;
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return -3;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: heap->next == 0
   T: if [B3.1]
   Preds (1): B5
   Succs (2): B2 B1

 [B4]
   1: return -1;
   Preds (1): B5
   Succs (1): B0

 [B5]
   T: if <null expr>
   Preds (1): B6
   Succs (2): B4 B3

 [B0 (EXIT)]
   Preds (3): B1 B2 B4

function-decl: hp_print hp_print
param-decl: heap_ctrl_t *; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: printf("[")
   2: printf("]\n")
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   T: if <null expr>
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/Algorithms/C/HeapSort/V2/main.c

function-decl: main main
param-decl: 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: heap_ctrl_t *h;
   2: hp_insert(h, 88)
   3: hp_insert(h, 85)
   4: hp_insert(h, 83)
   5: hp_insert(h, 72)
   6: hp_insert(h, 73)
   7: hp_insert(h, 42)
   8: hp_insert(h, 57)
   9: hp_insert(h, 6)
  10: hp_insert(h, 48)
  11: hp_insert(h, 60)
  12: hp_print(h)
  13: hp_sort(h)
  14: hp_print(h)
  15: hp_remove(h)
  16: hp_print(h)
  17: hp_remove(h)
  18: hp_print(h)
  19: hp_remove(h)
  20: hp_print(h)
  21: hp_remove(h)
  22: hp_print(h)
  23: hp_remove(h)
  24: hp_print(h)
  25: hp_remove(h)
  26: hp_print(h)
  27: hp_remove(h)
  28: hp_print(h)
  29: hp_destroy(&h)
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1


filename: /Users/yingcao/re/DataSets/Algorithms/C/HeapSort/V2/heap.h


filename: /Users/yingcao/re/DataSets/Algorithms/C/BitonicSort/BitonicSort.c

function-decl: main main
param-decl: int; char **; 

 [B12 (ENTRY)]
   Succs (1): B11

 [B1]
   1: free(array)
   2: return 0;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: printf("Sorting FAILED\n")
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: printf("Array sorted successfully\n")
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: enum Direction dir = ED_ascending;
   2: InitializeArray()
   3: Sort(dir)
   4: TestIfSorted(dir)
   T: if [B4.4]
   Preds (2): B5 B6
   Succs (2): B3 B2

 [B5]
   Preds (1): B6
   Succs (1): B4

 [B6]
   T: if <null expr>
   Preds (1): B8
   Succs (2): B5 B4

 [B7]
   1: printf("Usage:\n %s n\nwhere 2^n is the size of the array to be sorted and must be a positive number (max n value: 31, max recommended value: 24)\n", argv[0])
   2: return 1;
   Preds (2): B8 B9
   Succs (1): B0

 [B8]
   1: n > 31
   T: if [B9.3] || [B8.1]
   Preds (1): B9
   Succs (2): B7 B6

 [B9]
   1: atoi(argv[1])
   2: int n = atoi(argv[1]);
   3: n <= 0
   T: [B9.3] || ...
   Preds (1): B11
   Succs (2): B7 B8

 [B10]
   1: printf("Usage:\n %s n\nwhere 2^n is the size of the array to be sorted.\n", argv[0])
   2: return 1;
   Preds (1): B11
   Succs (1): B0

 [B11]
   1: argc != 2
   T: if [B11.1]
   Preds (1): B12
   Succs (2): B10 B9

 [B0 (EXIT)]
   Preds (3): B1 B7 B10

function-decl: Sort Sort
param-decl: enum Direction; 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: BitonicSort BitonicSort
param-decl: int; int; enum Direction; 

 [B4 (ENTRY)]
   Succs (1): B3

 [B1]
   1: BitonicSort(startingIndex, halfSize, ED_ascending)
   2: BitonicSort(startingIndex + halfSize, halfSize, ED_descending)
   3: BitonicMerge(startingIndex, size, dir)
   Preds (1): B3
   Succs (1): B0

 [B2]
   1: return;
   Preds (1): B3
   Succs (1): B0

 [B3]
   1: int halfSize = size / 2;
   2: halfSize < 1
   T: if [B3.2]
   Preds (1): B4
   Succs (2): B2 B1

 [B0 (EXIT)]
   Preds (2): B1 B2

function-decl: BitonicMerge BitonicMerge
param-decl: int; int; enum Direction; 

 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: BitonicMerge(startingIndex, halfSize, dir)
   2: BitonicMerge(startingIndex + halfSize, halfSize, dir)
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: CompareAndSwap(i, i + halfSize, dir)
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < startingIndex + halfSize
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int i = startingIndex;
   Preds (1): B7
   Succs (1): B4

 [B6]
   1: return;
   Preds (1): B7
   Succs (1): B0

 [B7]
   1: int halfSize = size / 2;
   2: halfSize < 1
   T: if [B7.2]
   Preds (1): B8
   Succs (2): B6 B5

 [B0 (EXIT)]
   Preds (2): B1 B6

function-decl: TestIfSorted TestIfSorted
param-decl: enum Direction; 

 [B5 (ENTRY)]
   Succs (1): B2

 [B1]
   1: return 0;
   Preds (1): B2(Unreachable)
   Succs (1): B0

 [B2]
   1: dir (ImplicitCastExpr, IntegralCast, unsigned int)
   T: switch [B2.1]
   Preds (1): B5
   Succs (3): B3 B4 B1(Unreachable)

 [B3]
  case ED_descending:
   1: return 1;
   Preds (1): B2
   Succs (1): B0

 [B4]
  case ED_ascending:
   1: return 1;
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (3): B1 B3 B4

function-decl: InitializeArray InitializeArray
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: PrintArray PrintArray
param-decl: 

 [B1 (ENTRY)]
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: CompareAndSwap CompareAndSwap
param-decl: int; int; enum Direction; 

 [B3 (ENTRY)]
   Succs (1): B2

 [B1]
   1: int t = array[elementIndex];
   2: array[elementIndex] = array[elementLaterIndex]
   3: array[elementLaterIndex] = t
   Preds (1): B2
   Succs (1): B0

 [B2]
   1: dir == (array[elementIndex] > array[elementLaterIndex])
   T: if [B2.1]
   Preds (1): B3
   Succs (2): B1 B0

 [B0 (EXIT)]
   Preds (2): B1 B2


filename: /Users/yingcao/re/DataSets/Algorithms/C/Postman Sort/Postman_Sort.c

function-decl: main main
param-decl: 

 [B42 (ENTRY)]
   Succs (1): B41

 [B1]
   1: printf("\n")
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: printf("%d ", array1[i])
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < count
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: printf("\nSorted Array (Postman sort) :")
   2: i = 0
   Preds (1): B15
   Succs (1): B4

 [B6]
   Preds (1): B7
   Succs (1): B15

 [B7]
   1: n = n / 10
   Preds (1): B13
   Succs (1): B6

 [B8]
   Preds (1): B9
   Succs (1): B13

 [B9]
   1: arrange(i, j)
   2: i = j
   Preds (1): B11
   Succs (1): B8

 [B10]
   1: j++
   Preds (1): B11
   Succs (1): B11

 [B11]
   1: t1 == (array[j] / n)
   T: for (...; [B11.1]; ...)
   Preds (2): B10 B12
   Succs (2): B10 B9

 [B12]
   1: t1 = array[i] / n
   2: j = i + 1
   Preds (1): B13
   Succs (1): B11

 [B13]
   1: i < count
   T: for (...; [B13.1]; )
   Preds (2): B8 B14
   Succs (2): B12 B7

 [B14]
   1: i = 0
   Preds (1): B15
   Succs (1): B13

 [B15]
   1: n >= 1
   T: while [B15.1]
   Preds (2): B6 B23
   Succs (2): B14 B5

 [B16]
   1: i++
   Preds (1): B17
   Succs (1): B23

 [B17]
   1: temp = array1[t]
   2: array1[t] = array1[i]
   3: array1[i] = temp
   4: temp = array[t]
   5: array[t] = array[i]
   6: array[i] = temp
   Preds (1): B21
   Succs (1): B16

 [B18]
   1: j++
   Preds (2): B19 B20
   Succs (1): B21

 [B19]
   1: max = array[j] / n
   2: t = j
   Preds (1): B20
   Succs (1): B18

 [B20]
   1: max > (array[j] / n)
   T: if [B20.1]
   Preds (1): B21
   Succs (2): B19 B18

 [B21]
   1: j < count
   T: for (...; [B21.1]; ...)
   Preds (2): B18 B22
   Succs (2): B20 B17

 [B22]
   1: max = array[i] / n
   2: t = i
   3: j = i + 1
   Preds (1): B23
   Succs (1): B21

 [B23]
   1: i < count
   T: for (...; [B23.1]; ...)
   Preds (2): B16 B24
   Succs (2): B22 B15

 [B24]
   1: i = 0
   Preds (1): B27
   Succs (1): B23

 [B25]
   Preds (1): B26
   Succs (1): B27

 [B26]
   1: n = n * 10
   Preds (1): B27
   Succs (1): B25

 [B27]
   1: --maxdigits
   T: while [B27.1]
   Preds (2): B25 B36
   Succs (2): B26 B24

 [B28]
   1: i++
   Preds (1): B29
   Succs (1): B36

 [B29]
   1: c = 0
   Preds (2): B30 B31
   Succs (1): B28

 [B30]
   1: maxdigits = c
   Preds (1): B31
   Succs (1): B29

 [B31]
   1: maxdigits < c
   T: if [B31.1]
   Preds (1): B34
   Succs (2): B30 B29

 [B32]
   Preds (1): B33
   Succs (1): B34

 [B33]
   1: c++
   2: t = t / 10
   Preds (1): B34
   Succs (1): B32

 [B34]
   1: t > 0
   T: while [B34.1]
   Preds (2): B32 B35
   Succs (2): B33 B31

 [B35]
   1: t = array[i]
   Preds (1): B36
   Succs (1): B34

 [B36]
   1: i < count
   T: for (...; [B36.1]; ...)
   Preds (2): B28 B37
   Succs (2): B35 B27

 [B37]
   1: i = 0
   Preds (1): B40
   Succs (1): B36

 [B38]
   1: i++
   Preds (1): B39
   Succs (1): B40

 [B39]
   1: scanf("%d", &array[i])
   2: array1[i] = array[i]
   Preds (1): B40
   Succs (1): B38

 [B40]
   1: i < count
   T: for (...; [B40.1]; ...)
   Preds (2): B38 B41
   Succs (2): B39 B37

 [B41]
   1: int t1;
   2: int t2;
   3: int k;
   4: int t;
   5: int n = 1;
   6: printf("Enter size of array :")
   7: scanf("%d", &count)
   8: printf("Enter elements into array :")
   9: i = 0
   Preds (1): B42
   Succs (1): B40

 [B0 (EXIT)]
   Preds (1): B1

function-decl: arrange arrange
param-decl: int; int; 

 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: i++
   Preds (1): B5
   Succs (1): B7

 [B2]
   1: j++
   Preds (2): B3 B4
   Succs (1): B5

 [B3]
   1: temp = array1[i]
   2: array1[i] = array1[j]
   3: array1[j] = temp
   4: temp = (array[i] % 10)
   5: array[i] = (array[j] % 10)
   6: array[j] = temp
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: array1[i] > array1[j]
   T: if [B4.1]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: j < n
   T: for (...; [B5.1]; ...)
   Preds (2): B2 B6
   Succs (2): B4 B1

 [B6]
   1: j = i + 1
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: i < n - 1
   T: for (...; [B7.1]; ...)
   Preds (2): B1 B8
   Succs (2): B6 B0

 [B8]
   1: i = k
   Preds (1): B9
   Succs (1): B7

 [B0 (EXIT)]
   Preds (1): B7


filename: /Users/yingcao/re/DataSets/Algorithms/C/Selection Sort/selection.c

function-decl: swap swap
param-decl: int *; int *; 

 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: int temp = *xp;
   2: *xp = *yp
   3: *yp = temp
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1

function-decl: selectionSort selectionSort
param-decl: int *; int; 

 [B10 (ENTRY)]
   Succs (1): B9

 [B1]
   1: i++
   Preds (1): B2
   Succs (1): B8

 [B2]
   1: swap(&arr[min_idx], &arr[i])
   Preds (1): B6
   Succs (1): B1

 [B3]
   1: j++
   Preds (2): B4 B5
   Succs (1): B6

 [B4]
   1: min_idx = j
   Preds (1): B5
   Succs (1): B3

 [B5]
   1: arr[j] < arr[min_idx]
   T: if [B5.1]
   Preds (1): B6
   Succs (2): B4 B3

 [B6]
   1: j < n
   T: for (...; [B6.1]; ...)
   Preds (2): B3 B7
   Succs (2): B5 B2

 [B7]
   1: min_idx = i
   2: j = i + 1
   Preds (1): B8
   Succs (1): B6

 [B8]
   1: i < n - 1
   T: for (...; [B8.1]; ...)
   Preds (2): B1 B9
   Succs (2): B7 B0

 [B9]
   1: int i;
   2: int j;
   3: int min_idx;
   4: i = 0
   Preds (1): B10
   Succs (1): B8

 [B0 (EXIT)]
   Preds (1): B8

function-decl: printArray printArray
param-decl: int *; int; 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: printf("\n")
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: printf("%d ", arr[i])
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < size
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int i;
   2: i = 0
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1

function-decl: main main
param-decl: 

 [B6 (ENTRY)]
   Succs (1): B5

 [B1]
   1: selectionSort(arr, n)
   2: printf("Sorted array: \n")
   3: printArray(arr, n)
   4: return 0;
   Preds (1): B4
   Succs (1): B0

 [B2]
   1: i++
   Preds (1): B3
   Succs (1): B4

 [B3]
   1: scanf("%d", &arr[i])
   Preds (1): B4
   Succs (1): B2

 [B4]
   1: i < n
   T: for (...; [B4.1]; ...)
   Preds (2): B2 B5
   Succs (2): B3 B1

 [B5]
   1: int arr[100];
   2: int i;
   3: int n;
   4: printf("Enter size of array=")
   5: scanf("%d", &n)
   6: printf("Enter array elements=")
   7: i = 0
   Preds (1): B6
   Succs (1): B4

 [B0 (EXIT)]
   Preds (1): B1


